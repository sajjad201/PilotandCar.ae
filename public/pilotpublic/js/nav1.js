(function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
            return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
})
([(function(module, exports, __webpack_require__) {
    (function(global) {
        window.jQuery = window.$ = __webpack_require__(27);
        global.Tether = __webpack_require__(76);
        var processInclude = __webpack_require__(1);
        $(document).ready(function() {
            global.viewport = __webpack_require__(77)();
            processInclude(__webpack_require__(79));
            processInclude(__webpack_require__(83));
            processInclude(__webpack_require__(84));
            processInclude(__webpack_require__(85));
            processInclude(__webpack_require__(100));
            processInclude(__webpack_require__(101));
            processInclude(__webpack_require__(102));
            processInclude(__webpack_require__(103));
            processInclude(__webpack_require__(28));
            processInclude(__webpack_require__(104));
            if (window.isProduction) {
                processInclude(__webpack_require__(105));
            } else {
                processInclude(__webpack_require__(106));
            }
            processInclude(__webpack_require__(107));
            processInclude(__webpack_require__(108));
            processInclude(__webpack_require__(110));
            processInclude(__webpack_require__(111));
        });
        __webpack_require__(35);
        __webpack_require__(44);
        __webpack_require__(45);
        __webpack_require__(47);
        __webpack_require__(48);
        __webpack_require__(49);
        __webpack_require__(50);
    }.call(exports, (function() {
        return this;
    }())))
}), (function(module, exports) {
    'use strict';
    module.exports = function(include) {
        if (typeof include === 'function') {
            include();
        } else if (typeof include === 'object') {
            Object.keys(include).forEach(function(key) {
                if (typeof include[key] === 'function') {
                    include[key]();
                }
            });
        }
    };
}), , (function(module, exports) {
    'use strict';
    module.exports = function(formElement, payload) {
        $('.form-group.has-danger', formElement).removeClass('has-danger');
        $('.alert', formElement).remove();
        if (typeof payload === 'object' && payload.fields) {
            Object.keys(payload.fields).forEach(function(key) {
                if (payload.fields[key]) {
                    var feedbackElement = $(formElement).find('[name="' + key + '"]').closest('.form-group').find('.form-control-feedback');
                    if (feedbackElement.length > 0) {
                        if (Array.isArray(payload[key])) {
                            feedbackElement.html(payload.fields[key].join('<br/>'));
                        } else {
                            feedbackElement.html(payload.fields[key]);
                        }
                        feedbackElement.parent('.form-group.has-success').removeClass('has-success');
                        feedbackElement.parent('.form-group').addClass('has-danger');
                    }
                }
            });
        }
        var form = $(formElement).prop('tagName') === 'FORM' ? $(formElement) : $(formElement).parents('form');
        if (payload && payload.error) {
            var errorMsg = Array.isArray(payload.error) ? payload.error.join('<br/>') : payload.error;
            form.prepend('<div class="alert alert-danger">' + errorMsg + '</div>');
        } else if (payload && payload.successHtml && payload.successTarget) {
            $(payload.successTarget).html(payload.successHtml);
        } else if (payload && payload.success && payload.successMsg) {
            var successMsg = Array.isArray(payload.successMsg) ? payload.successMsg.join('<br/>') : payload.successMsg;
            form.prepend('<div class="alert alert-success">' + successMsg + '</div>');
        }
    };
}), , (function(module, exports, __webpack_require__) {
    'use strict';
    window.hyperform = window.hyperform || __webpack_require__(6);
    var floatl = __webpack_require__(7);

    function initializeSelectMasking() {
        var select = $('.select-mask select');
        select.off('selectmask').on('change.selectmask updatemask.selectmask', function(e) {
            if (e.target && e.target.value) {
                $(e.target).parents('.select-mask').find('.select-mask__overlay').addClass('select-populated').find('.select-mask__overlay__value').text(e.target.options[e.target.selectedIndex].text);
            }
        });
        select.not('[data-no-init]').trigger('updatemask.selectmask');
    }

    function initializePlaceholderFix() {
        jQuery('input[placeholder]').each(function() {
            var placeholder = $(this).attr('placeholder');
            if (placeholder !== undefined && placeholder.indexOf('ÃŸ') !== -1) {
                $(this).addClass('placeholder-fix');
                var uppercase = placeholder.replace(/([a-z])/g, function(a) {
                    return String.fromCharCode(a.charCodeAt() ^ 32);
                });
                $(this).attr('placeholder', uppercase);
                $(this).parent().find('label').each(function() {
                    $(this).addClass('placeholder-fix');
                    var label = $(this).text();
                    var uppercaselabel = label.replace(/([a-z])/g, function(a) {
                        return String.fromCharCode(a.charCodeAt() ^ 32);
                    });
                    $(this).text(uppercaselabel);
                });
            }
        });
    }

    function initializeTextAreaCounterEvent() {
        $(document).on('input', 'textarea.has-counter', countLeftSymbols);
    }

    function countLeftSymbols() {
        var textlength = $(this).val().length;
        var maxLength = parseInt($(this).attr('maxlength'), 10);
        var leftSymbols = maxLength - textlength;
        $(this).closest('.form-group').find('.left-symbols').text(leftSymbols);
    }

    function setSelectInputsDefaultValueEvent() {
        $(window).on('form:reset', function(e, form) {
            var selectInputs = $(form).find('select');
            if (selectInputs.length > 0) {
                $.each(selectInputs, function(index, select) {
                    var defaultOption = $(select).find('option[data-default]');
                    if (defaultOption.length === 1) {
                        $(select).val(defaultOption.val()).change();
                    }
                });
            }
        });
    }

    function resetTextareaLeftSymbolsCounterEvent() {
        $(window).on('form:reset', function(e, form) {
            var textareas = $(form).find('textarea');
            if (textareas.length > 0) {
                $.each(textareas, function(index, textarea) {
                    var leftSymbolsSpan = $(textarea).closest('.form-group').find('.left-symbols');
                    if (leftSymbolsSpan.length === 1) {
                        var maxLength = parseInt($(textarea).attr('maxlength'), 10);
                        leftSymbolsSpan.text(maxLength);
                    }
                });
            }
        });
    }

    function initializeQtySelector() {
        var qtySelector = $('.quantity-select');
        if (qtySelector.length > 0) {
            qtySelector.trigger('change');
        }
    }

    function initializeDom() {
        __webpack_require__(8).init();
        $('.floatl').each(function() {
            new floatl(this);
        });
        initializeSelectMasking();
        initializePlaceholderFix();
        initializeTextAreaCounterEvent();
        setSelectInputsDefaultValueEvent();
        resetTextareaLeftSymbolsCounterEvent();
        initializeQtySelector();
    }

    function initialize() {
        $(document).ready(initializeDom);
    }
    module.exports = {
        init: initialize
    };
}), (function(module, exports) { /*!hyperform.js.org*/
    'use strict';
    var workingDefaultPrevented = function() {
        var e = document.createEvent('Event');
        e.initEvent('foo', true, true);
        e.preventDefault();
        return e.defaultPrevented;
    }();
    if (!workingDefaultPrevented) {
        (function() {
            var origPreventDefault = window.Event.prototype.preventDefault;
            window.Event.prototype.preventDefault = function() {
                if (!this.cancelable) {
                    return;
                }
                origPreventDefault.call(this);
                Object.defineProperty(this, 'defaultPrevented', {
                    get: function get() {
                        return true;
                    },
                    configurable: true
                });
            };
        })();
    }

    function create_event(name) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _ref$bubbles = _ref.bubbles;
        var bubbles = _ref$bubbles === undefined ? true : _ref$bubbles;
        var _ref$cancelable = _ref.cancelable;
        var cancelable = _ref$cancelable === undefined ? false : _ref$cancelable;
        var event = document.createEvent('Event');
        event.initEvent(name, bubbles, cancelable);
        return event;
    }

    function trigger_event(element, event) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _ref2$bubbles = _ref2.bubbles;
        var bubbles = _ref2$bubbles === undefined ? true : _ref2$bubbles;
        var _ref2$cancelable = _ref2.cancelable;
        var cancelable = _ref2$cancelable === undefined ? false : _ref2$cancelable;
        var payload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        if (!(event instanceof window.Event)) {
            event = create_event(event, {
                bubbles: bubbles,
                cancelable: cancelable
            });
        }
        for (var key in payload) {
            if (payload.hasOwnProperty(key)) {
                event[key] = payload[key];
            }
        }
        element.dispatchEvent(event);
        return event;
    }
    var ep = window.Element.prototype;
    var native_matches = ep.matches || ep.matchesSelector || ep.msMatchesSelector || ep.webkitMatchesSelector;

    function matches(element, selector) {
        return native_matches.call(element, selector);
    }

    function mark(obj) {
        if (['object', 'function'].indexOf(typeof obj) > -1) {
            delete obj.__hyperform;
            Object.defineProperty(obj, '__hyperform', {
                configurable: true,
                enumerable: false,
                value: true
            });
        }
        return obj;
    }
    var store = new WeakMap();
    var message_store = {
        set: function set(element, message) {
            var is_custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            if (element instanceof window.HTMLFieldSetElement) {
                var wrapped_form = get_wrapper(element);
                if (wrapped_form && !wrapped_form.settings.extendFieldset) {
                    return message_store;
                }
            }
            if (typeof message === 'string') {
                message = new String(message);
            }
            if (is_custom) {
                message.is_custom = true;
            }
            mark(message);
            store.set(element, message);
            if ('_original_setCustomValidity' in element) {
                element._original_setCustomValidity(message.toString());
            }
            return message_store;
        },
        get: function get(element) {
            var message = store.get(element);
            if (message === undefined && '_original_validationMessage' in element) {
                message = new String(element._original_validationMessage);
            }
            return message ? message : new String('');
        },
        delete: function _delete(element) {
            var is_custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if ('_original_setCustomValidity' in element) {
                element._original_setCustomValidity('');
            }
            var message = store.get(element);
            if (message && is_custom && !message.is_custom) {
                return false;
            }
            return store.delete(element);
        }
    };
    var uid = 0;

    function generate_id() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hf_';
        return prefix + uid++ + Math.random().toString(36).substr(2);
    }

    function get_radiogroup(element) {
        if (element.form) {
            return Array.prototype.filter.call(element.form.elements, function(radio) {
                return radio.type === 'radio' && radio.name === element.name;
            });
        }
        return [element];
    }
    var warningsCache = new WeakMap();
    var DefaultRenderer = {
        attachWarning: function attachWarning(warning, element) {
            element.parentNode.insertBefore(warning, element.nextSibling);
        },
        detachWarning: function detachWarning(warning, element) {
            if (warning.parentNode) {
                warning.parentNode.removeChild(warning);
            }
        },
        showWarning: function showWarning(element) {
            var whole_form_validated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (whole_form_validated && element.type === 'radio' && get_radiogroup(element)[0] !== element) {
                return;
            }
            var msg = message_store.get(element).toString();
            var warning = warningsCache.get(element);
            if (msg) {
                if (!warning) {
                    var wrapper = get_wrapper(element);
                    warning = document.createElement('div');
                    warning.className = wrapper && wrapper.settings.classes.warning || 'hf-warning';
                    warning.id = generate_id();
                    warning.setAttribute('aria-live', 'polite');
                    warningsCache.set(element, warning);
                }
                element.setAttribute('aria-errormessage', warning.id);
                if (!element.hasAttribute('aria-describedby')) {
                    element.setAttribute('aria-describedby', warning.id);
                }
                Renderer.setMessage(warning, msg, element);
                Renderer.attachWarning(warning, element);
            } else if (warning && warning.parentNode) {
                if (element.getAttribute('aria-describedby') === warning.id) {
                    element.removeAttribute('aria-describedby');
                }
                element.removeAttribute('aria-errormessage');
                Renderer.detachWarning(warning, element);
            }
        },
        setMessage: function setMessage(warning, message, element) {
            warning.textContent = message;
        }
    };
    var Renderer = {
        attachWarning: DefaultRenderer.attachWarning,
        detachWarning: DefaultRenderer.detachWarning,
        showWarning: DefaultRenderer.showWarning,
        setMessage: DefaultRenderer.setMessage,
        set: function set(renderer, action) {
            if (renderer.indexOf('_') > -1) {
                console.log('Renderer.set: please use camelCase names. ' + renderer + ' will be removed in the next non-patch release.');
                renderer = renderer.replace(/_([a-z])/g, function(g) {
                    return g[1].toUpperCase();
                });
            }
            if (!action) {
                action = DefaultRenderer[renderer];
            }
            Renderer[renderer] = action;
        },
        getWarning: function getWarning(element) {
            return warningsCache.get(element);
        }
    };
    var registry = Object.create(null);

    function call_hook(hook) {
        var result;
        var call_args = Array.prototype.slice.call(arguments, 1);
        if (hook in registry) {
            result = registry[hook].reduce(function(args) {
                return function(previousResult, currentAction) {
                    var interimResult = currentAction.apply({
                        state: previousResult,
                        hook: hook
                    }, args);
                    return interimResult !== undefined ? interimResult : previousResult;
                };
            }(call_args), result);
        }
        return result;
    }

    function do_filter(hook, initial_value) {
        var result = initial_value;
        var call_args = Array.prototype.slice.call(arguments, 1);
        if (hook in registry) {
            result = registry[hook].reduce(function(previousResult, currentAction) {
                call_args[0] = previousResult;
                var interimResult = currentAction.apply({
                    state: previousResult,
                    hook: hook
                }, call_args);
                return interimResult !== undefined ? interimResult : previousResult;
            }, result);
        }
        return result;
    }

    function remove_hook(hook, action) {
        if (hook in registry) {
            for (var i = 0; i < registry[hook].length; i++) {
                if (registry[hook][i] === action) {
                    registry[hook].splice(i, 1);
                    break;
                }
            }
        }
    }

    function add_hook(hook, action, position) {
        if (!(hook in registry)) {
            registry[hook] = [];
        }
        if (position === undefined) {
            position = registry[hook].length;
        }
        registry[hook].splice(position, 0, action);
    }
    var dates = ['datetime', 'date', 'month', 'week', 'time'];
    var plain_numbers = ['number', 'range'];
    var numbers = dates.concat(plain_numbers, 'datetime-local');
    var type_checked = ['email', 'url'];
    var input_checked = ['email', 'date', 'month', 'week', 'time', 'datetime', 'datetime-local', 'number', 'range', 'color'];
    var text_types = ['text', 'search', 'tel', 'password'].concat(type_checked);
    var validation_candidates = ['checkbox', 'color', 'file', 'image', 'radio', 'submit'].concat(numbers, text_types);
    var inputs = ['button', 'hidden', 'reset'].concat(validation_candidates);
    var non_inputs = ['select-one', 'select-multiple', 'textarea'];

    function get_type(element) {
        if (element instanceof window.HTMLTextAreaElement) {
            return 'textarea';
        } else if (element instanceof window.HTMLSelectElement) {
            return element.hasAttribute('multiple') ? 'select-multiple' : 'select-one';
        } else if (element instanceof window.HTMLButtonElement) {
            return (element.getAttribute('type') || 'submit').toLowerCase();
        } else if (element instanceof window.HTMLInputElement) {
            var attr = (element.getAttribute('type') || '').toLowerCase();
            if (attr && inputs.indexOf(attr) > -1) {
                return attr;
            } else {
                return element.type || 'text';
            }
        }
        return '';
    }

    function is_in_disallowed_parent(element) {
        var p = element.parentNode;
        while (p && p.nodeType === 1) {
            if (p instanceof window.HTMLFieldSetElement && p.hasAttribute('disabled')) {
                return true;
            } else if (p.nodeName.toUpperCase() === 'DATALIST') {
                return true;
            } else if (p === element.form) {
                break;
            }
            p = p.parentNode;
        }
        return false;
    }

    function is_validation_candidate(element) {
        var filtered = do_filter('is_validation_candidate', null, element);
        if (filtered !== null) {
            return !!filtered;
        }
        if (element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement) {
            var type = get_type(element);
            if (non_inputs.indexOf(type) > -1 || validation_candidates.indexOf(type) > -1) {
                if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
                    var wrapped_form = get_wrapper(element);
                    if (wrapped_form && !wrapped_form.settings.novalidateOnElements || !element.hasAttribute('novalidate') && !element.noValidate) {
                        if (!is_in_disallowed_parent(element)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function format_date(date) {
        var part = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        switch (part) {
            case 'date':
                return (date.toLocaleDateString || date.toDateString).call(date);
            case 'time':
                return (date.toLocaleTimeString || date.toTimeString).call(date);
            case 'month':
                return 'toLocaleDateString' in date ? date.toLocaleDateString(undefined, {
                    year: 'numeric',
                    month: '2-digit'
                }) : date.toDateString();
            default:
                return (date.toLocaleString || date.toString).call(date);
        }
    }

    function sprintf(str) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }
        var args_length = args.length;
        var global_index = 0;
        return str.replace(/%([0-9]+\$)?([sl])/g, function(match, position, type) {
            var local_index = global_index;
            if (position) {
                local_index = Number(position.replace(/\$$/, '')) - 1;
            }
            global_index += 1;
            var arg = '';
            if (args_length > local_index) {
                arg = args[local_index];
            }
            if (arg instanceof Date || typeof arg === 'number' || arg instanceof Number) {
                if (type === 'l') {
                    arg = (arg.toLocaleString || arg.toString).call(arg);
                } else {
                    arg = arg.toString();
                }
            }
            return arg;
        });
    }

    function get_week_of_year(d) {
        d = new Date(+d);
        d.setUTCHours(0, 0, 0);
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        var yearStart = new Date(d.getUTCFullYear(), 0, 1);
        var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
        return [d.getUTCFullYear(), weekNo];
    }

    function pad(num) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        var s = num + '';
        while (s.length < size) {
            s = '0' + s;
        }
        return s;
    }

    function date_to_string(date, element_type) {
        if (!(date instanceof Date)) {
            return null;
        }
        switch (element_type) {
            case 'datetime':
                return date_to_string(date, 'date') + 'T' + date_to_string(date, 'time');
            case 'datetime-local':
                return sprintf('%s-%s-%sT%s:%s:%s.%s', date.getFullYear(), pad(date.getMonth() + 1), pad(date.getDate()), pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds()), pad(date.getMilliseconds(), 3)).replace(/(:00)?\.000$/, '');
            case 'date':
                return sprintf('%s-%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1), pad(date.getUTCDate()));
            case 'month':
                return sprintf('%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1));
            case 'week':
                var params = get_week_of_year(date);
                return sprintf.call(null, '%s-W%s', params[0], pad(params[1]));
            case 'time':
                return sprintf('%s:%s:%s.%s', pad(date.getUTCHours()), pad(date.getUTCMinutes()), pad(date.getUTCSeconds()), pad(date.getUTCMilliseconds(), 3)).replace(/(:00)?\.000$/, '');
        }
        return null;
    }

    function get_date_from_week(week, year) {
        var date = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
        if (date.getUTCDay() <= 4) {
            date.setUTCDate(date.getUTCDate() - date.getUTCDay() + 1);
        } else {
            date.setUTCDate(date.getUTCDate() + 8 - date.getUTCDay());
        }
        return date;
    }

    function string_to_date(string, element_type) {
        var date = void 0;
        switch (element_type) {
            case 'datetime':
                if (!/^([0-9]{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\.([0-9]{1,3}))?)?$/.test(string)) {
                    return null;
                }
                date = new Date(string + 'z');
                return isNaN(date.valueOf()) ? null : date;
            case 'date':
                if (!/^([0-9]{4})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/.test(string)) {
                    return null;
                }
                date = new Date(string);
                return isNaN(date.valueOf()) ? null : date;
            case 'month':
                if (!/^([0-9]{4})-(0[1-9]|1[012])$/.test(string)) {
                    return null;
                }
                date = new Date(string);
                return isNaN(date.valueOf()) ? null : date;
            case 'week':
                if (!/^([0-9]{4})-W(0[1-9]|[1234][0-9]|5[0-3])$/.test(string)) {
                    return null;
                }
                return get_date_from_week(Number(RegExp.$2), Number(RegExp.$1));
            case 'time':
                if (!/^([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\.([0-9]{1,3}))?)?$/.test(string)) {
                    return null;
                }
                date = new Date('1970-01-01T' + string + 'z');
                return date;
        }
        return null;
    }

    function string_to_number(string, element_type) {
        var rval = string_to_date(string, element_type);
        if (rval !== null) {
            return +rval;
        }
        return Number(string);
    }
    var catalog = {
        en: {
            TextTooLong: 'Please shorten this text to %l characters or less (you are currently using %l characters).',
            ValueMissing: 'Please fill out this field.',
            CheckboxMissing: 'Please check this box if you want to proceed.',
            RadioMissing: 'Please select one of these options.',
            FileMissing: 'Please select a file.',
            SelectMissing: 'Please select an item in the list.',
            InvalidEmail: 'Please enter an email address.',
            InvalidURL: 'Please enter a URL.',
            PatternMismatch: 'Please match the requested format.',
            PatternMismatchWithTitle: 'Please match the requested format: %l.',
            NumberRangeOverflow: 'Please select a value that is no more than %l.',
            DateRangeOverflow: 'Please select a value that is no later than %l.',
            TimeRangeOverflow: 'Please select a value that is no later than %l.',
            NumberRangeUnderflow: 'Please select a value that is no less than %l.',
            DateRangeUnderflow: 'Please select a value that is no earlier than %l.',
            TimeRangeUnderflow: 'Please select a value that is no earlier than %l.',
            StepMismatch: 'Please select a valid value. The two nearest valid values are %l and %l.',
            StepMismatchOneValue: 'Please select a valid value. The nearest valid value is %l.',
            BadInputNumber: 'Please enter a number.'
        }
    };
    var language = 'en';
    var base_lang = 'en';

    function set_language(newlang) {
        language = newlang;
        base_lang = newlang.replace(/[-_].*/, '');
    }

    function add_translation(lang, new_catalog) {
        if (!(lang in catalog)) {
            catalog[lang] = {};
        }
        for (var key in new_catalog) {
            if (new_catalog.hasOwnProperty(key)) {
                catalog[lang][key] = new_catalog[key];
            }
        }
    }

    function _(s) {
        if (language in catalog && s in catalog[language]) {
            return catalog[language][s];
        } else if (base_lang in catalog && s in catalog[base_lang]) {
            return catalog[base_lang][s];
        } else if (s in catalog.en) {
            return catalog.en[s];
        }
        return s;
    }
    var default_step = {
        'datetime-local': 60,
        datetime: 60,
        time: 60
    };
    var step_scale_factor = {
        'datetime-local': 1000,
        datetime: 1000,
        date: 86400000,
        week: 604800000,
        time: 1000
    };
    var default_step_base = {
        week: -259200000
    };
    var default_min = {
        range: 0
    };
    var default_max = {
        range: 100
    };

    function get_next_valid(element) {
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var type = get_type(element);
        var aMin = element.getAttribute('min');
        var min = default_min[type] || NaN;
        if (aMin) {
            var pMin = string_to_number(aMin, type);
            if (!isNaN(pMin)) {
                min = pMin;
            }
        }
        var aMax = element.getAttribute('max');
        var max = default_max[type] || NaN;
        if (aMax) {
            var pMax = string_to_number(aMax, type);
            if (!isNaN(pMax)) {
                max = pMax;
            }
        }
        var aStep = element.getAttribute('step');
        var step = default_step[type] || 1;
        if (aStep && aStep.toLowerCase() === 'any') {
            return [_('any value'), _('any value')];
        } else if (aStep) {
            var pStep = string_to_number(aStep, type);
            if (!isNaN(pStep)) {
                step = pStep;
            }
        }
        var default_value = string_to_number(element.getAttribute('value'), type);
        var value = string_to_number(element.value || element.getAttribute('value'), type);
        if (isNaN(value)) {
            return [_('any valid value'), _('any valid value')];
        }
        var step_base = !isNaN(min) ? min : !isNaN(default_value) ? default_value : default_step_base[type] || 0;
        var scale = step_scale_factor[type] || 1;
        var prev = step_base + Math.floor((value - step_base) / (step * scale)) * (step * scale) * n;
        var next = step_base + (Math.floor((value - step_base) / (step * scale)) + 1) * (step * scale) * n;
        if (prev < min) {
            prev = null;
        } else if (prev > max) {
            prev = max;
        }
        if (next > max) {
            next = null;
        } else if (next < min) {
            next = min;
        }
        if (dates.indexOf(type) > -1) {
            prev = date_to_string(new Date(prev), type);
            next = date_to_string(new Date(next), type);
        }
        return [prev, next];
    }

    function unicode_string_length(str) {
        return str.match(/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g).length;
    }
    var store$1 = new WeakMap();
    var custom_messages = {
        set: function set(element, validator, message) {
            var messages = store$1.get(element) || {};
            messages[validator] = message;
            store$1.set(element, messages);
            return custom_messages;
        },
        get: function get(element, validator) {
            var _default = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var messages = store$1.get(element);
            if (messages === undefined || !(validator in messages)) {
                var data_id = 'data-' + validator.replace(/[A-Z]/g, '-$&').toLowerCase();
                if (element.hasAttribute(data_id)) {
                    return element.getAttribute(data_id);
                }
                return _default;
            }
            return messages[validator];
        },
        delete: function _delete(element) {
            var validator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (!validator) {
                return store$1.delete(element);
            }
            var messages = store$1.get(element) || {};
            if (validator in messages) {
                delete messages[validator];
                store$1.set(element, messages);
                return true;
            }
            return false;
        }
    };
    var internal_registry = new WeakMap();
    var custom_validator_registry = {
        set: function set(element, validator) {
            var current = internal_registry.get(element) || [];
            current.push(validator);
            internal_registry.set(element, current);
            return custom_validator_registry;
        },
        get: function get(element) {
            return internal_registry.get(element) || [];
        },
        delete: function _delete(element) {
            return internal_registry.delete(element);
        }
    };

    function test_bad_input(element) {
        var type = get_type(element);
        if (input_checked.indexOf(type) === -1) {
            return true;
        }
        if (!element.value) {
            if ('_original_validity' in element && !element._original_validity.__hyperform) {
                return !element._original_validity.badInput;
            }
            return true;
        }
        var result = true;
        switch (type) {
            case 'color':
                result = /^#[a-f0-9]{6}$/.test(element.value);
                break;
            case 'number':
            case 'range':
                result = !isNaN(Number(element.value));
                break;
            case 'datetime':
            case 'date':
            case 'month':
            case 'week':
            case 'time':
                result = string_to_date(element.value, type) !== null;
                break;
            case 'datetime-local':
                result = /^([0-9]{4,})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\.([0-9]{1,3}))?)?$/.test(element.value);
                break;
            case 'tel':
                break;
            case 'email':
                break;
        }
        return result;
    }

    function test_max(element) {
        var type = get_type(element);
        if (!element.value || !element.hasAttribute('max')) {
            return true;
        }
        var value = void 0,
            max = void 0;
        if (dates.indexOf(type) > -1) {
            value = string_to_date(element.value, type);
            value = value === null ? NaN : +value;
            max = string_to_date(element.getAttribute('max'), type);
            max = max === null ? NaN : +max;
        } else {
            value = Number(element.value);
            max = Number(element.getAttribute('max'));
        }
        return isNaN(max) || isNaN(value) || value <= max;
    }

    function test_maxlength(element) {
        if (!element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('maxlength') || !element.getAttribute('maxlength')) {
            return true;
        }
        var maxlength = parseInt(element.getAttribute('maxlength'), 10);
        if (isNaN(maxlength) || maxlength < 0) {
            return true;
        }
        return unicode_string_length(element.value) <= maxlength;
    }

    function test_min(element) {
        var type = get_type(element);
        if (!element.value || !element.hasAttribute('min')) {
            return true;
        }
        var value = void 0,
            min = void 0;
        if (dates.indexOf(type) > -1) {
            value = string_to_date(element.value, type);
            value = value === null ? NaN : +value;
            min = string_to_date(element.getAttribute('min'), type);
            min = min === null ? NaN : +min;
        } else {
            value = Number(element.value);
            min = Number(element.getAttribute('min'));
        }
        return isNaN(min) || isNaN(value) || value >= min;
    }

    function test_minlength(element) {
        if (!element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('minlength') || !element.getAttribute('minlength')) {
            return true;
        }
        var minlength = parseInt(element.getAttribute('minlength'), 10);
        if (isNaN(minlength) || minlength < 0) {
            return true;
        }
        return unicode_string_length(element.value) >= minlength;
    }

    function test_pattern(element) {
        return !element.value || !element.hasAttribute('pattern') || new RegExp('^(?:' + element.getAttribute('pattern') + ')$').test(element.value);
    }

    function has_submittable_option(select) {
        var has_placeholder_option = !select.multiple && select.size <= 1 && select.options.length > 0 && select.options[0].parentNode == select && select.options[0].value === '';
        return (select.selectedIndex > -1 && Array.prototype.some.call(select.options, function(option) {
            return ((!has_placeholder_option || option.index !== 0) && !option.disabled && option.selected);
        }));
    }

    function test_required(element) {
        if (element.type === 'radio') {
            if (element.hasAttribute('required') && element.checked) {
                return true;
            }
            var radiogroup = get_radiogroup(element);
            if (radiogroup.some(function(radio) {
                    return radio.hasAttribute('required');
                })) {
                return radiogroup.some(function(radio) {
                    return radio.checked;
                });
            }
            return true;
        }
        if (!element.hasAttribute('required')) {
            return true;
        }
        if (element instanceof window.HTMLSelectElement) {
            return has_submittable_option(element);
        }
        return element.type === 'checkbox' ? element.checked : !!element.value;
    }

    function test_step(element) {
        var type = get_type(element);
        if (!element.value || numbers.indexOf(type) === -1 || (element.getAttribute('step') || '').toLowerCase() === 'any') {
            return true;
        }
        var step = element.getAttribute('step');
        if (step) {
            step = string_to_number(step, type);
        } else {
            step = default_step[type] || 1;
        }
        if (step <= 0 || isNaN(step)) {
            return true;
        }
        var scale = step_scale_factor[type] || 1;
        var value = string_to_number(element.value, type);
        var min = string_to_number(element.getAttribute('min') || element.getAttribute('value') || '', type);
        if (isNaN(value)) {
            return true;
        }
        if (isNaN(min)) {
            min = default_step_base[type] || 0;
        }
        if (type === 'month') {
            min = new Date(min).getUTCFullYear() * 12 + new Date(min).getUTCMonth();
            value = new Date(value).getUTCFullYear() * 12 + new Date(value).getUTCMonth();
        }
        var result = Math.abs(min - value) % (step * scale);
        return result < 0.00000001 || result > step * scale - 0.00000001;
    }
    var ws_on_start_or_end = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    function trim(str) {
        return str.replace(ws_on_start_or_end, '');
    }

    function comma_split(str) {
        return str.split(',').map(function(item) {
            return trim(item);
        }).filter(function(b) {
            return b;
        });
    }
    var url_canary;
    var email_pattern = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

    function test_type(element) {
        var type = get_type(element);
        if (type !== 'file' && !element.value || type !== 'file' && type_checked.indexOf(type) === -1) {
            return true;
        }
        var is_valid = true;
        switch (type) {
            case 'url':
                if (!url_canary) {
                    url_canary = document.createElement('a');
                }
                var value = trim(element.value);
                url_canary.href = value;
                is_valid = url_canary.href === value || url_canary.href === value + '/';
                break;
            case 'email':
                if (element.hasAttribute('multiple')) {
                    is_valid = comma_split(element.value).every(function(value) {
                        return email_pattern.test(value);
                    });
                } else {
                    is_valid = email_pattern.test(trim(element.value));
                }
                break;
            case 'file':
                if ('files' in element && element.files.length && element.hasAttribute('accept')) {
                    var patterns = comma_split(element.getAttribute('accept')).map(function(pattern) {
                        if (/^(audio|video|image)\/\*$/.test(pattern)) {
                            pattern = new RegExp('^' + RegExp.$1 + '/.+$');
                        }
                        return pattern;
                    });
                    if (!patterns.length) {
                        break;
                    }
                    fileloop: for (var i = 0; i < element.files.length; i++) {
                        var file_valid = false;
                        patternloop: for (var j = 0; j < patterns.length; j++) {
                            var file = element.files[i];
                            var pattern = patterns[j];
                            var fileprop = file.type;
                            if (typeof pattern === 'string' && pattern.substr(0, 1) === '.') {
                                if (file.name.search('.') === -1) {
                                    continue patternloop;
                                }
                                fileprop = file.name.substr(file.name.lastIndexOf('.'));
                            }
                            if (fileprop.search(pattern) === 0) {
                                file_valid = true;
                                break patternloop;
                            }
                        }
                        if (!file_valid) {
                            is_valid = false;
                            break fileloop;
                        }
                    }
                }
        }
        return is_valid;
    }

    function check$1(test, react) {
        return function(element) {
            var invalid = !test(element);
            if (invalid) {
                react(element);
            }
            return invalid;
        };
    }

    function set_msg(element, msgtype, _default) {
        message_store.set(element, custom_messages.get(element, msgtype, _default));
    }
    var badInput = check$1(test_bad_input, function(element) {
        return set_msg(element, 'badInput', _('Please match the requested type.'));
    });

    function customError(element) {
        if (element.__hf_custom_validation_running) {
            var msg = message_store.get(element);
            return msg && msg.is_custom;
        }
        var custom_validators = custom_validator_registry.get(element);
        var cvl = custom_validators.length;
        var valid = true;
        if (cvl) {
            element.__hf_custom_validation_running = true;
            for (var i = 0; i < cvl; i++) {
                var result = custom_validators[i](element);
                if (result !== undefined && !result) {
                    valid = false;
                    break;
                }
            }
            delete element.__hf_custom_validation_running;
        }
        if (valid) {
            var _msg = message_store.get(element);
            valid = !(_msg.toString() && 'is_custom' in _msg);
        }
        return !valid;
    }
    var patternMismatch = check$1(test_pattern, function(element) {
        set_msg(element, 'patternMismatch', element.title ? sprintf(_('PatternMismatchWithTitle'), element.title) : _('PatternMismatch'));
    });
    var rangeOverflow = check$1(test_max, function(element) {
        var type = get_type(element);
        var wrapper = get_wrapper(element);
        var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';
        var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';
        var msg = void 0;
        switch (type) {
            case 'date':
            case 'datetime':
            case 'datetime-local':
                msg = sprintf(_('DateRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));
                break;
            case 'time':
                msg = sprintf(_('TimeRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));
                break;
            default:
                msg = sprintf(_('NumberRangeOverflow'), string_to_number(element.getAttribute('max'), type));
                break;
        }
        set_msg(element, 'rangeOverflow', msg);
        element.classList.add(outOfRangeClass);
        element.classList.remove(inRangeClass);
    });
    var rangeUnderflow = check$1(test_min, function(element) {
        var type = get_type(element);
        var wrapper = get_wrapper(element);
        var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';
        var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';
        var msg = void 0;
        switch (type) {
            case 'date':
            case 'datetime':
            case 'datetime-local':
                msg = sprintf(_('DateRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));
                break;
            case 'time':
                msg = sprintf(_('TimeRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));
                break;
            default:
                msg = sprintf(_('NumberRangeUnderflow'), string_to_number(element.getAttribute('min'), type));
                break;
        }
        set_msg(element, 'rangeUnderflow', msg);
        element.classList.add(outOfRangeClass);
        element.classList.remove(inRangeClass);
    });
    var stepMismatch = check$1(test_step, function(element) {
        var list = get_next_valid(element);
        var min = list[0];
        var max = list[1];
        var sole = false;
        var msg = void 0;
        if (min === null) {
            sole = max;
        } else if (max === null) {
            sole = min;
        }
        if (sole !== false) {
            msg = sprintf(_('StepMismatchOneValue'), sole);
        } else {
            msg = sprintf(_('StepMismatch'), min, max);
        }
        set_msg(element, 'stepMismatch', msg);
    });
    var tooLong = check$1(test_maxlength, function(element) {
        set_msg(element, 'tooLong', sprintf(_('TextTooLong'), element.getAttribute('maxlength'), unicode_string_length(element.value)));
    });
    var tooShort = check$1(test_minlength, function(element) {
        set_msg(element, 'tooShort', sprintf(_('Please lengthen this text to %l characters or more (you are currently using %l characters).'), element.getAttribute('minlength'), unicode_string_length(element.value)));
    });
    var typeMismatch = check$1(test_type, function(element) {
        var msg = _('Please use the appropriate format.');
        var type = get_type(element);
        if (type === 'email') {
            if (element.hasAttribute('multiple')) {
                msg = _('Please enter a comma separated list of email addresses.');
            } else {
                msg = _('InvalidEmail');
            }
        } else if (type === 'url') {
            msg = _('InvalidURL');
        } else if (type === 'file') {
            msg = _('Please select a file of the correct type.');
        }
        set_msg(element, 'typeMismatch', msg);
    });
    var valueMissing = check$1(test_required, function(element) {
        var msg = _('ValueMissing');
        var type = get_type(element);
        if (type === 'checkbox') {
            msg = _('CheckboxMissing');
        } else if (type === 'radio') {
            msg = _('RadioMissing');
        } else if (type === 'file') {
            if (element.hasAttribute('multiple')) {
                msg = _('Please select one or more files.');
            } else {
                msg = _('FileMissing');
            }
        } else if (element instanceof window.HTMLSelectElement) {
            msg = _('SelectMissing');
        }
        set_msg(element, 'valueMissing', msg);
    });
    var valid = function valid(element) {
        var wrapper = get_wrapper(element);
        var validClass = wrapper && wrapper.settings.classes.valid || 'hf-valid';
        var invalidClass = wrapper && wrapper.settings.classes.invalid || 'hf-invalid';
        var userInvalidClass = wrapper && wrapper.settings.classes.userInvalid || 'hf-user-invalid';
        var userValidClass = wrapper && wrapper.settings.classes.userValid || 'hf-user-valid';
        var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';
        var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';
        var validatedClass = wrapper && wrapper.settings.classes.validated || 'hf-validated';
        element.classList.add(validatedClass);
        var _arr = [badInput, customError, patternMismatch, rangeOverflow, rangeUnderflow, stepMismatch, tooLong, tooShort, typeMismatch, valueMissing];
        for (var _i = 0; _i < _arr.length; _i++) {
            var checker = _arr[_i];
            if (checker(element)) {
                element.classList.add(invalidClass);
                element.classList.remove(validClass);
                element.classList.remove(userValidClass);
                if ((element.type === 'checkbox' || element.type === 'radio') && element.checked !== element.defaultChecked || element.value !== element.defaultValue) {
                    element.classList.add(userInvalidClass);
                } else {
                    element.classList.remove(userInvalidClass);
                }
                element.setAttribute('aria-invalid', 'true');
                return false;
            }
        }
        message_store.delete(element);
        element.classList.remove(invalidClass);
        element.classList.remove(userInvalidClass);
        element.classList.remove(outOfRangeClass);
        element.classList.add(validClass);
        element.classList.add(inRangeClass);
        if (element.value !== element.defaultValue) {
            element.classList.add(userValidClass);
        } else {
            element.classList.remove(userValidClass);
        }
        element.setAttribute('aria-invalid', 'false');
        return true;
    };
    var validity_state_checkers = {
        badInput: badInput,
        customError: customError,
        patternMismatch: patternMismatch,
        rangeOverflow: rangeOverflow,
        rangeUnderflow: rangeUnderflow,
        stepMismatch: stepMismatch,
        tooLong: tooLong,
        tooShort: tooShort,
        typeMismatch: typeMismatch,
        valueMissing: valueMissing,
        valid: valid
    };
    var ValidityState = function ValidityState(element) {
        if (!(element instanceof window.HTMLElement)) {
            throw new Error('cannot create a ValidityState for a non-element');
        }
        var cached = ValidityState.cache.get(element);
        if (cached) {
            return cached;
        }
        if (!(this instanceof ValidityState)) {
            return new ValidityState(element);
        }
        this.element = element;
        ValidityState.cache.set(element, this);
    };
    var ValidityStatePrototype = {};
    ValidityState.prototype = ValidityStatePrototype;
    ValidityState.cache = new WeakMap();
    var checker_getter = function checker_getter(func) {
        return function() {
            if (!is_validation_candidate(this.element)) {
                return true;
            }
            return func(this.element);
        };
    };
    for (var prop in validity_state_checkers) {
        Object.defineProperty(ValidityStatePrototype, prop, {
            configurable: true,
            enumerable: true,
            get: checker_getter(validity_state_checkers[prop]),
            set: undefined
        });
    }
    mark(ValidityStatePrototype);

    function reportValidity(element) {
        if (element instanceof window.HTMLFormElement) {
            element.__hf_form_validation = true;
            var form_valid = get_validated_elements(element).map(reportValidity).every(function(b) {
                return b;
            });
            delete element.__hf_form_validation;
            return form_valid;
        }
        var valid = ValidityState(element).valid;
        var event;
        if (valid) {
            var wrapped_form = get_wrapper(element);
            if (wrapped_form && wrapped_form.settings.validEvent) {
                event = trigger_event(element, 'valid', {
                    cancelable: true
                });
            }
        } else {
            event = trigger_event(element, 'invalid', {
                cancelable: true
            });
        }
        if (!event || !event.defaultPrevented) {
            Renderer.showWarning(element, !!element.form.__hf_form_validation);
        }
        return valid;
    }

    function submit_form_via(element) {
        var event_got_cancelled;
        var submit_event = create_event('submit', {
            cancelable: true
        });
        submit_event.preventDefault();
        Object.defineProperty(submit_event, 'defaultPrevented', {
            value: false,
            writable: true
        });
        Object.defineProperty(submit_event, 'preventDefault', {
            value: function value() {
                return submit_event.defaultPrevented = event_got_cancelled = true;
            },
            writable: true
        });
        trigger_event(element.form, submit_event, {}, {
            submittedVia: element
        });
        if (!event_got_cancelled) {
            add_submit_field(element);
            window.HTMLFormElement.prototype.submit.call(element.form);
            window.setTimeout(function() {
                return remove_submit_field(element);
            });
        }
    }

    function add_submit_field(button) {
        if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {
            var wrapper = get_wrapper(button.form) || {};
            var submit_helper = wrapper.submit_helper;
            if (submit_helper) {
                if (submit_helper.parentNode) {
                    submit_helper.parentNode.removeChild(submit_helper);
                }
            } else {
                submit_helper = document.createElement('input');
                submit_helper.type = 'hidden';
                wrapper.submit_helper = submit_helper;
            }
            submit_helper.name = button.name;
            submit_helper.value = button.value;
            button.form.appendChild(submit_helper);
        }
    }

    function remove_submit_field(button) {
        if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {
            var wrapper = get_wrapper(button.form) || {};
            var submit_helper = wrapper.submit_helper;
            if (submit_helper && submit_helper.parentNode) {
                submit_helper.parentNode.removeChild(submit_helper);
            }
        }
    }

    function check(button) {
        var val_event = trigger_event(button.form, 'validate', {
            cancelable: true
        });
        if (val_event.defaultPrevented) {
            return;
        }
        var valid = true;
        var first_invalid;
        button.form.__hf_form_validation = true;
        get_validated_elements(button.form).map(function(element) {
            if (!reportValidity(element)) {
                valid = false;
                if (!first_invalid && 'focus' in element) {
                    first_invalid = element;
                }
            }
        });
        delete button.form.__hf_form_validation;
        if (valid) {
            submit_form_via(button);
        } else if (first_invalid) {
            first_invalid.focus();
            trigger_event(button.form, 'forminvalid');
        }
    }

    function is_submit_button(node) {
        return ((node.nodeName === 'INPUT' || node.nodeName === 'BUTTON') && (node.type === 'image' || node.type === 'submit'));
    }

    function is_submitting_click(event, button) {
        return (!event.defaultPrevented && (!('button' in event) || event.button < 2) && is_submit_button(button) && button.form && !button.form.hasAttribute('novalidate'));
    }

    function is_submitting_keypress(event) {
        return (!event.defaultPrevented && (event.keyCode === 13 && event.target.nodeName === 'INPUT' && text_types.indexOf(event.target.type) > -1 || (event.keyCode === 13 || event.keyCode === 32) && is_submit_button(event.target)) && event.target.form && !event.target.form.hasAttribute('novalidate'));
    }

    function get_clicked_button(element) {
        if (is_submit_button(element)) {
            return element;
        } else if (matches(element, 'button:not([type]) *, button[type="submit"] *')) {
            return get_clicked_button(element.parentNode);
        } else {
            return null;
        }
    }

    function get_click_handler() {
        var ignore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return function(event) {
            var button = get_clicked_button(event.target);
            if (button && is_submitting_click(event, button)) {
                event.preventDefault();
                if (ignore || button.hasAttribute('formnovalidate')) {
                    submit_form_via(button);
                } else {
                    check(button);
                }
            }
        };
    }
    var click_handler = get_click_handler();
    var ignored_click_handler = get_click_handler(true);

    function get_keypress_handler(ignore) {
        return function keypress_handler(event) {
            if (is_submitting_keypress(event)) {
                event.preventDefault();
                var wrapper = get_wrapper(event.target.form) || {
                    settings: {}
                };
                if (wrapper.settings.preventImplicitSubmit) {
                    return;
                }
                var el = event.target.form.elements.length;
                var submit;
                for (var i = 0; i < el; i++) {
                    if (['image', 'submit'].indexOf(event.target.form.elements[i].type) > -1) {
                        submit = event.target.form.elements[i];
                        break;
                    }
                }
                if (submit) {
                    submit.click();
                } else if (ignore) {
                    submit_form_via(event.target);
                } else {
                    check(event.target);
                }
            }
        };
    }
    var keypress_handler = get_keypress_handler();
    var ignored_keypress_handler = get_keypress_handler(true);

    function catch_submit(listening_node) {
        var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (ignore) {
            listening_node.addEventListener('click', ignored_click_handler);
            listening_node.addEventListener('keypress', ignored_keypress_handler);
        } else {
            listening_node.addEventListener('click', click_handler);
            listening_node.addEventListener('keypress', keypress_handler);
        }
    }

    function uncatch_submit(listening_node) {
        listening_node.removeEventListener('click', ignored_click_handler);
        listening_node.removeEventListener('keypress', ignored_keypress_handler);
        listening_node.removeEventListener('click', click_handler);
        listening_node.removeEventListener('keypress', keypress_handler);
    }

    function uninstall_property(element, property) {
        try {
            delete element[property];
        } catch (e) {
            var wrapper = get_wrapper(element);
            if (wrapper && wrapper.settings.debug) {
                console.log('[hyperform] cannot uninstall custom property ' + property);
            }
            return false;
        }
        var original_descriptor = Object.getOwnPropertyDescriptor(element, '_original_' + property);
        if (original_descriptor) {
            Object.defineProperty(element, property, original_descriptor);
        }
    }

    function install_property(element, property, descriptor) {
        descriptor.configurable = true;
        descriptor.enumerable = true;
        if ('value' in descriptor) {
            descriptor.writable = true;
        }
        var original_descriptor = Object.getOwnPropertyDescriptor(element, property);
        if (original_descriptor === undefined) {
            original_descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(element), property);
        }
        if (original_descriptor) {
            if (original_descriptor.configurable === false) {
                var wrapper = get_wrapper(element);
                if (wrapper && wrapper.settings.debug) {
                    console.log('[hyperform] cannot install custom property ' + property);
                }
                return false;
            }
            if (original_descriptor.get && original_descriptor.get.__hyperform || original_descriptor.value && original_descriptor.value.__hyperform) {
                return;
            }
            Object.defineProperty(element, '_original_' + property, original_descriptor);
        }
        delete element[property];
        Object.defineProperty(element, property, descriptor);
        return true;
    }

    function is_field(element) {
        return element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement || element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLFieldSetElement || element === window.HTMLButtonElement.prototype || element === window.HTMLInputElement.prototype || element === window.HTMLSelectElement.prototype || element === window.HTMLTextAreaElement.prototype || element === window.HTMLFieldSetElement.prototype;
    }

    function setCustomValidity(element, msg) {
        if (!msg) {
            message_store.delete(element, true);
        } else {
            message_store.set(element, msg, true);
        }
        var warning = Renderer.getWarning(element);
        if (warning) {
            Renderer.setMessage(warning, msg, element);
        }
        validity_state_checkers.valid(element);
    }

    function valueAsDate(element) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var type = get_type(element);
        if (dates.indexOf(type) > -1) {
            if (value !== undefined) {
                if (value === null) {
                    element.value = '';
                } else if (value instanceof Date) {
                    if (isNaN(value.getTime())) {
                        element.value = '';
                    } else {
                        element.value = date_to_string(value, type);
                    }
                } else {
                    throw new window.DOMException('valueAsDate setter encountered invalid value', 'TypeError');
                }
                return;
            }
            var value_date = string_to_date(element.value, type);
            return value_date instanceof Date ? value_date : null;
        } else if (value !== undefined) {
            throw new window.DOMException('valueAsDate setter cannot set date on this element', 'InvalidStateError');
        }
        return null;
    }

    function valueAsNumber(element) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var type = get_type(element);
        if (numbers.indexOf(type) > -1) {
            if (type === 'range' && element.hasAttribute('multiple')) {
                return NaN;
            }
            if (value !== undefined) {
                if (isNaN(value)) {
                    element.value = '';
                } else if (typeof value === 'number' && window.isFinite(value)) {
                    try {
                        valueAsDate(element, new Date(value));
                    } catch (e) {
                        if (!(e instanceof window.DOMException)) {
                            throw e;
                        }
                        element.value = value.toString();
                    }
                } else {
                    throw new window.DOMException('valueAsNumber setter encountered invalid value', 'TypeError');
                }
                return;
            }
            return string_to_number(element.value, type);
        } else if (value !== undefined) {
            throw new window.DOMException('valueAsNumber setter cannot set number on this element', 'InvalidStateError');
        }
        return NaN;
    }

    function stepDown(element) {
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        if (numbers.indexOf(get_type(element)) === -1) {
            throw new window.DOMException('stepDown encountered invalid type', 'InvalidStateError');
        }
        if ((element.getAttribute('step') || '').toLowerCase() === 'any') {
            throw new window.DOMException('stepDown encountered step "any"', 'InvalidStateError');
        }
        var prev = get_next_valid(element, n)[0];
        if (prev !== null) {
            valueAsNumber(element, prev);
        }
    }

    function stepUp(element) {
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        if (numbers.indexOf(get_type(element)) === -1) {
            throw new window.DOMException('stepUp encountered invalid type', 'InvalidStateError');
        }
        if ((element.getAttribute('step') || '').toLowerCase() === 'any') {
            throw new window.DOMException('stepUp encountered step "any"', 'InvalidStateError');
        }
        var next = get_next_valid(element, n)[1];
        if (next !== null) {
            valueAsNumber(element, next);
        }
    }

    function validationMessage(element) {
        var msg = message_store.get(element);
        if (!msg) {
            return '';
        }
        return msg.toString();
    }

    function willValidate(element) {
        return is_validation_candidate(element);
    }
    var gA = function gA(prop) {
        return function() {
            return do_filter('attr_get_' + prop, this.getAttribute(prop), this);
        };
    };
    var sA = function sA(prop) {
        return function(value) {
            this.setAttribute(prop, do_filter('attr_set_' + prop, value, this));
        };
    };
    var gAb = function gAb(prop) {
        return function() {
            return do_filter('attr_get_' + prop, this.hasAttribute(prop), this);
        };
    };
    var sAb = function sAb(prop) {
        return function(value) {
            if (do_filter('attr_set_' + prop, value, this)) {
                this.setAttribute(prop, prop);
            } else {
                this.removeAttribute(prop);
            }
        };
    };
    var gAn = function gAn(prop) {
        return function() {
            return do_filter('attr_get_' + prop, Math.max(0, Number(this.getAttribute(prop))), this);
        };
    };
    var sAn = function sAn(prop) {
        return function(value) {
            value = do_filter('attr_set_' + prop, value, this);
            if (/^[0-9]+$/.test(value)) {
                this.setAttribute(prop, value);
            }
        };
    };

    function install_properties(element) {
        var _arr = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step'];
        for (var _i = 0; _i < _arr.length; _i++) {
            var prop = _arr[_i];
            install_property(element, prop, {
                get: gA(prop),
                set: sA(prop)
            });
        }
        var _arr2 = ['multiple', 'required', 'readOnly'];
        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
            var _prop = _arr2[_i2];
            install_property(element, _prop, {
                get: gAb(_prop.toLowerCase()),
                set: sAb(_prop.toLowerCase())
            });
        }
        var _arr3 = ['minLength', 'maxLength'];
        for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
            var _prop2 = _arr3[_i3];
            install_property(element, _prop2, {
                get: gAn(_prop2.toLowerCase()),
                set: sAn(_prop2.toLowerCase())
            });
        }
    }

    function uninstall_properties(element) {
        var _arr4 = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step', 'multiple', 'required', 'readOnly', 'minLength', 'maxLength'];
        for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
            var prop = _arr4[_i4];
            uninstall_property(element, prop);
        }
    }
    var polyfills = {
        checkValidity: {
            value: mark(function() {
                return checkValidity(this);
            })
        },
        reportValidity: {
            value: mark(function() {
                return reportValidity(this);
            })
        },
        setCustomValidity: {
            value: mark(function(msg) {
                return setCustomValidity(this, msg);
            })
        },
        stepDown: {
            value: mark(function() {
                var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                return stepDown(this, n);
            })
        },
        stepUp: {
            value: mark(function() {
                var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                return stepUp(this, n);
            })
        },
        validationMessage: {
            get: mark(function() {
                return validationMessage(this);
            })
        },
        validity: {
            get: mark(function() {
                return ValidityState(this);
            })
        },
        valueAsDate: {
            get: mark(function() {
                return valueAsDate(this);
            }),
            set: mark(function(value) {
                valueAsDate(this, value);
            })
        },
        valueAsNumber: {
            get: mark(function() {
                return valueAsNumber(this);
            }),
            set: mark(function(value) {
                valueAsNumber(this, value);
            })
        },
        willValidate: {
            get: mark(function() {
                return willValidate(this);
            })
        }
    };

    function polyfill(element) {
        if (is_field(element)) {
            for (var prop in polyfills) {
                install_property(element, prop, polyfills[prop]);
            }
            install_properties(element);
        } else if (element instanceof window.HTMLFormElement || element === window.HTMLFormElement.prototype) {
            install_property(element, 'checkValidity', polyfills.checkValidity);
            install_property(element, 'reportValidity', polyfills.reportValidity);
        }
    }

    function polyunfill(element) {
        if (is_field(element)) {
            uninstall_property(element, 'checkValidity');
            uninstall_property(element, 'reportValidity');
            uninstall_property(element, 'setCustomValidity');
            uninstall_property(element, 'stepDown');
            uninstall_property(element, 'stepUp');
            uninstall_property(element, 'validationMessage');
            uninstall_property(element, 'validity');
            uninstall_property(element, 'valueAsDate');
            uninstall_property(element, 'valueAsNumber');
            uninstall_property(element, 'willValidate');
            uninstall_properties(element);
        } else if (element instanceof window.HTMLFormElement) {
            uninstall_property(element, 'checkValidity');
            uninstall_property(element, 'reportValidity');
        }
    }
    var instances = new WeakMap();

    function Wrapper(form, settings) {
        var existing = instances.get(form);
        if (existing) {
            existing.settings = settings;
            return existing;
        }
        this.form = form;
        this.settings = settings;
        this.revalidator = this.revalidate.bind(this);
        instances.set(form, this);
        catch_submit(form, settings.revalidate === 'never');
        if (form === window || form.nodeType === 9) {
            this.install([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);
            polyfill(window.HTMLFormElement);
        } else if (form instanceof window.HTMLFormElement || form instanceof window.HTMLFieldSetElement) {
            this.install(form.elements);
            if (form instanceof window.HTMLFormElement) {
                polyfill(form);
            }
        }
        if (settings.revalidate === 'oninput' || settings.revalidate === 'hybrid') {
            form.addEventListener('keyup', this.revalidator);
            form.addEventListener('change', this.revalidator);
        }
        if (settings.revalidate === 'onblur' || settings.revalidate === 'hybrid') {
            form.addEventListener('blur', this.revalidator, true);
        }
    }
    Wrapper.prototype = {
        destroy: function destroy() {
            uncatch_submit(this.form);
            instances.delete(this.form);
            this.form.removeEventListener('keyup', this.revalidator);
            this.form.removeEventListener('change', this.revalidator);
            this.form.removeEventListener('blur', this.revalidator, true);
            if (this.form === window || this.form.nodeType === 9) {
                this.uninstall([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);
                polyunfill(window.HTMLFormElement);
            } else if (this.form instanceof window.HTMLFormElement || this.form instanceof window.HTMLFieldSetElement) {
                this.uninstall(this.form.elements);
                if (this.form instanceof window.HTMLFormElement) {
                    polyunfill(this.form);
                }
            }
        },
        revalidate: function revalidate(event) {
            if (event.target instanceof window.HTMLButtonElement || event.target instanceof window.HTMLTextAreaElement || event.target instanceof window.HTMLSelectElement || event.target instanceof window.HTMLInputElement) {
                if (this.settings.revalidate === 'hybrid') {
                    if (event.type === 'blur' && event.target.value !== event.target.defaultValue || ValidityState(event.target).valid) {
                        reportValidity(event.target);
                    } else if (event.type === 'keyup' && event.keyCode !== 9 || event.type === 'change') {
                        if (ValidityState(event.target).valid) {
                            reportValidity(event.target);
                        }
                    }
                } else if (event.type !== 'keyup' || event.keyCode !== 9) {
                    reportValidity(event.target);
                }
            }
        },
        install: function install(els) {
            if (els instanceof window.Element) {
                els = [els];
            }
            var els_length = els.length;
            for (var i = 0; i < els_length; i++) {
                polyfill(els[i]);
            }
        },
        uninstall: function uninstall(els) {
            if (els instanceof window.Element) {
                els = [els];
            }
            var els_length = els.length;
            for (var i = 0; i < els_length; i++) {
                polyunfill(els[i]);
            }
        }
    };

    function get_wrapper(element) {
        var wrapped;
        if (element.form) {
            wrapped = instances.get(element.form);
        }
        while (!wrapped && element) {
            wrapped = instances.get(element);
            element = element.parentNode;
        }
        if (!wrapped) {
            wrapped = instances.get(window);
        }
        return wrapped;
    }

    function get_validated_elements(form) {
        var wrapped_form = get_wrapper(form);
        return Array.prototype.filter.call(form.elements, function(element) {
            if (element.getAttribute('name') || wrapped_form && wrapped_form.settings.validateNameless) {
                return true;
            }
            return false;
        });
    }

    function return_hook_or(hook, action) {
        return function() {
            var data = call_hook(hook, Array.prototype.slice.call(arguments));
            if (data !== undefined) {
                return data;
            }
            return action.apply(this, arguments);
        };
    }
    var checkValidity = return_hook_or('checkValidity', function(element) {
        if (element instanceof window.HTMLFormElement) {
            return get_validated_elements(element).map(checkValidity).every(function(b) {
                return b;
            });
        }
        var valid = ValidityState(element).valid;
        if (valid) {
            var wrapped_form = get_wrapper(element);
            if (wrapped_form && wrapped_form.settings.validEvent) {
                trigger_event(element, 'valid');
            }
        } else {
            trigger_event(element, 'invalid', {
                cancelable: true
            });
        }
        return valid;
    });
    var version = '0.9.23';

    function w(name) {
        var deprecated_message = 'Please use camelCase method names! The name "%s" is deprecated and will be removed in the next non-patch release.';
        console.log(sprintf(deprecated_message, name));
    }

    function hyperform(form) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var classes = _ref.classes;
        var _ref$debug = _ref.debug;
        var debug = _ref$debug === undefined ? false : _ref$debug;
        var extend_fieldset = _ref.extend_fieldset;
        var extendFieldset = _ref.extendFieldset;
        var novalidate_on_elements = _ref.novalidate_on_elements;
        var novalidateOnElements = _ref.novalidateOnElements;
        var prevent_implicit_submit = _ref.prevent_implicit_submit;
        var preventImplicitSubmit = _ref.preventImplicitSubmit;
        var revalidate = _ref.revalidate;
        var _ref$strict = _ref.strict;
        var strict = _ref$strict === undefined ? false : _ref$strict;
        var valid_event = _ref.valid_event;
        var validEvent = _ref.validEvent;
        var _ref$validateNameless = _ref.validateNameless;
        var validateNameless = _ref$validateNameless === undefined ? false : _ref$validateNameless;
        if (!classes) {
            classes = {};
        }
        if (extendFieldset === undefined) {
            if (extend_fieldset === undefined) {
                extendFieldset = !strict;
            } else {
                w('extend_fieldset');
                extendFieldset = extend_fieldset;
            }
        }
        if (novalidateOnElements === undefined) {
            if (novalidate_on_elements === undefined) {
                novalidateOnElements = !strict;
            } else {
                w('novalidate_on_elements');
                novalidateOnElements = novalidate_on_elements;
            }
        }
        if (preventImplicitSubmit === undefined) {
            if (prevent_implicit_submit === undefined) {
                preventImplicitSubmit = false;
            } else {
                w('prevent_implicit_submit');
                preventImplicitSubmit = prevent_implicit_submit;
            }
        }
        if (revalidate === undefined) {
            revalidate = strict ? 'onsubmit' : 'hybrid';
        }
        if (validEvent === undefined) {
            if (valid_event === undefined) {
                validEvent = !strict;
            } else {
                w('valid_event');
                validEvent = valid_event;
            }
        }
        var settings = {
            debug: debug,
            strict: strict,
            preventImplicitSubmit: preventImplicitSubmit,
            revalidate: revalidate,
            validEvent: validEvent,
            extendFieldset: extendFieldset,
            classes: classes,
            novalidateOnElements: novalidateOnElements,
            validateNameless: validateNameless
        };
        if (form instanceof window.NodeList || form instanceof window.HTMLCollection || form instanceof Array) {
            return Array.prototype.map.call(form, function(element) {
                return hyperform(element, settings);
            });
        }
        return new Wrapper(form, settings);
    }
    hyperform.version = version;
    hyperform.checkValidity = checkValidity;
    hyperform.reportValidity = reportValidity;
    hyperform.setCustomValidity = setCustomValidity;
    hyperform.stepDown = stepDown;
    hyperform.stepUp = stepUp;
    hyperform.validationMessage = validationMessage;
    hyperform.ValidityState = ValidityState;
    hyperform.valueAsDate = valueAsDate;
    hyperform.valueAsNumber = valueAsNumber;
    hyperform.willValidate = willValidate;
    hyperform.setLanguage = function(lang) {
        set_language(lang);
        return hyperform;
    };
    hyperform.addTranslation = function(lang, catalog) {
        add_translation(lang, catalog);
        return hyperform;
    };
    hyperform.setRenderer = function(renderer, action) {
        Renderer.set(renderer, action);
        return hyperform;
    };
    hyperform.addValidator = function(element, validator) {
        custom_validator_registry.set(element, validator);
        return hyperform;
    };
    hyperform.setMessage = function(element, validator, message) {
        custom_messages.set(element, validator, message);
        return hyperform;
    };
    hyperform.addHook = function(hook, action, position) {
        add_hook(hook, action, position);
        return hyperform;
    };
    hyperform.removeHook = function(hook, action) {
        remove_hook(hook, action);
        return hyperform;
    };
    hyperform.set_language = function(lang) {
        w('set_language');
        set_language(lang);
        return hyperform;
    };
    hyperform.add_translation = function(lang, catalog) {
        w('add_translation');
        add_translation(lang, catalog);
        return hyperform;
    };
    hyperform.set_renderer = function(renderer, action) {
        w('set_renderer');
        Renderer.set(renderer, action);
        return hyperform;
    };
    hyperform.add_validator = function(element, validator) {
        w('add_validator');
        custom_validator_registry.set(element, validator);
        return hyperform;
    };
    hyperform.set_message = function(element, validator, message) {
        w('set_message');
        custom_messages.set(element, validator, message);
        return hyperform;
    };
    hyperform.add_hook = function(hook, action, position) {
        w('add_hook');
        add_hook(hook, action, position);
        return hyperform;
    };
    hyperform.remove_hook = function(hook, action) {
        w('remove_hook');
        remove_hook(hook, action);
        return hyperform;
    };
    if (document.currentScript && document.currentScript.hasAttribute('data-hf-autoload')) {
        hyperform(window);
    }
    module.exports = hyperform;
}), (function(module, exports) {
    module.exports = (function(modules) {
            var installedModules = {};

            function __webpack_require__(moduleId) {
                if (installedModules[moduleId])
                    return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    exports: {},
                    id: moduleId,
                    loaded: false
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.loaded = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.p = "";
            return __webpack_require__(0);
        })
        ([function(module, exports, __webpack_require__) {
            'use strict';
            var _floatl = __webpack_require__(1);
            var _floatl2 = _interopRequireDefault(_floatl);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            module.exports = _floatl2.default;
        }, function(module, exports, __webpack_require__) {
            'use strict';
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            var _utils = __webpack_require__(2);

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var focusedClass = 'floatl--focused';
            var activeClass = 'floatl--active';
            var multilineClass = 'floatl--multiline';
            var Floatl = function() {
                function Floatl(element) {
                    _classCallCheck(this, Floatl);
                    this.element = (0, _utils.getElement)(element);
                    this.label = this.element.querySelectorAll('.floatl__label')[0];
                    this.input = this.element.querySelectorAll('.floatl__input')[0];
                    if (!this.label || !this.input) return;
                    this._bindListeners();
                    this._init();
                }
                _createClass(Floatl, [{
                    key: '_bindListeners',
                    value: function _bindListeners() {
                        var _this = this;
                        (0, _utils.addEventListener)(this.input, 'focus', function() {
                            (0, _utils.addClass)(_this.element, focusedClass);
                        });
                        (0, _utils.addEventListener)(this.input, 'blur', function() {
                            (0, _utils.removeClass)(_this.element, focusedClass);
                        });
                        var _arr = ['keyup', 'blur', 'change', 'input'];
                        for (var _i = 0; _i < _arr.length; _i++) {
                            var event = _arr[_i];
                            (0, _utils.addEventListener)(this.input, event, function() {
                                return _this._handleChange();
                            });
                        }
                    }
                }, {
                    key: '_init',
                    value: function _init() {
                        if (this.input.tagName === 'TEXTAREA') {
                            (0, _utils.addClass)(this.element, multilineClass);
                        }
                        this._handleChange();
                    }
                }, {
                    key: '_handleChange',
                    value: function _handleChange() {
                        if (this.input.value === '') {
                            (0, _utils.removeClass)(this.element, activeClass);
                        } else {
                            (0, _utils.addClass)(this.element, activeClass);
                        }
                    }
                }]);
                return Floatl;
            }();
            exports.default = Floatl;
        }, function(module, exports) {
            'use strict';
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getElement = getElement;
            exports.addClass = addClass;
            exports.removeClass = removeClass;
            exports.addEventListener = addEventListener;

            function getElement(element) {
                if (element.tagName) {
                    return element;
                } else if (jQuery && element instanceof jQuery) {
                    return element.get(0);
                } else {
                    throw new TypeError('%{element} \'is not a valid element.\n                        Valid options are: DOM Element, jQuery.\'');
                }
            }

            function addClass(element, className) {
                if (element.classList) {
                    element.classList.add(className);
                } else {
                    element.className += ' %{className}';
                }
            }

            function removeClass(element, className) {
                if (element.classList) {
                    element.classList.remove(className);
                } else {
                    var re = new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi');
                    element.className = element.className.replace(re, ' ');
                }
            }

            function addEventListener(element, eventName, handler) {
                if (element.addEventListener) {
                    element.addEventListener(eventName, handler);
                } else {
                    element.attachEvent('on%{eventName}', function() {
                        handler.call(element);
                    });
                }
            }
        }]);
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var errorHelpers = __webpack_require__(9);
    var VALIDATION_CLASSES = {
        WARNING: 'has-warning',
        VALID: 'has-success',
        INVALID: 'has-danger',
        MESSAGE: 'form-control-feedback',
        GROUP: 'form-group'
    };

    function isFormValid(form) {
        var isValid = true;
        $(form).find('input:visible, select:visible').each(function(index, elem) {
            if ($(elem).prop('required') && !elem.validity.valid) {
                isValid = false;
            }
        });
        return isValid;
    }

    function setSubmitButtonStatus(form) {
        if (isFormValid(form)) {
            if (!$(form).find('button[type="submit"], .submit').data('disabled-if-valid')) {
                $(form).find('button[type="submit"], .submit').prop('disabled', false).removeClass('isDisabled');
            }
        } else {
            $(form).find('button[type="submit"], .submit').prop('disabled', true).addClass('isDisabled');
        }
    }
    $(document).on('click', 'button[type="submit"]', function() {
        var form = $(this).closest('.container').find('form');
        errorHelpers.scrollToFirstFormErrorElement(form);
    });

    function initValidation(form) {
        window.hyperform(form, {
            classes: {
                warning: VALIDATION_CLASSES.MESSAGE
            }
        });
        setSubmitButtonStatus(form);
        window.hyperform.setRenderer('attachWarning', function(warning, element) {
            $(element).parents('.' + VALIDATION_CLASSES.GROUP).find('.' + VALIDATION_CLASSES.MESSAGE).replaceWith(warning);
        });
        window.hyperform.setRenderer('detachWarning', function(warning, element) {
            $(element).parents('.' + VALIDATION_CLASSES.GROUP).find('.' + VALIDATION_CLASSES.MESSAGE).replaceWith('<div class="' + VALIDATION_CLASSES.MESSAGE + '"></div>');
        });
        form.addEventListener('invalid', function(e) {
            $(e.target).parents('.' + VALIDATION_CLASSES.GROUP).removeClass(VALIDATION_CLASSES.WARNING).removeClass(VALIDATION_CLASSES.VALID).addClass(VALIDATION_CLASSES.INVALID);
            setSubmitButtonStatus(form);
        });
        for (var i = 0; i < form.length; i++) {
            form[i].addEventListener('blur', function() {
                this.checkValidity();
                if ('reportValidity' in HTMLFormElement.prototype) {
                    this.reportValidity();
                } else {
                    window.hyperform.reportValidity(this);
                }
            });
        }
        form.addEventListener('valid', function(e) {
            $(e.target).parents('.' + VALIDATION_CLASSES.GROUP).removeClass(VALIDATION_CLASSES.WARNING).removeClass(VALIDATION_CLASSES.INVALID).addClass(VALIDATION_CLASSES.VALID);
            setSubmitButtonStatus(form);
        });
        var emailConfirm = document.getElementById('shippingEmailConfirm');
        if (emailConfirm) {
            window.hyperform.addValidator(emailConfirm, function(element) {
                var valid = element.value === document.getElementById('shippingEmail').value;
                element.setCustomValidity(valid ? '' : element.dataset.matchError);
                return valid;
            });
        }
        var cvvElement = document.getElementById('dwfrm_billing_paymentMethods_creditdirect_cvn');
        if (cvvElement) {
            window.hyperform.addValidator(cvvElement, function(element) {
                var cvvRegex = new RegExp('^[0-9]{3,4}$');
                var valid = cvvRegex.test($(element).val());
                if (valid) {
                    element.setCustomValidity('');
                } else if (element.dataset && element.dataset.invalidError && $(element).val() !== '') {
                    element.setCustomValidity(element.dataset.invalidError);
                } else if (element.dataset && element.dataset.emptyError && $(element).val() === '') {
                    element.setCustomValidity(element.dataset.emptyError);
                }
                return valid;
            });
        }
        var creditCardNumberElement = document.getElementById('dwfrm_billing_paymentMethods_creditdirect_number');
        if (creditCardNumberElement) {
            window.hyperform.addValidator(creditCardNumberElement, function(element) {
                var valid = $('.valid-card').length > 0;
                if (valid) {
                    element.setCustomValidity('');
                } else if (element.dataset && element.dataset.invalidError && $(element).val() !== '') {
                    element.setCustomValidity(element.dataset.invalidError);
                } else if (element.dataset && element.dataset.emptyError && $(element).val() === '') {
                    element.setCustomValidity(element.dataset.emptyError);
                }
                return valid;
            });
        }
        var customCardValue = document.getElementById('dwfrm_giftcard_giftCard_customCardValue');
        if (customCardValue) {
            window.hyperform.addValidator(customCardValue, function(element) {
                var valid = true;
                var fieldValue = $(element).val().replace(/,/g, '.');
                var valueStep = element.dataset && element.dataset.valueStep ? parseInt(element.dataset.valueStep, 10) : null;
                var multipleOfErrorMessage = element.dataset && element.dataset.multipleOfErrorMessage ? element.dataset.multipleOfErrorMessage : null;
                var numericErrorMessage = element.dataset && element.dataset.numericErrorMessage ? element.dataset.numericErrorMessage : null;
                var pattern = $(element).attr('pattern');
                if (fieldValue.trim() !== '' && !isNaN(fieldValue) && valueStep && multipleOfErrorMessage) {
                    valid = parseFloat(fieldValue) % valueStep === 0;
                    if (valid) {
                        element.setCustomValidity('');
                    } else {
                        element.setCustomValidity(multipleOfErrorMessage);
                    }
                    return valid;
                } else if (fieldValue.length > 0 && isNaN(fieldValue) && pattern && numericErrorMessage) {
                    var match = fieldValue.match(new RegExp(pattern));
                    valid = match && match[0] === match.input;
                    if (valid) {
                        element.setCustomValidity('');
                    } else {
                        element.setCustomValidity(numericErrorMessage);
                    }
                    return valid;
                }
                element.setCustomValidity('');
                return valid;
            });
        }
    }

    function setLanguage() {
        var data;
        try {
            data = JSON.parse($('.js-form-messages').text());
        } catch (e) {
            window.console.warn(e);
        }
        if (data && data.language && data.messages) {
            window.hyperform.addTranslation(data.language, data.messages);
            window.hyperform.setLanguage(data.language);
        }
    }

    function initWhenTabIsChanged() {
        $('a[data-toggle="tab"]').one('shown.bs.tab', function(e) {
            var formContainerId = $(e.target).attr('href');
            if (formContainerId) {
                $(formContainerId).find('form').each(function(idx, form) {
                    setSubmitButtonStatus(form);
                });
            }
        });
    }

    function initWhenModalShown() {
        $('.modal').on('shown.bs.modal', function() {
            $('.modal form').each(function(idx, form) {
                setSubmitButtonStatus(form);
            });
        });
    }
    module.exports = {
        init: function init() {
            var $forms = $('form').not('novalidate');
            $forms.each(function(index, form) {
                initValidation(form);
            });
            setLanguage();
            initWhenTabIsChanged();
            initWhenModalShown();
        },
        initForm: initValidation,
        isFormValid: isFormValid,
        setSubmitButtonStatus: setSubmitButtonStatus
    };
}), (function(module, exports) {
    'use strict';

    function scrollToFirstFormErrorElement(form) {
        var element = $(form).find('.has-danger:visible').first();
        if ($(element).length > 0) {
            $('html, body').animate({
                scrollTop: $(element).offset().top - 120
            }, 300, function() {
                var focusedElement = element.find('.form-control');
                if (focusedElement.length > 0) {
                    $(focusedElement).focus();
                }
            });
        }
    }

    function scrollTo($element, callback) {
        $('html, body').animate({
            scrollTop: $element.offset().top - 90
        }, 300, function() {
            var focusEl = null;
            if ($element.hasClass('.form-control')) {
                focusEl = $element;
            } else if ($element.find('.has-danger .form-control').length) {
                focusEl = $element.find('.has-danger .form-control').first();
            }
            if (focusEl) {
                focusEl.focus();
                setTimeout(function() {
                    if (callback && typeof callback === 'function') {
                        callback();
                    }
                }, 0);
            } else if (callback && typeof callback === 'function') {
                callback();
            }
        });
    }

    function loadFormErrors(parentSelector, fieldErrors) {
        $.each(fieldErrors, function(attr) {
            $('*[name=' + attr + ']', parentSelector).parents('.form-group').first().addClass('has-danger').removeClass('has-success').find('.form-control-feedback').html(fieldErrors[attr]);
        });
        scrollToFirstFormErrorElement(parentSelector);
    }
    module.exports = {
        loadFormErrors: loadFormErrors,
        scrollToFirstFormErrorElement: scrollToFirstFormErrorElement,
        scrollTo: scrollTo
    };
}), (function(module, exports) {
    'use strict';

    function createCookie(cName, value, exdays) {
        var exdate = new Date();
        exdate.setDate(exdate.getDate() + exdays);
        var cValue = escape(value);
        cValue += exdays === null ? '' : ('; expires=' + exdate.toUTCString());
        cValue += '; path=/';
        document.cookie = cName + '=' + cValue;
    }

    function getCookie(cName) {
        var i;
        var x;
        var y;
        var ARRcookies = document.cookie.split(';');
        var returnval = '';
        for (i = 0; i < ARRcookies.length; i++) {
            x = ARRcookies[i].substr(0, ARRcookies[i].indexOf('='));
            y = ARRcookies[i].substr(ARRcookies[i].indexOf('=') + 1);
            x = x.replace(/^\s+|\s+$/g, '');
            if (x === cName) {
                returnval = unescape(y);
            }
        }
        return returnval;
    }

    function eraseCookie(cName) {
        document.cookie = cName + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/';
    }

    function generateSvgString(iconId, iconClass) {
        var svgClass = iconClass || '';
        return ('<svg viewBox="0 0 100 100" class="' + svgClass + '">' +
            '<use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#' + iconId + '"></use>' +
            '</svg>');
    }

    function appendParamToURL(url, name, value) {
        var c = '?';
        var hash = '';
        var baseUrl = url;
        if (baseUrl.indexOf(c) !== -1) {
            c = '&';
        }
        if (baseUrl.indexOf('#') !== -1) {
            var urlParts = baseUrl.split('#');
            baseUrl = urlParts[0];
            hash = urlParts[1];
        }
        var resultUrl = baseUrl + c + name + '=' + encodeURIComponent(value);
        if (hash.length) {
            resultUrl += '#' + hash;
        }
        return resultUrl;
    }

    function appendParamsToURL(url, params) {
        var resultUrl = url;
        Object.keys(params).forEach(function(name) {
            resultUrl = appendParamToURL(resultUrl, name, params[name]);
        });
        return resultUrl;
    }

    function keyValueArray(str) {
        var kvp = str.split('&');
        var x;
        var k;
        var v;
        var output = {};
        for (var i = kvp.length - 1; i >= 0; i--) {
            if (kvp[i].length) {
                x = kvp[i].split('=');
                k = x[0];
                v = '';
                if (x.length > 1) {
                    v = x[1];
                }
                output[k] = decodeURIComponent(v);
            }
        }
        return output;
    }

    function getParamsFromURL(url) {
        var arr = url.split('?');
        var search = '';
        var searchHash = '';
        var postHash = false;
        if (arr.length > 1) {
            var arrHash = arr[1].split('#');
            search = arrHash[0];
            if (arrHash.length > 1) {
                postHash = true;
                searchHash = arrHash[1];
            }
        }
        var output = {};
        if (search.length) {
            output = keyValueArray(search);
        }
        if (postHash) {
            if (searchHash.length) {
                var output2 = keyValueArray(searchHash);
                Object.keys(output2).forEach(function(prop) {
                    output[prop] = output2[prop];
                });
            }
        }
        return output;
    }
    module.exports = {
        createCookie: createCookie,
        getCookie: getCookie,
        eraseCookie: eraseCookie,
        generateSvgString: generateSvgString,
        appendParamToURL: appendParamToURL,
        keyValueArray: keyValueArray,
        getParamsFromURL: getParamsFromURL,
        appendParamsToURL: appendParamsToURL
    };
}), , , , (function(module, exports, __webpack_require__) {
    'use strict';
    var modal = __webpack_require__(15);
    var formValidation = __webpack_require__(3);
    var clearForm = __webpack_require__(16);
    var form = __webpack_require__(5);
    var errorHelpers = __webpack_require__(9);
    var forceNoSizeAttributeUrls = false;

    function isBundle() {
        return !!$('.product-detail .product-bundle').length;
    }

    function getQuantitySelected($el) {
        return !isBundle() ? $('.quantity-select').val() : $el.closest('.prices-add-to-cart-actions').siblings('.quantity-select').val();
    }

    function updateQuantitySelection(el, qty) {
        $(el).parents('.select-mask').find('.select-mask__overlay').addClass('select-populated').find('.select-mask__overlay__value').text(qty);
    }

    function processSwatchValues(attr, $productContainer) {
        attr.values.forEach(function(attrValue) {
            var $attrValue = $('[data-attr="' + attr.id + '"] [data-attr-value="' +
                attrValue.value + '"]', $productContainer);
            var $swatchAnchor = $attrValue.parent();
            if (attrValue.selected) {
                $attrValue.addClass('selected');
                var $colorTextElem = $productContainer.find('.attribute-color__name__text').eq(0);
                var colorLabel = $colorTextElem.data('label');
                $colorTextElem.text(colorLabel + ' ' + attrValue.displayValue);
            } else {
                $attrValue.removeClass('selected');
            }
            var urlSelectVariat = attrValue.urlSelectVariant;
            if (typeof attrValue.urlSelectVariant !== 'undefined' && forceNoSizeAttributeUrls) {
                urlSelectVariat = attrValue.urlNoPreselectedSize;
            }
            $swatchAnchor.attr('href', urlSelectVariat);
            $swatchAnchor.data('url-show', attrValue.urlProductShow);
            $swatchAnchor.data('url-select', urlSelectVariat);
            $attrValue.removeClass('selectable unselectable');
            $attrValue.addClass(attrValue.selectable ? 'selectable' : 'unselectable');
        });
    }

    function processNonSwatchValues(attr, $productContainer) {
        var $attr = '[data-attr="' + attr.id + '"]';
        var $defaultOption = $($attr + ' .select-' + attr.id + ' option:first', $productContainer);
        $defaultOption.attr('value', attr.resetUrl);
        attr.values.forEach(function(attrValue) {
            var $attrValue = $($attr + ' [data-attr-value="' + attrValue.value + '"]', $productContainer);
            $attrValue.attr('value', attrValue.url).removeAttr('disabled');
            if (!attrValue.selectable) {
                $attrValue.attr('disabled', true);
            }
        });
    }

    function appendQuantityToUrl(url, $productContainer) {
        var quantitySelected = $productContainer.find('.quantity-select').val();
        return !quantitySelected ? url : url + '&quantity=' + quantitySelected;
    }

    function updateAttrs(attrs, $productContainer) {
        var attrsWithSwatches = ['color'];
        attrs.forEach(function(attr) {
            if (attrsWithSwatches.indexOf(attr.id) > -1) {
                processSwatchValues(attr, $productContainer);
            } else {
                processNonSwatchValues(attr, $productContainer);
            }
        });
    }

    function getBundleAvailability(response) {
        var availability = response.resources.label_instock;
        if ($('.bundle-item div.availability[data-available=false]').length) {
            availability = response.resources.label_outofstock;
        } else if ($('.bundle-item div.availability[data-ready-to-order=false]').length) {
            availability = response.resources.info_selectforstock;
        }
        return availability;
    }

    function isBundleOrderable() {
        return !$('.bundle-item div.availability[data-ready-to-order=false]').length && !$('.bundle-item div.availability[data-available=false]').length;
    }

    function getBundleAddToCartButton() {
        var bundlePid = $('.product-bundle').parents().data('pid');
        return $(['button.add-to-cart', '[data-pid="', bundlePid, '"]'].join(''));
    }

    function getProductTitle($) {
        return $.find('strong.uppercase').text();
    }

    function updateAvailability(response, $productContainer) {
        var availabilityValue = '';
        var availabilityMessages = response.product.availability.messages;
        var maxOrderQuantityHtml = response.product.maxOrderQuantityHtml;
        var hasRequiredAttrsSelected = response.product.readyToOrder;
        var bundleAvailability;
        $productContainer.find('div.availability').attr('data-ready-to-order', response.product.readyToOrder).attr('data-available', response.product.available);
        if (hasRequiredAttrsSelected) {
            availabilityMessages.forEach(function(message) {
                availabilityValue += '<li>' + message + '</li>';
            });
        }
        $productContainer.find('.availability-msg').eq(0).empty().html(availabilityValue);
        $('.availability-wrapper').toggleClass('d-none', response.product.hideAvailability);
        if (response.product.hideAvailability && response.product.availability.formattedInStockDate) {
            $('.preorder-wrapper').removeClass('d-none');
            $productContainer.find('.instockdate-msg').eq(0).empty().html(response.product.availability.formattedInStockDate);
        } else {
            $('.preorder-wrapper').addClass('d-none');
        }
        let $productContainerQtyErrorMsg = $productContainer.find('.max-order-qty-msg');
        if (maxOrderQuantityHtml) {
            $productContainerQtyErrorMsg.removeClass('hidden').empty().html(maxOrderQuantityHtml);
            updateAddToCartButton(response, $productContainer);
        } else {
            let currentProductTitle = getProductTitle($productContainerQtyErrorMsg);
            $('.max-order-qty-msg').not('.hidden').each(function() {
                if (getProductTitle($(this)) === currentProductTitle) {
                    $(this).addClass('hidden');
                }
            });
            updateAddToCartButton(response, $productContainer);
        }
        if (isBundle()) {
            $('.bundle-footer div.availability').attr('data-ready-to-order', isBundleOrderable());
            bundleAvailability = getBundleAvailability(response);
            $('.bundle-footer ul.availability-msg').html('<li>' + bundleAvailability + '</li>');
        }
    }

    function updateSizeSelector(response, $productContainer) {
        var sizesHtml = $(response.product.attributesHtml).find('.form-group');
        if (sizesHtml) {
            $productContainer.find('.attribute-size .form-group').replaceWith(sizesHtml);
        }
        $('.attribute-size').toggleClass('d-none', (!response.product.available || !response.stockControl.addToCart));
    }

    function updateQtySelector(response, $productContainer) {
        var quantityHtml = response.product.quantityHtml;
        if (quantityHtml) {
            $productContainer.find('.quantity').empty().html(quantityHtml);
        }
        $('.quantity').toggleClass('d-none', (!response.product.available || !response.stockControl.addToCart));
    }

    function updateFluidConfigureButton(response, $productContainer) {
        var configureUrl = response.product.fluidConfigureCustomize;
        if (configureUrl) {
            $productContainer.find('.fluid-configure a.btn-configure').attr('href', configureUrl);
        }
    }

    function getPromotionsHtml(promotions) {
        if (!promotions) {
            return '';
        }
        var html = '';
        promotions.forEach(function(promotion) {
            if (promotion.details && promotion.calloutMsg) {
                html += '<div class="callout" title="' + promotion.details + '">' +
                    promotion.calloutMsg + '</div>';
            }
        });
        return html;
    }

    function checkIfSizeSelected() {
        return $('#attribute-select-size').val() !== null;
    }

    function updateAddToCartButton(response, $productContainer) {
        var disableButton = false;
        var disableCondition = (response.product.readyToOrder === false) || (response.product.available === false) || (response.stockControl.addToCart === false);
        $productContainer.find('button.add-to-cart').eq(0).attr('disabled', disableCondition).text(response.stockControl.ctaText).trigger('product:statusUpdate', response.product);
        $productContainer.find('button.add-to-cart--update').eq(0).attr('disabled', disableCondition).text(response.stockControl.ctaUpdateText).trigger('product:statusUpdate', response.product);
        if (isBundle()) {
            disableButton = !isBundleOrderable();
            getBundleAddToCartButton().attr('disabled', disableButton).trigger('product:statusUpdate', response.product);
        }
        $productContainer.find('.select-bonus-product').eq(0).attr('disabled', (disableCondition)).text(response.stockControl.ctaText).trigger('product:statusUpdate', response.product);
    }

    function handleVariantResponse(response, caller, $productContainer) {
        var isBonusRequest = $('#chooseBonusProductModal').hasClass('active');
        if (caller === 'tile') {
            $productContainer.find('.product-quickview').eq(0).data('pid', response.product.id);
        }
        if (isBonusRequest) {
            $productContainer.attr('data-pid', response.product.id).data('pid', response.product.id);
            $productContainer.find('[data-pid]').attr('data-pid', response.product.id).data('pid', response.product.id);
        }
        if (caller === 'details') {
            $productContainer.find('.product-id').eq(0).text(response.product.id);
            $productContainer.attr('data-pid', response.product.id);
        }
        var $productStyleNumber = $productContainer.find('.product-style-number');
        if (response.styleNumber) {
            var styleNumberValue = response.styleNumber;
            var styleNumberValuePrevious = $productStyleNumber.data('style-number');
            if (styleNumberValue !== styleNumberValuePrevious) {
                var styleNumberLabel = $productStyleNumber.eq(0).data('label');
                var taxMsgSeparator = response.showTaxDisplayMsg ? '/ ' : '';
                $productStyleNumber.empty();
                $productStyleNumber.text(taxMsgSeparator + styleNumberLabel + ' ' + styleNumberValue);
                $productStyleNumber.data('style-number', styleNumberValue);
                $(document).trigger('omniture.trackPDPColor', [styleNumberValue]);
            }
        }
        if (response.product.variationAttributes) {
            updateAttrs(response.product.variationAttributes, $productContainer);
        }
        if (caller === 'details') {
            $productContainer.find('.product-gallery').eq(0).trigger('swatch:changed', response.product.productGalleryHtml);
        }
        if (caller === 'tile') {
            $productContainer.find('.product-quickview .product-quickview__product-image img').eq(0).attr('src', response.product.images.large[0].url);
        }
        if ($('.exchange-form').length > 0) {
            if ('medium' in response.product.images && response.product.images.medium.length > 0) {
                $productContainer.find('.product-image_wrapper .product-image').attr('src', response.product.images.medium[0].url);
            }
        }
        $productContainer.find('.prices .price').replaceWith(response.product.price.html);
        $productContainer.find('.promotions').eq(0).empty().html(getPromotionsHtml(response.product.promotions));
        if (caller === 'tile') {
            $productContainer.find('.line-item-promo').empty().html(response.product.promotionsHtml);
        }
        if (response.product.attributes && response.product.attributes.length) {
            response.product.attributes.forEach(function(attribute) {
                if (attribute.ID === 'Badges' && attribute.attributes.length) {
                    $productContainer.find('.product-badge').empty().html(attribute.attributes[0].value);
                }
            });
        }
        updateSizeSelector(response, $productContainer);
        if (!isBonusRequest) {
            updateQtySelector(response, $productContainer);
        }
        updateFluidConfigureButton(response, $productContainer);
        updateAvailability(response, $productContainer);
        updateAddToCartButton(response, $productContainer);
        $productContainer.trigger('product:variantSelect', response.product);
    }

    function createSelectedValueUrl(selectedValueUrl, $productContainer) {
        if (selectedValueUrl && selectedValueUrl !== 'null') {
            return appendQuantityToUrl(selectedValueUrl, $productContainer);
        }
        return null;
    }

    function attributeSelect(selectedValueUrl, $productContainer) {
        var view;
        if (selectedValueUrl) {
            if ($('#quickViewModal').hasClass('show') || $('#chooseBonusProductModal').hasClass('active')) {
                view = 'tile';
                $('.modal-body').spinner().start();
            } else {
                view = 'details';
                $.spinner().start();
            }
            $.ajax({
                url: selectedValueUrl,
                method: 'GET',
                success: function(data) {
                    forceNoSizeAttributeUrls = false;
                    if (selectedValueUrl.match(/_size=/) === null) {
                        forceNoSizeAttributeUrls = true;
                    }
                    handleVariantResponse(data, view, $productContainer);
                    selectBonusProduct();
                    disableExcludeColorsForBonusProducts();
                    $productContainer.find('.quantity-select').data('action', data.product.selectedVariantUrl).trigger('change');
                    $.spinner().stop();
                },
                error: function() {
                    $.spinner().stop();
                }
            });
        }
    }

    function getAddToCartUrl() {
        return $('input[name="addToCartUrl"]').val();
    }

    function getUpdateCartUrl() {
        return $('input[name="updateCartUrl"]').val();
    }

    function displayAddToBagOverlay(url, quantityAdded, quantityTotal, adjustQuantityMessage) {
        $.ajax({
            url: url,
            method: 'GET',
            dataType: 'html',
            success: function(html) {
                modal.create('addToBagOverlay', html, true);
                $('.addToBagOverlay__quantity-added').text(quantityAdded);
                $('.addToBagOverlay__quantity-total').text(quantityTotal);
                if (adjustQuantityMessage !== undefined && adjustQuantityMessage.length > 0) {
                    $('.addToBagOverlay__status').append('<span class="adjust-quantity-message">' + adjustQuantityMessage + '</span>');
                    $('.quantity-select').trigger('change');
                }
                if ('pageData' in window) {
                    window.pageData.product = ($('[data-layer-product-added]').data('layerProductAdded'));
                    window.pageData.cart = ($('[data-layer-cart]').data('layerCart'));
                    window.pageData.event.push({
                        type: 'cart',
                        name: 'product added'
                    });
                }
                $('#addToBagOverlay .btn--keep-shopping').click(function(e) {
                    e.preventDefault();
                    modal.hide();
                });
                modal.show();
                $(document).trigger('carousel1.reinit');
            },
            error: function() {
                modal.stopSpinner();
            }
        });
    }

    function parseHtml(html) {
        var $html = $('<div>').append($.parseHTML(html));
        var body = $html.find('.choice-of-bonus-product');
        var footer = $html.find('.modal-footer').children();
        return {
            body: body,
            footer: footer
        };
    }

    function chooseBonusProducts(data) {
        return new Promise(function(resolve, reject) {
            var bonusUrl;
            if (data.bonusChoiceRuleBased) {
                bonusUrl = data.showProductsUrlRuleBased;
            } else {
                bonusUrl = data.showProductsUrlListBased;
            }
            $.spinner().start();
            $.ajax({
                url: bonusUrl,
                method: 'GET',
                dataType: 'html',
                success: function(html) {
                    var parsedHtml = parseHtml(html);
                    var productCount = parsedHtml.body.filter('.ready-to-order').length;
                    resolve(productCount);
                    if (productCount > 0) {
                        buildBonusProductModal(data, parsedHtml);
                    }
                    $.spinner().stop();
                },
                error: function() {
                    reject(0);
                    $.spinner().stop();
                }
            });
        });
    }

    function buildBonusProductModal(data, parsedHtml) {
        var bonusProductModal = $('#chooseBonusProductModal');
        if (bonusProductModal.length !== 0) {
            bonusProductModal.remove();
        }
        var htmlString = '<!-- Modal -->' + '<div class="modal fade" id="chooseBonusProductModal" role="dialog">' + '<div class="modal-dialog choose-bonus-product-dialog" ' + 'data-total-qty="' + data.maxBonusItems + '"' + 'data-UUID="' + data.uuid + '"' + 'data-pliUUID="' + data.pliUUID + '"' + 'data-addToCartUrl="' + data.addToCartUrl + '"' + 'data-pageStart="0"' + 'data-pageSize="' + data.pageSize + '"' + 'data-moreURL="' + data.showProductsUrlRuleBased + '"' + 'data-bonusChoiceRuleBased="' + data.bonusChoiceRuleBased + '">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<div class="modal-header">' + '    <span class="text-uppercase text-center w-100 color-brand-danger">' + data.labels.selectprods + '</span>' + '    <button type="button" class="close pull-right" data-dismiss="modal">' + '    <svg viewBox="0 0 32 32" class="modal-fs__close__icon"><use xlink:href="#close-x"></use></svg>' + '    </button>' + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer"></div>' + '</div>' + '</div>' + '</div>';
        $('body').append(htmlString);
        bonusProductModal = $('#chooseBonusProductModal');
        bonusProductModal.find('.modal-body').html(parsedHtml.body);
        bonusProductModal.find('.modal-footer').html(parsedHtml.footer);
        bonusProductModal.on('show.bs.modal', function() {
            $(this).addClass('active');
        });
        bonusProductModal.on('hide.bs.modal', function() {
            $(this).removeClass('active');
        });
        bonusProductModal.modal('show');
        if (bonusProductModal.find('.select-bonus-product').length === 1) {
            bonusProductModal.find('.select-bonus-product').trigger('change');
        }
        form.init();
        disableExcludeColorsForBonusProducts();
        updateBonusSelectButtons();
        refreshAddtoBagButton();
        enableDeclineBonusPromo(bonusProductModal, data);
    }

    function disableExcludeColorsForBonusProducts() {
        var bonusModalSelector = $('#chooseBonusProductModal');
        var excludeColors = bonusModalSelector.find('.exclude-colors').data('exclude-colors');
        if (excludeColors) {
            var excludeColorsArray = excludeColors.toString().split('|');
            bonusModalSelector.find("a[data-attr-value='" + excludeColorsArray.join("'],a[data-attr-value='") + "']").remove();
            bonusModalSelector.find("a[data-style-number='" + excludeColorsArray.join("'],a[data-style-number='") + "']").remove();
            bonusModalSelector.find("option[data-variant-upc='" + excludeColorsArray.join("'],option[data-variant-upc='") + "']").remove();
            bonusModalSelector.find('a[data-variant-upcs]').each(function() {
                var swatch = $(this);
                var upcs = swatch.attr('data-variant-upcs').split(',');
                var filteredUpcs = upcs.filter(function(upc) {
                    if (excludeColorsArray.indexOf(upc) === -1) {
                        return true;
                    }
                    return false;
                });
                if (filteredUpcs.length > 0) {} else {
                    swatch.remove();
                }
            });
        }
        $.each($('#chooseBonusProductModal .choice-of-bonus-product.product-detail').not('.exclude-color-verified'), function() {
            var selectableColor = $(this).find('.attribute-color a.selectable:first');
            if (selectableColor.length > 0) {
                $(this).addClass('exclude-color-verified');
                selectableColor.trigger('click');
            } else {
                $(this).remove();
            }
        });
    }

    function autoAddBonusProductFromResponse(response) {
        if (response.newBonusDiscountLineItem && response.newBonusDiscountLineItem.popupdisabled && response.newBonusDiscountLineItem.autoAddPid && response.newBonusDiscountLineItem.autoAddQty) {
            var url = response.newBonusDiscountLineItem.addToCartUrl;
            var queryString = '?pids=';
            var totalQty = response.newBonusDiscountLineItem.autoAddQty;
            var pidsObject = {
                bonusProducts: [{
                    pid: response.newBonusDiscountLineItem.autoAddPid,
                    qty: response.newBonusDiscountLineItem.autoAddQty
                }]
            };
            if (response.newBonusDiscountLineItem.selectedBonusProducts) {
                for (var i = 0; i < response.newBonusDiscountLineItem.selectedBonusProducts.length; i++) {
                    var previousBonus = response.newBonusDiscountLineItem.selectedBonusProducts[i];
                    pidsObject.bonusProducts.push({
                        pid: previousBonus.pid,
                        qty: previousBonus.submittedQty,
                        option: previousBonus.option
                    });
                    totalQty += previousBonus.submittedQty;
                }
            }
            pidsObject.totalQty = totalQty;
            queryString += JSON.stringify(pidsObject);
            queryString += '&uuid=' + response.newBonusDiscountLineItem.uuid;
            queryString += '&pliuuid=' + response.newBonusDiscountLineItem.pliUUID;
            $.ajax({
                url: url + queryString,
                method: 'POST',
                success: function(data) {
                    if (data.error) {} else {
                        $('.minicart-quantity').html(data.totalQty);
                        setTimeout(function() {
                            if ($('.cart-page').length) {
                                location.reload();
                            }
                        }, 3000);
                    }
                }
            });
        }
    }

    function handlePostCartAdd(response, pid) {
        if (!response.noSizeSelected) {
            $('.mini-cart').trigger('count:update', response);
            if (response.newBonusDiscountLineItem && !(response.newBonusDiscountLineItem.promotionDeclined) && !(response.newBonusDiscountLineItem.popupdisabled) && Object.keys(response.newBonusDiscountLineItem).length !== 0) {
                chooseBonusProducts(response.newBonusDiscountLineItem).then(function(count) {
                    if (count === 0) {
                        prepareAddToBagOverlay(response, pid);
                    }
                }, function() {
                    prepareAddToBagOverlay(response, pid);
                });
            } else {
                if (!$('.cart-page').length) {
                    prepareAddToBagOverlay(response, pid);
                }
                if (response.newBonusDiscountLineItem && response.newBonusDiscountLineItem.popupdisabled && response.newBonusDiscountLineItem.autoAddPid && response.newBonusDiscountLineItem.autoAddQty) {
                    autoAddBonusProductFromResponse(response);
                }
            }
        }
    }

    function prepareAddToBagOverlay(response, pid) {
        var overlayUrl = $('input[name="addedToBagOverlayUrl"]').val();
        overlayUrl = overlayUrl.replace('0', pid);
        var itemsAddedMessage = response.message;
        var quantityTotal = response.quantityTotal;
        if (response.adjustQuantityMessage && response.adjustQuantityMessage.length) {
            overlayUrl += '&unavailable=true';
        }
        displayAddToBagOverlay(overlayUrl, itemsAddedMessage, quantityTotal, response.adjustQuantityMessage);
    }

    function getChildPids() {
        if (isBundle()) {
            return $('.bundle-item .product-id').map(function() {
                return $(this).text();
            }).get().join(',');
        }
        return [];
    }

    function injectGiftCardData($container, data) {
        var postData = data;
        var $form = $('[name=giftcard]', $container);
        if ($form.length > 0) {
            var $inputs = $form.find(':input');
            $inputs.each(function(index, input) {
                if ($(input).attr('name').indexOf('_customCardValue') > -1) {
                    postData[$(input).attr('name')] = $(input).val().replace(/,/g, '.');
                } else {
                    postData[$(input).attr('name')] = $(input).val();
                }
            });
        }
        return postData;
    }

    function refreshAddtoBagButton() {
        if ($('#chooseBonusProductModal .selected-pid').length) {
            $('#chooseBonusProductModal .add-bonus-products').prop('disabled', false);
        } else {
            $('#chooseBonusProductModal .add-bonus-products').prop('disabled', true);
        }
    }

    function updateBonusSelectButtons() {
        var $selectButtons = $('.choose-bonus-product-dialog .select-bonus-product');
        var maxSelectable = $('.choose-bonus-product-dialog').data('total-qty');
        var totalSelected = 0;
        $.each($('#chooseBonusProductModal .selected-bonus-products .selected-pid'), function() {
            totalSelected += $(this).data('qty');
        });
        if (totalSelected >= maxSelectable) {
            $selectButtons.prop('disabled', true);
        } else {
            $selectButtons.prop('disabled', false);
        }
    }

    function enableDeclineBonusPromo($container, data) {
        if (data.declineUrl) {
            $container.data('declineUrl', data.declineUrl);
            $container.data('declined', true);
            $container.on('hide.bs.modal', function() {
                if ($(this).data('declined')) {
                    $.ajax({
                        url: $(this).data('declineUrl'),
                        method: 'GET',
                        success: function() {
                            if ($('.cart-page').length) {
                                window.location.reload();
                            }
                        }
                    });
                }
            });
        }
    }

    function selectBonusProduct() {
        $(document).off('click', '.choose-bonus-product-dialog .select-bonus-product').on('click', '.choose-bonus-product-dialog .select-bonus-product', function() {
            var $choiceOfBonusProduct = $(this).parents('.choice-of-bonus-product');
            $(this).parents('#chooseBonusProductModal').data('declined', false);
            var pid = $(this).data('pid');
            var maxPids = $('.choose-bonus-product-dialog').data('total-qty');
            var submittedQty = parseInt($(this).parents('.choice-of-bonus-product').find('.bonus-quantity-select, .quantity-select').val(), 10);
            var totalQty = 0;
            $.each($('#chooseBonusProductModal .selected-bonus-products .selected-pid'), function() {
                totalQty += $(this).data('qty');
            });
            totalQty += submittedQty;
            var optionID = $(this).parents('.choice-of-bonus-product').find('.product-option').data('option-id');
            var valueId = $(this).parents('.choice-of-bonus-product').find('.options-select option:selected').data('valueId');
            if (totalQty <= maxPids) {
                var selectedBonusProductHtml = '' + '<div class="selected-pid row row-id-' + pid + '" ' + 'data-pid="' + pid + '"' + 'data-qty="' + submittedQty + '"' + 'data-optionID="' + (optionID || '') + '"' + 'data-option-selected-value="' + (valueId || '') + '"' + '>' + '<div class="col-11 bonus-product-name" >' + $choiceOfBonusProduct.find('.product-name').html() + '</div>' + '<div class="col-1 remove-bonus-product-from-selection">' + '<svg viewBox="0 0 32 32" class="remove-bonus-product-popup-icon">' + '<use xlink:href="#close-x"></use>' + '</svg>' + '</div>' + '</div>';
                $('#chooseBonusProductModal .selected-bonus-products').append(selectedBonusProductHtml);
                $('.pre-cart-products').html(totalQty);
                $('.selected-bonus-products .bonus-summary').removeClass('alert-danger');
                refreshAddtoBagButton();
                updateBonusSelectButtons();
            } else {
                $('.selected-bonus-products .bonus-summary').addClass('alert-danger');
            }
        });
    }

    function adjustModalWindowSize() {
        $('.choose-bonus-product-dialog').css('overflow', 'hidden');
        $('.choose-bonus-product-dialog .modal-body').css('height', 'auto');
        var windowHeight = $(window).height();
        var popupHeight = $('.choose-bonus-product-dialog .modal-content').height();
        if (popupHeight > windowHeight) {
            var headerHeight = $('.choose-bonus-product-dialog .modal-header').height() + Number($('.choose-bonus-product-dialog .modal-header').css('padding-top').slice(0, -2)) + Number($('.choose-bonus-product-dialog .modal-header').css('padding-bottom').slice(0, -2));
            var footerHeight = $('.choose-bonus-product-dialog .modal-footer').height() + Number($('.choose-bonus-product-dialog .modal-footer').css('padding-top').slice(0, -2)) + Number($('.choose-bonus-product-dialog .modal-footer').css('padding-bottom').slice(0, -2));
            var heightHeaderFooter = headerHeight + footerHeight;
            var heightModalBody = (windowHeight - heightHeaderFooter).toString() + 'px';
            $('.choose-bonus-product-dialog .modal-body').css('height', heightModalBody);
            $('.choose-bonus-product-dialog .modal-body').css('overflow-y', 'scroll');
        }
    }

    function updateDataLayer(response, eventData) {
        if (response.analyticsData) {
            var pageDataTrack = window.pageDataTrack || [];
            var productsArray = [];
            productsArray.push(response.analyticsData.product);
            pageDataTrack.push({
                event: [{
                    widget: eventData.widget,
                    name: response.analyticsData.event,
                    origin: eventData.origin
                }],
                widget: {
                    title: eventData.title
                },
                products: productsArray
            });
        }
    }
    module.exports = {
        attributeSelect: attributeSelect,
        colorAttribute: function() {
            $(document).off('click.productbase', '[data-attr="color"] a').on('click.productbase', '[data-attr="color"] a', function(e) {
                e.preventDefault();
                if ($(this).hasClass('selected') === false) {
                    var $productContainer = $(this).closest('.product-detail');
                    var selectedValueUrl = $(this).data('url-select');
                    selectedValueUrl = createSelectedValueUrl(selectedValueUrl, $productContainer);
                    attributeSelect(selectedValueUrl, $productContainer);
                }
            });
        },
        selectAttribute: function() {
            $(document).off('change.productbase', 'select[class*="select-"]').on('change.productbase', 'select[class*="select-"]', function(e) {
                e.preventDefault();
                var $productContainer = $(this).closest('.product-detail');
                var selectedValueUrl = createSelectedValueUrl(e.currentTarget.value, $productContainer);
                attributeSelect(selectedValueUrl, $productContainer);
            });
        },
        availability: function() {
            $(document).off('change.productbase', '.quantity-select').on('change.productbase', '.quantity-select', function(e) {
                e.preventDefault();
                var sizeIsSelected = checkIfSizeSelected();
                var quantity = getQuantitySelected($(this));
                updateQuantitySelection(this, quantity);
                var $productContainer = $(this).closest('.product-detail');
                if (sizeIsSelected && !isBundle()) {
                    if ($('#quickViewModal').hasClass('show')) {
                        $('.modal-body').spinner().start();
                    } else {
                        $.spinner().start();
                    }
                    $.ajax({
                        url: $(this).data('action') + '&quantity=' + quantity,
                        method: 'GET',
                        success: function(data) {
                            updateAvailability(data, $productContainer);
                            $.spinner().stop();
                        },
                        error: function() {
                            $.spinner().stop();
                        }
                    });
                }
            });
        },
        addToCart: function() {
            $(document).off('click.productbase', 'button.add-to-cart').on('click.productbase', 'button.add-to-cart', function() {
                var view;
                var pid;
                var $button = $(this);
                var addToCartText = $button.text();
                var addingText = $button.data('addingtext');
                var errorText = $button.data('errortext');
                var $productContainer = $button.closest('.product-detail');
                if ($('#quickViewModal').hasClass('show')) {
                    if ($('.hotspotQuickViewModal').hasClass('show')) {
                        view = 'hotspot';
                    } else {
                        view = 'tile';
                    }
                    pid = $button.closest('.product-quickview').data('pid');
                } else {
                    view = 'details';
                    pid = isBundle() ? $('.product-bundle .product-id').eq(0).text() : $('.product-id').text();
                }
                if (view === 'tile') {
                    $('.modal-body').spinner().start();
                } else {
                    $.spinner().start();
                }
                $button.text(addingText);
                var childPids = getChildPids();
                var quantity = getQuantitySelected($button);
                var price = $productContainer.find('.prices .price .sales').first().data('price-value');
                if (price === undefined) {
                    price = 0;
                } else {
                    price = parseInt(price, 10);
                    if (isNaN(price) === false) {
                        price *= quantity;
                    } else {
                        price = 0;
                    }
                }
                var newCart = false;
                var itemsInCart = $('.mini-cart-total').data('items-in-cart');
                if (itemsInCart === undefined || itemsInCart === 0) {
                    newCart = true;
                }
                if (newCart === true) {
                    $(document).trigger('omniture.trackAddNewCart', [price, quantity, pid]);
                } else {
                    $(document).trigger('omniture.trackAddExistingCart', [price, quantity, pid]);
                }
                $.ajax({
                    url: getAddToCartUrl(),
                    method: 'POST',
                    data: injectGiftCardData($productContainer, {
                        pid: pid,
                        childPids: childPids,
                        quantity: quantity,
                        sizeIsSelected: checkIfSizeSelected() ? 1 : 0
                    }),
                    success: function(data) {
                        if (data.noSizeSelected) {
                            var scrollToElement = $('.attribute-size').find('.form-group');
                            var selectSizeMessage = '<div class="alert alert-danger" role="alert">' + data.selectSizeMessage + '</div>';
                            scrollToElement.addClass('has-danger');
                            $button.text(addToCartText);
                            $productContainer.find('.max-order-qty-msg').empty().removeClass('hidden').html(selectSizeMessage);
                            $.spinner().stop();
                            if (!$('#quickViewModal').hasClass('show')) {
                                errorHelpers.scrollTo(scrollToElement);
                            }
                        } else {
                            if (view === 'tile') {
                                $('#quickViewModal').modal('hide');
                            } else if (view === 'hotspot') {
                                $('.hotspotQuickViewModal').removeClass('show');
                            }
                            updateDataLayer(data, {
                                widget: view === 'details' ? 'page' : 'modal',
                                origin: view === 'hotspot' ? 'hotspot' : '',
                                title: view === 'details' ? '' : 'quick view'
                            });
                            handlePostCartAdd(data, pid);
                            $.spinner().stop();
                            $button.text(addToCartText);
                            clearForm($('[name=giftcard]'));
                        }
                    },
                    error: function(err) {
                        var scrollToElement = $('[name=giftcard]').find('.has-danger').first();
                        if (err.responseJSON && err.responseJSON.formErrors) {
                            formValidation($('[name=giftcard]'), err.responseJSON.formErrors);
                            $button.text(addToCartText);
                        } else {
                            $button.text(errorText);
                            $button.prop('disabled');
                        }
                        if (scrollToElement && scrollToElement.length) {
                            errorHelpers.scrollTo(scrollToElement);
                        }
                        $.spinner().stop();
                    }
                });
            });
        },
        updateCart: function() {
            $(document).off('click.productbase', 'button.add-to-cart--update').on('click.productbase', 'button.add-to-cart--update', function() {
                var view;
                var pid;
                var oldpid;
                var uuid;
                var $button = $(this);
                var updateCartText = $button.text();
                var updatingText = $button.data('updatingtext');
                var errorText = $button.data('errortext');
                var $productContainer = $button.closest('.product-detail');
                oldpid = $('.product-id').text();
                uuid = $('.product-uuid').text();
                if ($('#quickViewModal').hasClass('show')) {
                    view = 'tile';
                    pid = $button.closest('.product-quickview').data('pid');
                } else if ($('.hotspotQuickViewModal').hasClass('show')) {
                    view = 'hotspot';
                    pid = $button.closest('.product-quickview').data('pid');
                } else {
                    view = 'details';
                    pid = isBundle() ? $('.product-bundle .product-id').eq(0).text() : $('.product-id').text();
                }
                if (view === 'tile') {
                    $('.modal-body').spinner().start();
                } else {
                    $.spinner().start();
                }
                $button.text(updatingText);
                var childPids = getChildPids();
                var quantity = getQuantitySelected($button);
                var price = $productContainer.find('.prices .price .sales').first().data('price-value');
                if (price === undefined) {
                    price = 0;
                } else {
                    price = parseInt(price, 10);
                    if (isNaN(price) === false) {
                        price *= quantity;
                    } else {
                        price = 0;
                    }
                }
                var newCart = false;
                var itemsInCart = $('.mini-cart-total').data('items-in-cart');
                if (itemsInCart === undefined || itemsInCart === 0) {
                    newCart = true;
                }
                if (newCart === true) {
                    $(document).trigger('omniture.trackAddNewCart', [price, quantity, pid]);
                } else {
                    $(document).trigger('omniture.trackAddExistingCart', [price, quantity, pid]);
                }
                $.ajax({
                    url: getUpdateCartUrl(),
                    method: 'POST',
                    data: injectGiftCardData($productContainer, {
                        oldpid: oldpid,
                        pid: pid,
                        childPids: childPids,
                        quantity: quantity,
                        uuid: uuid
                    }),
                    success: function(data) {
                        updateDataLayer(data, {
                            widget: 'modal',
                            origin: '',
                            title: 'quick view'
                        });
                        window.location.reload();
                    },
                    error: function(err) {
                        if (err.responseJSON && err.responseJSON.formErrors) {
                            formValidation($('[name=giftcard]'), err.responseJSON.formErrors);
                            $button.text(updateCartText);
                        } else {
                            $button.text(errorText);
                            $button.prop('disabled');
                        }
                        $.spinner().stop();
                    }
                });
            });
        },
        initSizeChartModal: function() {
            var $sizeChartModal = $('#modal-size-chart');
            $('body').append($sizeChartModal.detach());
            $(document).off('click.productbase', '.link-size-chart').on('click.productbase', '.link-size-chart', function(e) {
                e.preventDefault();
                $sizeChartModal.modal();
            });
        },
        populateReviewsLink: function() {
            var timeoutCount = 10;
            var copyReviewLink = function() {
                var $writeReview = $('.bazaarvoice-reviewsummary #BVCustomerRatings > div').first();
                if ($writeReview.length) {
                    $('.bazaarvoice-reviewsummary-placeholder').append($writeReview.clone(true));
                } else {
                    timeoutCount--;
                    if (timeoutCount > 0) {
                        setTimeout(copyReviewLink, 1500);
                    }
                }
            };
            copyReviewLink();
        },
        handleGiftCard: function() {
            $(document).on('change', '[name$=_cardValue]', function() {
                if ($(this).val() !== '0.0') {
                    $('[name$=_customCardValue]').val('');
                    $('[name$=_customCardValue]').parent().removeClass('floatl--active');
                    $('[name$=_customCardValue]').closest('.form-group').removeClass('has-success');
                    $('[name$=_customCardValue]').closest('.form-group').removeClass('has-danger');
                }
            });
            $(document).on('input', '[name$=_customCardValue]', function() {
                $('[name$=_cardValue]').val('0.0').change();
                $('[name$=_cardValue]').closest('.form-group').addClass('has-success');
            });
            $(document).on('submit', '[name=giftcard]', function(e) {
                e.preventDefault();
                $('button.add-to-cart').trigger('click');
            });
        },
        getAddToCartUrl: getAddToCartUrl,
        handlePostCartAdd: handlePostCartAdd,
        updateAvailability: updateAvailability,
        updateDataLayer: updateDataLayer,
        methods: {
            editBonusProducts: function(data) {
                return chooseBonusProducts(data);
            },
            prepareOverlay: function(response, pid) {
                prepareAddToBagOverlay(response, pid);
            }
        },
        selectBonusProduct: selectBonusProduct,
        updateModalWindowWithStickyCTAs: function() {
            $(document).on('click', '.choose-bonus-product-dialog .select-bonus-product', function() {
                adjustModalWindowSize();
            });
        },
        initModalWindowWithStickyCTAs: function() {
            $(document).on('shown.bs.modal', '#chooseBonusProductModal', function() {
                adjustModalWindowSize();
            });
        },
        handleModalWindowOnResize: function() {
            $(window).on('resize', function() {
                adjustModalWindowSize();
            });
        },
        removeBonusProduct: function() {
            $(document).on('click', '.selected-pid', function() {
                $(this).remove();
                var $selected = $('#chooseBonusProductModal .selected-bonus-products .selected-pid');
                var count = 0;
                if ($selected.length) {
                    $selected.each(function() {
                        count += parseInt($(this).data('qty'), 10);
                    });
                }
                $('.pre-cart-products').html(count);
                $('.selected-bonus-products .bonus-summary').removeClass('alert-danger');
                refreshAddtoBagButton();
                updateBonusSelectButtons();
                adjustModalWindowSize();
            });
        },
        enableBonusProductSelection: function() {
            $('body').on('bonusproduct:updateSelectButton', function(e, response) {
                $('.select-bonus-product', response.$productContainer).attr('disabled', (!response.product.readyToOrder || !response.product.available));
                var pid = response.product.id;
                $('.select-bonus-product').data('pid', pid);
            });
        },
        showMoreBonusProducts: function() {
            $(document).off('click', '.show-more-bonus-products').on('click', '.show-more-bonus-products', function() {
                var url = $(this).data('url');
                $('#chooseBonusProductModal .modal-content').spinner().start();
                $.ajax({
                    url: url,
                    method: 'GET',
                    success: function(html) {
                        var parsedHtml = parseHtml(html);
                        $('#chooseBonusProductModal').find('.show-more-bonus-products').remove();
                        $('#chooseBonusProductModal .modal-body').append(parsedHtml.body);
                        $('#chooseBonusProductModal .modal-content').spinner().stop();
                        disableExcludeColorsForBonusProducts();
                    },
                    error: function() {
                        $('#chooseBonusProductModal .modal-content').spinner().stop();
                    }
                });
            });
        },
        addBonusProductsToCart: function() {
            $(document).off('click', '.add-bonus-products').on('click', '.add-bonus-products', function() {
                var $readyToOrderBonusProducts = $('.choose-bonus-product-dialog .selected-pid');
                var queryString = '?pids=';
                var url = $('.choose-bonus-product-dialog').data('addtocarturl');
                var pidsObject = {
                    bonusProducts: []
                };
                $.each($readyToOrderBonusProducts, function() {
                    var qtyOption = parseInt($(this).data('qty'), 10);
                    var option = null;
                    if (qtyOption > 0) {
                        if ($(this).data('optionid') && $(this).data('option-selected-value')) {
                            option = {};
                            option.optionId = $(this).data('optionid');
                            option.productId = $(this).data('pid');
                            option.selectedValueId = $(this).data('option-selected-value');
                        }
                        pidsObject.bonusProducts.push({
                            pid: $(this).data('pid'),
                            qty: qtyOption,
                            options: [option]
                        });
                        pidsObject.totalQty = parseInt($('.pre-cart-products').html(), 10);
                    }
                });
                queryString += JSON.stringify(pidsObject);
                queryString = queryString + '&uuid=' + $('.choose-bonus-product-dialog').data('uuid');
                queryString = queryString + '&pliuuid=' + $('.choose-bonus-product-dialog').data('pliuuid');
                $.spinner().start();
                $.ajax({
                    url: url + queryString,
                    method: 'POST',
                    success: function(data) {
                        $.spinner().stop();
                        if (data.error) {
                            $('.error-choice-of-bonus-products').html(data.errorMessage);
                        } else {
                            $('.configure-bonus-product-attributes').html(data);
                            $('.bonus-products-step2').removeClass('hidden-xl-down');
                            $('#chooseBonusProductModal').modal('hide');
                            if ($('.add-to-cart-messages').length === 0) {
                                $('body').append('<div class="add-to-cart-messages"></div>');
                            }
                            $('.minicart-quantity').html(data.totalQty);
                            $('.add-to-cart-messages').append('<div class="alert alert-success add-to-basket-alert text-center"' + ' role="alert">' + data.msgSuccess + '</div>');
                            setTimeout(function() {
                                $('.add-to-basket-alert').remove();
                                if ($('.cart-page').length) {
                                    location.reload();
                                }
                            }, 3000);
                        }
                    },
                    error: function() {
                        $.spinner().stop();
                    }
                });
            });
        }
    };
}), (function(module, exports, __webpack_require__) {
    var name;

    function createModalHtmlElement(html, fsOnMobile, options) {
        var utils = __webpack_require__(10);
        var modalOptions = options || {};
        var $modal = $('#' + name);
        if ($modal.length !== 0) {
            $modal.remove();
        }
        var closeButton = '<button type="button" class="close" data-dismiss="modal">' + '<svg viewBox="0 0 32 32"><use xlink:href="#close-x"></use></svg>' + '</button>';
        var htmlHead = closeButton;
        if (modalOptions.logo === true) {
            htmlHead = '<div class="modal-header notification__header">' + utils.generateSvgString('puma-logo', 'notification__logo__icon') + closeButton + '</div>';
        }
        var htmlString = '<!-- Modal -->' + '<div class="modal fade ' + (fsOnMobile ? 'modal-fs-mobile' : '') + '" id="' + name + '" role="dialog">' + '<div class="modal-dialog">' + '<!-- Modal content-->' + '<div class="modal-content">' + htmlHead + '<div class="modal-body">' + html + '</div>' + '</div>' + '</div>' + '</div>';
        $('body').append(htmlString);
    }

    function createFsModalHtmlElement(html) {
        var $modal = $('#' + name);
        if ($modal.length !== 0) {
            $modal.remove();
        }
        var htmlString = '<!-- Modal -->' + '<div class="modal fade modal-fs" id="' + name + '" role="dialog">' + '<div class="modal-dialog">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<button type="button" class="modal-fs__close" data-dismiss="modal">' + '<svg viewBox="0 0 32 32" class="modal-fs__close__icon"><use xlink:href="#close-x"></use></svg>' + '</button>' + '<div class="modal-body modal-fs__body">' + html + '</div>' + '</div>' + '</div>' + '</div>';
        $('body').append(htmlString);
    }
    module.exports = {
        create: function(modalName, html, fsOnMobile, options) {
            var modalOptions = options || {};
            name = modalName.split(' ').join('-');
            createModalHtmlElement(html, fsOnMobile, modalOptions);
        },
        createFs: function(modalName, html) {
            name = modalName.split(' ').join('-');
            createFsModalHtmlElement(html);
        },
        show: function() {
            $('#' + name).modal('show');
        },
        hide: function() {
            $('#' + name).modal('hide');
        },
        startSpinner: function() {
            $('#' + name + ' .modal-body').spinner().start();
        },
        stopSpinner: function() {
            $.spinner().stop();
        }
    };
}), (function(module, exports) {
    'use strict';
    module.exports = function(form) {
        if (form.length > 0) {
            var $inputs = form.find(':input');
            $inputs.each(function(index, input) {
                $(input).val('');
                $(input).parent().removeClass('floatl--active');
                $(input).closest('.form-group').removeClass('has-success');
            });
            $(window).trigger('form:reset', form);
        }
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var base = __webpack_require__(14);
    var modal = __webpack_require__(15);
    var form = __webpack_require__(5);
    module.exports = {
        init: function() {
            base.colorAttribute();
            base.selectAttribute();
            base.availability();
            base.addToCart();
            base.updateCart();
            base.handleGiftCard();
            base.selectBonusProduct();
            base.updateModalWindowWithStickyCTAs();
            base.initModalWindowWithStickyCTAs();
            base.handleModalWindowOnResize();
            base.removeBonusProduct();
            base.enableBonusProductSelection();
            base.showMoreBonusProducts();
            base.addBonusProductsToCart();
        },
        displayQuickView: function(quickviewUrl) {
            var productUrl = quickviewUrl.replace('Product-ShowQuickView', 'Product-Show').replace('Product-EditAttributes', 'Product-Show');
            $.ajax({
                url: quickviewUrl,
                method: 'GET',
                dataType: 'html',
                success: function(html) {
                    modal.create('quickViewModal', html, true);
                    modal.startSpinner();
                    $('#quickViewModal .full-pdp-link').attr('href', productUrl);
                    $('#quickViewModal .size-chart').attr('href', productUrl);
                    form.init();
                    modal.show();
                    modal.stopSpinner();
                    window.pageData.product = ($('[data-layer-product-quick-view]').data('layerProductQuickView'));
                },
                error: function() {
                    modal.stopSpinner();
                }
            });
        }
    };
}), , , , , , (function(module, exports) {
    'use strict';
    const DEFAULT_LOADING_CLASS = 'loading';
    const DEFAULT_REDIRECT_CONFIDENCE_TIME = 30000;
    var INITIALIZED_COMPONENTS = {};
    module.exports = {
        functions: {
            init: function(buttonsSelector, progressClass, confidenceTime) {
                var loadingClass = progressClass || DEFAULT_LOADING_CLASS;
                var timeoutDuration = confidenceTime || DEFAULT_REDIRECT_CONFIDENCE_TIME;
                INITIALIZED_COMPONENTS[buttonsSelector] = {
                    loadingClass: loadingClass
                };
                $(document).on('click', buttonsSelector, function() {
                    var $btn = $(this);
                    setTimeout(function() {
                        $btn.attr('disabled', 'disabled').addClass(loadingClass).spinner().start();
                    }, 100);
                    setTimeout(function() {
                        $btn.removeAttr('disabled').removeClass(loadingClass).spinner().stop();
                    }, timeoutDuration);
                });
            },
            enable: function(buttonsSelector) {
                var $btn = $(buttonsSelector);
                var btnObj = INITIALIZED_COMPONENTS[buttonsSelector];
                if ($btn.length && btnObj) {
                    $btn.removeAttr('disabled').removeClass(btnObj.loadingClass).spinner().stop();
                }
            }
        }
    };
}), , , , (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
     * jQuery JavaScript Library v3.4.1
     * https://jquery.com/
     *
     * Includes Sizzle.js
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2019-05-01T21:04Z
     */
    (function(global, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
            module.exports = global.document ? factory(global, true) : function(w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
        } else {
            factory(global);
        }
    })(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
        "use strict";
        var arr = [];
        var document = window.document;
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var concat = arr.concat;
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction(obj) {
            return typeof obj === "function" && typeof obj.nodeType !== "number";
        };
        var isWindow = function isWindow(obj) {
            return obj != null && obj === obj.window;
        };
        var preservedScriptAttributes = {
            type: true,
            src: true,
            nonce: true,
            noModule: true
        };

        function DOMEval(code, node, doc) {
            doc = doc || document;
            var i, val, script = doc.createElement("script");
            script.text = code;
            if (node) {
                for (i in preservedScriptAttributes) {
                    val = node[i] || node.getAttribute && node.getAttribute(i);
                    if (val) {
                        script.setAttribute(i, val);
                    }
                }
            }
            doc.head.appendChild(script).parentNode.removeChild(script);
        }

        function toType(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var
            version = "3.4.1",
            jQuery = function(selector, context) {
                return new jQuery.fn.init(selector, context);
            },
            rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery.fn = jQuery.prototype = {
            jquery: version,
            constructor: jQuery,
            length: 0,
            toArray: function() {
                return slice.call(this);
            },
            get: function(num) {
                if (num == null) {
                    return slice.call(this);
                }
                return num < 0 ? this[num + this.length] : this[num];
            },
            pushStack: function(elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                ret.prevObject = this;
                return ret;
            },
            each: function(callback) {
                return jQuery.each(this, callback);
            },
            map: function(callback) {
                return this.pushStack(jQuery.map(this, function(elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            slice: function() {
                return this.pushStack(slice.apply(this, arguments));
            },
            first: function() {
                return this.eq(0);
            },
            last: function() {
                return this.eq(-1);
            },
            eq: function(i) {
                var len = this.length,
                    j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            end: function() {
                return this.prevObject || this.constructor();
            },
            push: push,
            sort: arr.sort,
            splice: arr.splice
        };
        jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[i] || {};
                i++;
            }
            if (typeof target !== "object" && !isFunction(target)) {
                target = {};
            }
            if (i === length) {
                target = this;
                i--;
            }
            for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        copy = options[name];
                        if (name === "__proto__" || target === copy) {
                            continue;
                        }
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                            src = target[name];
                            if (copyIsArray && !Array.isArray(src)) {
                                clone = [];
                            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                                clone = {};
                            } else {
                                clone = src;
                            }
                            copyIsArray = false;
                            target[name] = jQuery.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        };
        jQuery.extend({
            expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
            isReady: true,
            error: function(msg) {
                throw new Error(msg);
            },
            noop: function() {},
            isPlainObject: function(obj) {
                var proto, Ctor;
                if (!obj || toString.call(obj) !== "[object Object]") {
                    return false;
                }
                proto = getProto(obj);
                if (!proto) {
                    return true;
                }
                Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
                return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
            },
            isEmptyObject: function(obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            globalEval: function(code, options) {
                DOMEval(code, {
                    nonce: options && options.nonce
                });
            },
            each: function(obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj)) {
                    length = obj.length;
                    for (; i < length; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                }
                return obj;
            },
            trim: function(text) {
                return text == null ? "" : (text + "").replace(rtrim, "");
            },
            makeArray: function(arr, results) {
                var ret = results || [];
                if (arr != null) {
                    if (isArrayLike(Object(arr))) {
                        jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                    } else {
                        push.call(ret, arr);
                    }
                }
                return ret;
            },
            inArray: function(elem, arr, i) {
                return arr == null ? -1 : indexOf.call(arr, elem, i);
            },
            merge: function(first, second) {
                var len = +second.length,
                    j = 0,
                    i = first.length;
                for (; j < len; j++) {
                    first[i++] = second[j];
                }
                first.length = i;
                return first;
            },
            grep: function(elems, callback, invert) {
                var callbackInverse, matches = [],
                    i = 0,
                    length = elems.length,
                    callbackExpect = !invert;
                for (; i < length; i++) {
                    callbackInverse = !callback(elems[i], i);
                    if (callbackInverse !== callbackExpect) {
                        matches.push(elems[i]);
                    }
                }
                return matches;
            },
            map: function(elems, callback, arg) {
                var length, value, i = 0,
                    ret = [];
                if (isArrayLike(elems)) {
                    length = elems.length;
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                } else {
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                }
                return concat.apply([], ret);
            },
            guid: 1,
            support: support
        });
        if (typeof Symbol === "function") {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        function isArrayLike(obj) {
            var length = !!obj && "length" in obj && obj.length,
                type = toType(obj);
            if (isFunction(obj) || isWindow(obj)) {
                return false;
            }
            return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
        }
        var Sizzle =
            /*!
             * Sizzle CSS Selector Engine v2.3.4
             * https://sizzlejs.com/
             *
             * Copyright JS Foundation and other contributors
             * Released under the MIT license
             * https://js.foundation/
             *
             * Date: 2019-04-08
             */
            (function(window) {
                var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(),
                    preferredDoc = window.document,
                    dirruns = 0,
                    done = 0,
                    classCache = createCache(),
                    tokenCache = createCache(),
                    compilerCache = createCache(),
                    nonnativeSelectorCache = createCache(),
                    sortOrder = function(a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                        }
                        return 0;
                    },
                    hasOwn = ({}).hasOwnProperty,
                    arr = [],
                    pop = arr.pop,
                    push_native = arr.push,
                    push = arr.push,
                    slice = arr.slice,
                    indexOf = function(list, elem) {
                        var i = 0,
                            len = list.length;
                        for (; i < len; i++) {
                            if (list[i] === elem) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    whitespace = "[\\x20\\t\\r\\n\\f]",
                    identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
                    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                    "*([*^$|!~]?=)" + whitespace +
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",
                    pseudos = ":(" + identifier + ")(?:\\((" +
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    ".*" +
                    ")\\)|)",
                    rwhitespace = new RegExp(whitespace + "+", "g"),
                    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
                    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                    rdescend = new RegExp(whitespace + "|>"),
                    rpseudo = new RegExp(pseudos),
                    ridentifier = new RegExp("^" + identifier + "$"),
                    matchExpr = {
                        "ID": new RegExp("^#(" + identifier + ")"),
                        "CLASS": new RegExp("^\\.(" + identifier + ")"),
                        "TAG": new RegExp("^(" + identifier + "|[*])"),
                        "ATTR": new RegExp("^" + attributes),
                        "PSEUDO": new RegExp("^" + pseudos),
                        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                            "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                    },
                    rhtml = /HTML$/i,
                    rinputs = /^(?:input|select|textarea|button)$/i,
                    rheader = /^h\d$/i,
                    rnative = /^[^{]+\{\s*\[native \w/,
                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    rsibling = /[+~]/,
                    runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                    funescape = function(_, escaped, escapedWhitespace) {
                        var high = "0x" + escaped - 0x10000;
                        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                    },
                    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                    fcssescape = function(ch, asCodePoint) {
                        if (asCodePoint) {
                            if (ch === "\0") {
                                return "\uFFFD";
                            }
                            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                        }
                        return "\\" + ch;
                    },
                    unloadHandler = function() {
                        setDocument();
                    },
                    inDisabledFieldset = addCombinator(function(elem) {
                        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
                    }, {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
                    arr[preferredDoc.childNodes.length].nodeType;
                } catch (e) {
                    push = {
                        apply: arr.length ? function(target, els) {
                            push_native.apply(target, slice.call(els));
                        } : function(target, els) {
                            var j = target.length,
                                i = 0;
                            while ((target[j++] = els[i++])) {}
                            target.length = j - 1;
                        }
                    };
                }

                function Sizzle(selector, context, results, seed) {
                    var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
                        nodeType = context ? context.nodeType : 9;
                    results = results || [];
                    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                        return results;
                    }
                    if (!seed) {
                        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                            setDocument(context);
                        }
                        context = context || document;
                        if (documentIsHTML) {
                            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                                if ((m = match[1])) {
                                    if (nodeType === 9) {
                                        if ((elem = context.getElementById(m))) {
                                            if (elem.id === m) {
                                                results.push(elem);
                                                return results;
                                            }
                                        } else {
                                            return results;
                                        }
                                    } else {
                                        if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    }
                                } else if (match[2]) {
                                    push.apply(results, context.getElementsByTagName(selector));
                                    return results;
                                } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                                    push.apply(results, context.getElementsByClassName(m));
                                    return results;
                                }
                            }
                            if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                                newSelector = selector;
                                newContext = context;
                                if (nodeType === 1 && rdescend.test(selector)) {
                                    if ((nid = context.getAttribute("id"))) {
                                        nid = nid.replace(rcssescape, fcssescape);
                                    } else {
                                        context.setAttribute("id", (nid = expando));
                                    }
                                    groups = tokenize(selector);
                                    i = groups.length;
                                    while (i--) {
                                        groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                    }
                                    newSelector = groups.join(",");
                                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                }
                                try {
                                    push.apply(results, newContext.querySelectorAll(newSelector));
                                    return results;
                                } catch (qsaError) {
                                    nonnativeSelectorCache(selector, true);
                                } finally {
                                    if (nid === expando) {
                                        context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                    }
                    return select(selector.replace(rtrim, "$1"), context, results, seed);
                }

                function createCache() {
                    var keys = [];

                    function cache(key, value) {
                        if (keys.push(key + " ") > Expr.cacheLength) {
                            delete cache[keys.shift()];
                        }
                        return (cache[key + " "] = value);
                    }
                    return cache;
                }

                function markFunction(fn) {
                    fn[expando] = true;
                    return fn;
                }

                function assert(fn) {
                    var el = document.createElement("fieldset");
                    try {
                        return !!fn(el);
                    } catch (e) {
                        return false;
                    } finally {
                        if (el.parentNode) {
                            el.parentNode.removeChild(el);
                        }
                        el = null;
                    }
                }

                function addHandle(attrs, handler) {
                    var arr = attrs.split("|"),
                        i = arr.length;
                    while (i--) {
                        Expr.attrHandle[arr[i]] = handler;
                    }
                }

                function siblingCheck(a, b) {
                    var cur = b && a,
                        diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
                    if (diff) {
                        return diff;
                    }
                    if (cur) {
                        while ((cur = cur.nextSibling)) {
                            if (cur === b) {
                                return -1;
                            }
                        }
                    }
                    return a ? 1 : -1;
                }

                function createInputPseudo(type) {
                    return function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === type;
                    };
                }

                function createButtonPseudo(type) {
                    return function(elem) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === "input" || name === "button") && elem.type === type;
                    };
                }

                function createDisabledPseudo(disabled) {
                    return function(elem) {
                        if ("form" in elem) {
                            if (elem.parentNode && elem.disabled === false) {
                                if ("label" in elem) {
                                    if ("label" in elem.parentNode) {
                                        return elem.parentNode.disabled === disabled;
                                    } else {
                                        return elem.disabled === disabled;
                                    }
                                }
                                return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                            }
                            return elem.disabled === disabled;
                        } else if ("label" in elem) {
                            return elem.disabled === disabled;
                        }
                        return false;
                    };
                }

                function createPositionalPseudo(fn) {
                    return markFunction(function(argument) {
                        argument = +argument;
                        return markFunction(function(seed, matches) {
                            var j, matchIndexes = fn([], seed.length, argument),
                                i = matchIndexes.length;
                            while (i--) {
                                if (seed[(j = matchIndexes[i])]) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }

                function testContext(context) {
                    return context && typeof context.getElementsByTagName !== "undefined" && context;
                }
                support = Sizzle.support = {};
                isXML = Sizzle.isXML = function(elem) {
                    var namespace = elem.namespaceURI,
                        docElem = (elem.ownerDocument || elem).documentElement;
                    return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
                };
                setDocument = Sizzle.setDocument = function(node) {
                    var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                        return document;
                    }
                    document = doc;
                    docElem = document.documentElement;
                    documentIsHTML = !isXML(document);
                    if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                        if (subWindow.addEventListener) {
                            subWindow.addEventListener("unload", unloadHandler, false);
                        } else if (subWindow.attachEvent) {
                            subWindow.attachEvent("onunload", unloadHandler);
                        }
                    }
                    support.attributes = assert(function(el) {
                        el.className = "i";
                        return !el.getAttribute("className");
                    });
                    support.getElementsByTagName = assert(function(el) {
                        el.appendChild(document.createComment(""));
                        return !el.getElementsByTagName("*").length;
                    });
                    support.getElementsByClassName = rnative.test(document.getElementsByClassName);
                    support.getById = assert(function(el) {
                        docElem.appendChild(el).id = expando;
                        return !document.getElementsByName || !document.getElementsByName(expando).length;
                    });
                    if (support.getById) {
                        Expr.filter["ID"] = function(id) {
                            var attrId = id.replace(runescape, funescape);
                            return function(elem) {
                                return elem.getAttribute("id") === attrId;
                            };
                        };
                        Expr.find["ID"] = function(id, context) {
                            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                var elem = context.getElementById(id);
                                return elem ? [elem] : [];
                            }
                        };
                    } else {
                        Expr.filter["ID"] = function(id) {
                            var attrId = id.replace(runescape, funescape);
                            return function(elem) {
                                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                return node && node.value === attrId;
                            };
                        };
                        Expr.find["ID"] = function(id, context) {
                            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                var node, i, elems, elem = context.getElementById(id);
                                if (elem) {
                                    node = elem.getAttributeNode("id");
                                    if (node && node.value === id) {
                                        return [elem];
                                    }
                                    elems = context.getElementsByName(id);
                                    i = 0;
                                    while ((elem = elems[i++])) {
                                        node = elem.getAttributeNode("id");
                                        if (node && node.value === id) {
                                            return [elem];
                                        }
                                    }
                                }
                                return [];
                            }
                        };
                    }
                    Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } : function(tag, context) {
                        var elem, tmp = [],
                            i = 0,
                            results = context.getElementsByTagName(tag);
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }
                            return tmp;
                        }
                        return results;
                    };
                    Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };
                    rbuggyMatches = [];
                    rbuggyQSA = [];
                    if ((support.qsa = rnative.test(document.querySelectorAll))) {
                        assert(function(el) {
                            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                                "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                "<option selected=''></option></select>";
                            if (el.querySelectorAll("[msallowcapture^='']").length) {
                                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                            }
                            if (!el.querySelectorAll("[selected]").length) {
                                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                            }
                            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                                rbuggyQSA.push("~=");
                            }
                            if (!el.querySelectorAll(":checked").length) {
                                rbuggyQSA.push(":checked");
                            }
                            if (!el.querySelectorAll("a#" + expando + "+*").length) {
                                rbuggyQSA.push(".#.+[+~]");
                            }
                        });
                        assert(function(el) {
                            el.innerHTML = "<a href='' disabled='disabled'></a>" +
                                "<select disabled='disabled'><option/></select>";
                            var input = document.createElement("input");
                            input.setAttribute("type", "hidden");
                            el.appendChild(input).setAttribute("name", "D");
                            if (el.querySelectorAll("[name=d]").length) {
                                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                            }
                            if (el.querySelectorAll(":enabled").length !== 2) {
                                rbuggyQSA.push(":enabled", ":disabled");
                            }
                            docElem.appendChild(el).disabled = true;
                            if (el.querySelectorAll(":disabled").length !== 2) {
                                rbuggyQSA.push(":enabled", ":disabled");
                            }
                            el.querySelectorAll("*,:x");
                            rbuggyQSA.push(",.*:");
                        });
                    }
                    if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
                        assert(function(el) {
                            support.disconnectedMatch = matches.call(el, "*");
                            matches.call(el, "[s!='']:x");
                            rbuggyMatches.push("!=", pseudos);
                        });
                    }
                    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
                    hasCompare = rnative.test(docElem.compareDocumentPosition);
                    contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                    } : function(a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    sortOrder = hasCompare ? function(a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }
                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
                            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }
                            return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
                        }
                        return compare & 4 ? -1 : 1;
                    } : function(a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var cur, i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];
                        if (!aup || !bup) {
                            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }
                        while (ap[i] === bp[i]) {
                            i++;
                        }
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                    };
                    return document;
                };
                Sizzle.matches = function(expr, elements) {
                    return Sizzle(expr, null, null, elements);
                };
                Sizzle.matchesSelector = function(elem, expr) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                        try {
                            var ret = matches.call(elem, expr);
                            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                                return ret;
                            }
                        } catch (e) {
                            nonnativeSelectorCache(expr, true);
                        }
                    }
                    return Sizzle(expr, document, null, [elem]).length > 0;
                };
                Sizzle.contains = function(context, elem) {
                    if ((context.ownerDocument || context) !== document) {
                        setDocument(context);
                    }
                    return contains(context, elem);
                };
                Sizzle.attr = function(elem, name) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                };
                Sizzle.escape = function(sel) {
                    return (sel + "").replace(rcssescape, fcssescape);
                };
                Sizzle.error = function(msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg);
                };
                Sizzle.uniqueSort = function(results) {
                    var elem, duplicates = [],
                        j = 0,
                        i = 0;
                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice(0);
                    results.sort(sortOrder);
                    if (hasDuplicate) {
                        while ((elem = results[i++])) {
                            if (elem === results[i]) {
                                j = duplicates.push(i);
                            }
                        }
                        while (j--) {
                            results.splice(duplicates[j], 1);
                        }
                    }
                    sortInput = null;
                    return results;
                };
                getText = Sizzle.getText = function(elem) {
                    var node, ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
                    if (!nodeType) {
                        while ((node = elem[i++])) {
                            ret += getText(node);
                        }
                    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                        if (typeof elem.textContent === "string") {
                            return elem.textContent;
                        } else {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                ret += getText(elem);
                            }
                        }
                    } else if (nodeType === 3 || nodeType === 4) {
                        return elem.nodeValue;
                    }
                    return ret;
                };
                Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: true
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: true
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        "ATTR": function(match) {
                            match[1] = match[1].replace(runescape, funescape);
                            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                            if (match[2] === "~=") {
                                match[3] = " " + match[3] + " ";
                            }
                            return match.slice(0, 4);
                        },
                        "CHILD": function(match) {
                            match[1] = match[1].toLowerCase();
                            if (match[1].slice(0, 3) === "nth") {
                                if (!match[3]) {
                                    Sizzle.error(match[0]);
                                }
                                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                match[5] = +((match[7] + match[8]) || match[3] === "odd");
                            } else if (match[3]) {
                                Sizzle.error(match[0]);
                            }
                            return match;
                        },
                        "PSEUDO": function(match) {
                            var excess, unquoted = !match[6] && match[2];
                            if (matchExpr["CHILD"].test(match[0])) {
                                return null;
                            }
                            if (match[3]) {
                                match[2] = match[4] || match[5] || "";
                            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                                match[0] = match[0].slice(0, excess);
                                match[2] = unquoted.slice(0, excess);
                            }
                            return match.slice(0, 3);
                        }
                    },
                    filter: {
                        "TAG": function(nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return nodeNameSelector === "*" ? function() {
                                return true;
                            } : function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                        },
                        "CLASS": function(className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                            });
                        },
                        "ATTR": function(name, operator, check) {
                            return function(elem) {
                                var result = Sizzle.attr(elem, name);
                                if (result == null) {
                                    return operator === "!=";
                                }
                                if (!operator) {
                                    return true;
                                }
                                result += "";
                                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                            };
                        },
                        "CHILD": function(type, what, argument, first, last) {
                            var simple = type.slice(0, 3) !== "nth",
                                forward = type.slice(-4) !== "last",
                                ofType = what === "of-type";
                            return first === 1 && last === 0 ? function(elem) {
                                return !!elem.parentNode;
                            } : function(elem, context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = false;
                                if (parent) {
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while ((node = node[dir])) {
                                                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                    return false;
                                                }
                                            }
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }
                                    start = [forward ? parent.firstChild : parent.lastChild];
                                    if (forward && useCache) {
                                        node = parent;
                                        outerCache = node[expando] || (node[expando] = {});
                                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];
                                        while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break;
                                            }
                                        }
                                    } else {
                                        if (useCache) {
                                            node = elem;
                                            outerCache = node[expando] || (node[expando] = {});
                                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                            cache = uniqueCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = nodeIndex;
                                        }
                                        if (diff === false) {
                                            while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                                                if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                    if (useCache) {
                                                        outerCache = node[expando] || (node[expando] = {});
                                                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                        uniqueCache[type] = [dirruns, diff];
                                                    }
                                                    if (node === elem) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    diff -= last;
                                    return diff === first || (diff % first === 0 && diff / first >= 0);
                                }
                            };
                        },
                        "PSEUDO": function(pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            if (fn[expando]) {
                                return fn(argument);
                            }
                            if (fn.length > 1) {
                                args = [pseudo, pseudo, "", argument];
                                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                    var idx, matched = fn(seed, argument),
                                        i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) : function(elem) {
                                    return fn(elem, 0, args);
                                };
                            }
                            return fn;
                        }
                    },
                    pseudos: {
                        "not": markFunction(function(selector) {
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                                var elem, unmatched = matcher(seed, null, xml, []),
                                    i = seed.length;
                                while (i--) {
                                    if ((elem = unmatched[i])) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) : function(elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                input[0] = null;
                                return !results.pop();
                            };
                        }),
                        "has": markFunction(function(selector) {
                            return function(elem) {
                                return Sizzle(selector, elem).length > 0;
                            };
                        }),
                        "contains": markFunction(function(text) {
                            text = text.replace(runescape, funescape);
                            return function(elem) {
                                return (elem.textContent || getText(elem)).indexOf(text) > -1;
                            };
                        }),
                        "lang": markFunction(function(lang) {
                            if (!ridentifier.test(lang || "")) {
                                Sizzle.error("unsupported lang: " + lang);
                            }
                            lang = lang.replace(runescape, funescape).toLowerCase();
                            return function(elem) {
                                var elemLang;
                                do {
                                    if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                    }
                                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                return false;
                            };
                        }),
                        "target": function(elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id;
                        },
                        "root": function(elem) {
                            return elem === docElem;
                        },
                        "focus": function(elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },
                        "enabled": createDisabledPseudo(false),
                        "disabled": createDisabledPseudo(true),
                        "checked": function(elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                        },
                        "selected": function(elem) {
                            if (elem.parentNode) {
                                elem.parentNode.selectedIndex;
                            }
                            return elem.selected === true;
                        },
                        "empty": function(elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                if (elem.nodeType < 6) {
                                    return false;
                                }
                            }
                            return true;
                        },
                        "parent": function(elem) {
                            return !Expr.pseudos["empty"](elem);
                        },
                        "header": function(elem) {
                            return rheader.test(elem.nodeName);
                        },
                        "input": function(elem) {
                            return rinputs.test(elem.nodeName);
                        },
                        "button": function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === "button" || name === "button";
                        },
                        "text": function(elem) {
                            var attr;
                            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                        },
                        "first": createPositionalPseudo(function() {
                            return [0];
                        }),
                        "last": createPositionalPseudo(function(matchIndexes, length) {
                            return [length - 1];
                        }),
                        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument];
                        }),
                        "even": createPositionalPseudo(function(matchIndexes, length) {
                            var i = 0;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        "odd": createPositionalPseudo(function(matchIndexes, length) {
                            var i = 1;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument > length ? length : argument;
                            for (; --i >= 0;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (; ++i < length;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        })
                    }
                };
                Expr.pseudos["nth"] = Expr.pseudos["eq"];
                for (i in {
                        radio: true,
                        checkbox: true,
                        file: true,
                        password: true,
                        image: true
                    }) {
                    Expr.pseudos[i] = createInputPseudo(i);
                }
                for (i in {
                        submit: true,
                        reset: true
                    }) {
                    Expr.pseudos[i] = createButtonPseudo(i);
                }

                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();
                tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                    if (cached) {
                        return parseOnly ? 0 : cached.slice(0);
                    }
                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;
                    while (soFar) {
                        if (!matched || (match = rcomma.exec(soFar))) {
                            if (match) {
                                soFar = soFar.slice(match[0].length) || soFar;
                            }
                            groups.push((tokens = []));
                        }
                        matched = false;
                        if ((match = rcombinators.exec(soFar))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: match[0].replace(rtrim, " ")
                            });
                            soFar = soFar.slice(matched.length);
                        }
                        for (type in Expr.filter) {
                            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice(matched.length);
                            }
                        }
                        if (!matched) {
                            break;
                        }
                    }
                    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
                };

                function toSelector(tokens) {
                    var i = 0,
                        len = tokens.length,
                        selector = "";
                    for (; i < len; i++) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }

                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir,
                        skip = combinator.next,
                        key = skip || dir,
                        checkNonElements = base && key === "parentNode",
                        doneName = done++;
                    return combinator.first ? function(elem, context, xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                        return false;
                    } : function(elem, context, xml) {
                        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                        if (xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});
                                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                                    if (skip && skip === elem.nodeName.toLowerCase()) {
                                        elem = elem[dir] || elem;
                                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                        return (newCache[2] = oldCache[2]);
                                    } else {
                                        uniqueCache[key] = newCache;
                                        if ((newCache[2] = matcher(elem, context, xml))) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    };
                }

                function elementMatcher(matchers) {
                    return matchers.length > 1 ? function(elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } : matchers[0];
                }

                function multipleContexts(selector, contexts, results) {
                    var i = 0,
                        len = contexts.length;
                    for (; i < len; i++) {
                        Sizzle(selector, contexts[i], results);
                    }
                    return results;
                }

                function condense(unmatched, map, filter, context, xml) {
                    var elem, newUnmatched = [],
                        i = 0,
                        len = unmatched.length,
                        mapped = map != null;
                    for (; i < len; i++) {
                        if ((elem = unmatched[i])) {
                            if (!filter || filter(elem, context, xml)) {
                                newUnmatched.push(elem);
                                if (mapped) {
                                    map.push(i);
                                }
                            }
                        }
                    }
                    return newUnmatched;
                }

                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    if (postFilter && !postFilter[expando]) {
                        postFilter = setMatcher(postFilter);
                    }
                    if (postFinder && !postFinder[expando]) {
                        postFinder = setMatcher(postFinder, postSelector);
                    }
                    return markFunction(function(seed, results, context, xml) {
                        var temp, i, elem, preMap = [],
                            postMap = [],
                            preexisting = results.length,
                            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher) {
                            matcher(matcherIn, matcherOut, context, xml);
                        }
                        if (postFilter) {
                            temp = condense(matcherOut, postMap);
                            postFilter(temp, [], context, xml);
                            i = temp.length;
                            while (i--) {
                                if ((elem = temp[i])) {
                                    matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                }
                            }
                        }
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    temp = [];
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i])) {
                                            temp.push((matcherIn[i] = elem));
                                        }
                                    }
                                    postFinder(null, (matcherOut = []), temp, xml);
                                }
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }
                        } else {
                            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                            if (postFinder) {
                                postFinder(null, results, matcherOut, xml);
                            } else {
                                push.apply(results, matcherOut);
                            }
                        }
                    });
                }

                function matcherFromTokens(tokens) {
                    var checkContext, matcher, j, len = tokens.length,
                        leadingRelative = Expr.relative[tokens[0].type],
                        implicitRelative = leadingRelative || Expr.relative[" "],
                        i = leadingRelative ? 1 : 0,
                        matchContext = addCombinator(function(elem) {
                            return elem === checkContext;
                        }, implicitRelative, true),
                        matchAnyContext = addCombinator(function(elem) {
                            return indexOf(checkContext, elem) > -1;
                        }, implicitRelative, true),
                        matchers = [function(elem, context, xml) {
                            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                            checkContext = null;
                            return ret;
                        }];
                    for (; i < len; i++) {
                        if ((matcher = Expr.relative[tokens[i].type])) {
                            matchers = [addCombinator(elementMatcher(matchers), matcher)];
                        } else {
                            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                            if (matcher[expando]) {
                                j = ++i;
                                for (; j < len; j++) {
                                    if (Expr.relative[tokens[j].type]) {
                                        break;
                                    }
                                }
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                    value: tokens[i - 2].type === " " ? "*" : ""
                                })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
                            }
                            matchers.push(matcher);
                        }
                    }
                    return elementMatcher(matchers);
                }

                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0,
                        byElement = elementMatchers.length > 0,
                        superMatcher = function(seed, context, xml, results, outermost) {
                            var elem, j, matcher, matchedCount = 0,
                                i = "0",
                                unmatched = seed && [],
                                setMatched = [],
                                contextBackup = outermostContext,
                                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                len = elems.length;
                            if (outermost) {
                                outermostContext = context === document || context || outermost;
                            }
                            for (; i !== len && (elem = elems[i]) != null; i++) {
                                if (byElement && elem) {
                                    j = 0;
                                    if (!context && elem.ownerDocument !== document) {
                                        setDocument(elem);
                                        xml = !documentIsHTML;
                                    }
                                    while ((matcher = elementMatchers[j++])) {
                                        if (matcher(elem, context || document, xml)) {
                                            results.push(elem);
                                            break;
                                        }
                                    }
                                    if (outermost) {
                                        dirruns = dirrunsUnique;
                                    }
                                }
                                if (bySet) {
                                    if ((elem = !matcher && elem)) {
                                        matchedCount--;
                                    }
                                    if (seed) {
                                        unmatched.push(elem);
                                    }
                                }
                            }
                            matchedCount += i;
                            if (bySet && i !== matchedCount) {
                                j = 0;
                                while ((matcher = setMatchers[j++])) {
                                    matcher(unmatched, setMatched, context, xml);
                                }
                                if (seed) {
                                    if (matchedCount > 0) {
                                        while (i--) {
                                            if (!(unmatched[i] || setMatched[i])) {
                                                setMatched[i] = pop.call(results);
                                            }
                                        }
                                    }
                                    setMatched = condense(setMatched);
                                }
                                push.apply(results, setMatched);
                                if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                                    Sizzle.uniqueSort(results);
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                outermostContext = contextBackup;
                            }
                            return unmatched;
                        };
                    return bySet ? markFunction(superMatcher) : superMatcher;
                }
                compile = Sizzle.compile = function(selector, match) {
                    var i, setMatchers = [],
                        elementMatchers = [],
                        cached = compilerCache[selector + " "];
                    if (!cached) {
                        if (!match) {
                            match = tokenize(selector);
                        }
                        i = match.length;
                        while (i--) {
                            cached = matcherFromTokens(match[i]);
                            if (cached[expando]) {
                                setMatchers.push(cached);
                            } else {
                                elementMatchers.push(cached);
                            }
                        }
                        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                        cached.selector = selector;
                    }
                    return cached;
                };
                select = Sizzle.select = function(selector, context, results, seed) {
                    var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
                        match = !seed && tokenize((selector = compiled.selector || selector));
                    results = results || [];
                    if (match.length === 1) {
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results;
                            } else if (compiled) {
                                context = context.parentNode;
                            }
                            selector = selector.slice(tokens.shift().value.length);
                        }
                        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
                            if (Expr.relative[(type = token.type)]) {
                                break;
                            }
                            if ((find = Expr.find[type])) {
                                if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
                    return results;
                };
                support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
                support.detectDuplicates = !!hasDuplicate;
                setDocument();
                support.sortDetached = assert(function(el) {
                    return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
                });
                if (!assert(function(el) {
                        el.innerHTML = "<a href='#'></a>";
                        return el.firstChild.getAttribute("href") === "#";
                    })) {
                    addHandle("type|href|height|width", function(elem, name, isXML) {
                        if (!isXML) {
                            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                        }
                    });
                }
                if (!support.attributes || !assert(function(el) {
                        el.innerHTML = "<input/>";
                        el.firstChild.setAttribute("value", "");
                        return el.firstChild.getAttribute("value") === "";
                    })) {
                    addHandle("value", function(elem, name, isXML) {
                        if (!isXML && elem.nodeName.toLowerCase() === "input") {
                            return elem.defaultValue;
                        }
                    });
                }
                if (!assert(function(el) {
                        return el.getAttribute("disabled") == null;
                    })) {
                    addHandle(booleans, function(elem, name, isXML) {
                        var val;
                        if (!isXML) {
                            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                        }
                    });
                }
                return Sizzle;
            })(window);
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
        jQuery.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir, until) {
            var matched = [],
                truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        };
        var siblings = function(n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        };
        var rneedsContext = jQuery.expr.match.needsContext;

        function nodeName(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        };
        var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);

        function winnow(elements, qualifier, not) {
            if (isFunction(qualifier)) {
                return jQuery.grep(elements, function(elem, i) {
                    return !!qualifier.call(elem, i, elem) !== not;
                });
            }
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function(elem) {
                    return (elem === qualifier) !== not;
                });
            }
            if (typeof qualifier !== "string") {
                return jQuery.grep(elements, function(elem) {
                    return (indexOf.call(qualifier, elem) > -1) !== not;
                });
            }
            return jQuery.filter(qualifier, elements, not);
        }
        jQuery.filter = function(expr, elems, not) {
            var elem = elems[0];
            if (not) {
                expr = ":not(" + expr + ")";
            }
            if (elems.length === 1 && elem.nodeType === 1) {
                return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
            }
            return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                return elem.nodeType === 1;
            }));
        };
        jQuery.fn.extend({
            find: function(selector) {
                var i, ret, len = this.length,
                    self = this;
                if (typeof selector !== "string") {
                    return this.pushStack(jQuery(selector).filter(function() {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    }));
                }
                ret = this.pushStack([]);
                for (i = 0; i < len; i++) {
                    jQuery.find(selector, self[i], ret);
                }
                return len > 1 ? jQuery.uniqueSort(ret) : ret;
            },
            filter: function(selector) {
                return this.pushStack(winnow(this, selector || [], false));
            },
            not: function(selector) {
                return this.pushStack(winnow(this, selector || [], true));
            },
            is: function(selector) {
                return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
            init = jQuery.fn.init = function(selector, context, root) {
                var match, elem;
                if (!selector) {
                    return this;
                }
                root = root || rootjQuery;
                if (typeof selector === "string") {
                    if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }
                    if (match && (match[1] || !context)) {
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    if (isFunction(this[match])) {
                                        this[match](context[match]);
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            elem = document.getElementById(match[2]);
                            if (elem) {
                                this[0] = elem;
                                this.length = 1;
                            }
                            return this;
                        }
                    } else if (!context || context.jquery) {
                        return (context || root).find(selector);
                    } else {
                        return this.constructor(context).find(selector);
                    }
                } else if (selector.nodeType) {
                    this[0] = selector;
                    this.length = 1;
                    return this;
                } else if (isFunction(selector)) {
                    return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
                }
                return jQuery.makeArray(selector, this);
            };
        init.prototype = jQuery.fn;
        rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
        jQuery.fn.extend({
            has: function(target) {
                var targets = jQuery(target, this),
                    l = targets.length;
                return this.filter(function() {
                    var i = 0;
                    for (; i < l; i++) {
                        if (jQuery.contains(this, targets[i])) {
                            return true;
                        }
                    }
                });
            },
            closest: function(selectors, context) {
                var cur, i = 0,
                    l = this.length,
                    matched = [],
                    targets = typeof selectors !== "string" && jQuery(selectors);
                if (!rneedsContext.test(selectors)) {
                    for (; i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                                matched.push(cur);
                                break;
                            }
                        }
                    }
                }
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
            },
            index: function(elem) {
                if (!elem) {
                    return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                }
                if (typeof elem === "string") {
                    return indexOf.call(jQuery(elem), this[0]);
                }
                return indexOf.call(this, elem.jquery ? elem[0] : elem);
            },
            add: function(selector, context) {
                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
            },
            addBack: function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            }
        });

        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {}
            return cur;
        }
        jQuery.each({
            parent: function(elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function(elem) {
                return dir(elem, "parentNode");
            },
            parentsUntil: function(elem, i, until) {
                return dir(elem, "parentNode", until);
            },
            next: function(elem) {
                return sibling(elem, "nextSibling");
            },
            prev: function(elem) {
                return sibling(elem, "previousSibling");
            },
            nextAll: function(elem) {
                return dir(elem, "nextSibling");
            },
            prevAll: function(elem) {
                return dir(elem, "previousSibling");
            },
            nextUntil: function(elem, i, until) {
                return dir(elem, "nextSibling", until);
            },
            prevUntil: function(elem, i, until) {
                return dir(elem, "previousSibling", until);
            },
            siblings: function(elem) {
                return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function(elem) {
                return siblings(elem.firstChild);
            },
            contents: function(elem) {
                if (typeof elem.contentDocument !== "undefined") {
                    return elem.contentDocument;
                }
                if (nodeName(elem, "template")) {
                    elem = elem.content || elem;
                }
                return jQuery.merge([], elem.childNodes);
            }
        }, function(name, fn) {
            jQuery.fn[name] = function(until, selector) {
                var matched = jQuery.map(this, fn, until);
                if (name.slice(-5) !== "Until") {
                    selector = until;
                }
                if (selector && typeof selector === "string") {
                    matched = jQuery.filter(selector, matched);
                }
                if (this.length > 1) {
                    if (!guaranteedUnique[name]) {
                        jQuery.uniqueSort(matched);
                    }
                    if (rparentsprev.test(name)) {
                        matched.reverse();
                    }
                }
                return this.pushStack(matched);
            };
        });
        var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);

        function createOptions(options) {
            var object = {};
            jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                object[flag] = true;
            });
            return object;
        }
        jQuery.Callbacks = function(options) {
            options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
            var
                firing, memory, fired, locked, list = [],
                queue = [],
                firingIndex = -1,
                fire = function() {
                    locked = locked || options.once;
                    fired = firing = true;
                    for (; queue.length; firingIndex = -1) {
                        memory = queue.shift();
                        while (++firingIndex < list.length) {
                            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                                firingIndex = list.length;
                                memory = false;
                            }
                        }
                    }
                    if (!options.memory) {
                        memory = false;
                    }
                    firing = false;
                    if (locked) {
                        if (memory) {
                            list = [];
                        } else {
                            list = "";
                        }
                    }
                },
                self = {
                    add: function() {
                        if (list) {
                            if (memory && !firing) {
                                firingIndex = list.length - 1;
                                queue.push(memory);
                            }
                            (function add(args) {
                                jQuery.each(args, function(_, arg) {
                                    if (isFunction(arg)) {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && toType(arg) !== "string") {
                                        add(arg);
                                    }
                                });
                            })(arguments);
                            if (memory && !firing) {
                                fire();
                            }
                        }
                        return this;
                    },
                    remove: function() {
                        jQuery.each(arguments, function(_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        });
                        return this;
                    },
                    has: function(fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                    },
                    empty: function() {
                        if (list) {
                            list = [];
                        }
                        return this;
                    },
                    disable: function() {
                        locked = queue = [];
                        list = memory = "";
                        return this;
                    },
                    disabled: function() {
                        return !list;
                    },
                    lock: function() {
                        locked = queue = [];
                        if (!memory && !firing) {
                            list = memory = "";
                        }
                        return this;
                    },
                    locked: function() {
                        return !!locked;
                    },
                    fireWith: function(context, args) {
                        if (!locked) {
                            args = args || [];
                            args = [context, args.slice ? args.slice() : args];
                            queue.push(args);
                            if (!firing) {
                                fire();
                            }
                        }
                        return this;
                    },
                    fire: function() {
                        self.fireWith(this, arguments);
                        return this;
                    },
                    fired: function() {
                        return !!fired;
                    }
                };
            return self;
        };

        function Identity(v) {
            return v;
        }

        function Thrower(ex) {
            throw ex;
        }

        function adoptValue(value, resolve, reject, noValue) {
            var method;
            try {
                if (value && isFunction((method = value.promise))) {
                    method.call(value).done(resolve).fail(reject);
                } else if (value && isFunction((method = value.then))) {
                    method.call(value, resolve, reject);
                } else {
                    resolve.apply(undefined, [value].slice(noValue));
                }
            } catch (value) {
                reject.apply(undefined, [value]);
            }
        }
        jQuery.extend({
            Deferred: function(func) {
                var tuples = [
                        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2],
                        ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]
                    ],
                    state = "pending",
                    promise = {
                        state: function() {
                            return state;
                        },
                        always: function() {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        "catch": function(fn) {
                            return promise.then(null, fn);
                        },
                        pipe: function() {
                            var fns = arguments;
                            return jQuery.Deferred(function(newDefer) {
                                jQuery.each(tuples, function(i, tuple) {
                                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                    deferred[tuple[1]](function() {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && isFunction(returned.promise)) {
                                            returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                        } else {
                                            newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        then: function(onFulfilled, onRejected, onProgress) {
                            var maxDepth = 0;

                            function resolve(depth, deferred, handler, special) {
                                return function() {
                                    var that = this,
                                        args = arguments,
                                        mightThrow = function() {
                                            var returned, then;
                                            if (depth < maxDepth) {
                                                return;
                                            }
                                            returned = handler.apply(that, args);
                                            if (returned === deferred.promise()) {
                                                throw new TypeError("Thenable self-resolution");
                                            }
                                            then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                                            if (isFunction(then)) {
                                                if (special) {
                                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                                } else {
                                                    maxDepth++;
                                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                                }
                                            } else {
                                                if (handler !== Identity) {
                                                    that = undefined;
                                                    args = [returned];
                                                }
                                                (special || deferred.resolveWith)(that, args);
                                            }
                                        },
                                        process = special ? mightThrow : function() {
                                            try {
                                                mightThrow();
                                            } catch (e) {
                                                if (jQuery.Deferred.exceptionHook) {
                                                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                                }
                                                if (depth + 1 >= maxDepth) {
                                                    if (handler !== Thrower) {
                                                        that = undefined;
                                                        args = [e];
                                                    }
                                                    deferred.rejectWith(that, args);
                                                }
                                            }
                                        };
                                    if (depth) {
                                        process();
                                    } else {
                                        if (jQuery.Deferred.getStackHook) {
                                            process.stackTrace = jQuery.Deferred.getStackHook();
                                        }
                                        window.setTimeout(process);
                                    }
                                };
                            }
                            return jQuery.Deferred(function(newDefer) {
                                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                            }).promise();
                        },
                        promise: function(obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    },
                    deferred = {};
                jQuery.each(tuples, function(i, tuple) {
                    var list = tuple[2],
                        stateString = tuple[5];
                    promise[tuple[1]] = list.add;
                    if (stateString) {
                        list.add(function() {
                            state = stateString;
                        }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
                    }
                    list.add(tuple[3].fire);
                    deferred[tuple[0]] = function() {
                        deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                        return this;
                    };
                    deferred[tuple[0] + "With"] = list.fireWith;
                });
                promise.promise(deferred);
                if (func) {
                    func.call(deferred, deferred);
                }
                return deferred;
            },
            when: function(singleValue) {
                var
                    remaining = arguments.length,
                    i = remaining,
                    resolveContexts = Array(i),
                    resolveValues = slice.call(arguments),
                    master = jQuery.Deferred(),
                    updateFunc = function(i) {
                        return function(value) {
                            resolveContexts[i] = this;
                            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                            if (!(--remaining)) {
                                master.resolveWith(resolveContexts, resolveValues);
                            }
                        };
                    };
                if (remaining <= 1) {
                    adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
                    if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
                        return master.then();
                    }
                }
                while (i--) {
                    adoptValue(resolveValues[i], updateFunc(i), master.reject);
                }
                return master.promise();
            }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error, stack) {
            if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
                window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
            }
        };
        jQuery.readyException = function(error) {
            window.setTimeout(function() {
                throw error;
            });
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function(fn) {
            readyList.then(fn).catch(function(error) {
                jQuery.readyException(error);
            });
            return this;
        };
        jQuery.extend({
            isReady: false,
            readyWait: 1,
            ready: function(wait) {
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }
                jQuery.isReady = true;
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }
                readyList.resolveWith(document, [jQuery]);
            }
        });
        jQuery.ready.then = readyList.then;

        function completed() {
            document.removeEventListener("DOMContentLoaded", completed);
            window.removeEventListener("load", completed);
            jQuery.ready();
        }
        if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            window.setTimeout(jQuery.ready);
        } else {
            document.addEventListener("DOMContentLoaded", completed);
            window.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0,
                len = elems.length,
                bulk = key == null;
            if (toType(key) === "object") {
                chainable = true;
                for (i in key) {
                    access(elems, fn, i, key[i], true, emptyGet, raw);
                }
            } else if (value !== undefined) {
                chainable = true;
                if (!isFunction(value)) {
                    raw = true;
                }
                if (bulk) {
                    if (raw) {
                        fn.call(elems, value);
                        fn = null;
                    } else {
                        bulk = fn;
                        fn = function(elem, key, value) {
                            return bulk.call(jQuery(elem), value);
                        };
                    }
                }
                if (fn) {
                    for (; i < len; i++) {
                        fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                    }
                }
            }
            if (chainable) {
                return elems;
            }
            if (bulk) {
                return fn.call(elems);
            }
            return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/,
            rdashAlpha = /-([a-z])/g;

        function fcamelCase(all, letter) {
            return letter.toUpperCase();
        }

        function camelCase(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
            return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
        };

        function Data() {
            this.expando = jQuery.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
            cache: function(owner) {
                var value = owner[this.expando];
                if (!value) {
                    value = {};
                    if (acceptData(owner)) {
                        if (owner.nodeType) {
                            owner[this.expando] = value;
                        } else {
                            Object.defineProperty(owner, this.expando, {
                                value: value,
                                configurable: true
                            });
                        }
                    }
                }
                return value;
            },
            set: function(owner, data, value) {
                var prop, cache = this.cache(owner);
                if (typeof data === "string") {
                    cache[camelCase(data)] = value;
                } else {
                    for (prop in data) {
                        cache[camelCase(prop)] = data[prop];
                    }
                }
                return cache;
            },
            get: function(owner, key) {
                return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
            },
            access: function(owner, key, value) {
                if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
                    return this.get(owner, key);
                }
                this.set(owner, key, value);
                return value !== undefined ? value : key;
            },
            remove: function(owner, key) {
                var i, cache = owner[this.expando];
                if (cache === undefined) {
                    return;
                }
                if (key !== undefined) {
                    if (Array.isArray(key)) {
                        key = key.map(camelCase);
                    } else {
                        key = camelCase(key);
                        key = key in cache ? [key] : (key.match(rnothtmlwhite) || []);
                    }
                    i = key.length;
                    while (i--) {
                        delete cache[key[i]];
                    }
                }
                if (key === undefined || jQuery.isEmptyObject(cache)) {
                    if (owner.nodeType) {
                        owner[this.expando] = undefined;
                    } else {
                        delete owner[this.expando];
                    }
                }
            },
            hasData: function(owner) {
                var cache = owner[this.expando];
                return cache !== undefined && !jQuery.isEmptyObject(cache);
            }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /[A-Z]/g;

        function getData(data) {
            if (data === "true") {
                return true;
            }
            if (data === "false") {
                return false;
            }
            if (data === "null") {
                return null;
            }
            if (data === +data + "") {
                return +data;
            }
            if (rbrace.test(data)) {
                return JSON.parse(data);
            }
            return data;
        }

        function dataAttr(elem, key, data) {
            var name;
            if (data === undefined && elem.nodeType === 1) {
                name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                data = elem.getAttribute(name);
                if (typeof data === "string") {
                    try {
                        data = getData(data);
                    } catch (e) {}
                    dataUser.set(elem, key, data);
                } else {
                    data = undefined;
                }
            }
            return data;
        }
        jQuery.extend({
            hasData: function(elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem);
            },
            data: function(elem, name, data) {
                return dataUser.access(elem, name, data);
            },
            removeData: function(elem, name) {
                dataUser.remove(elem, name);
            },
            _data: function(elem, name, data) {
                return dataPriv.access(elem, name, data);
            },
            _removeData: function(elem, name) {
                dataPriv.remove(elem, name);
            }
        });
        jQuery.fn.extend({
            data: function(key, value) {
                var i, name, data, elem = this[0],
                    attrs = elem && elem.attributes;
                if (key === undefined) {
                    if (this.length) {
                        data = dataUser.get(elem);
                        if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                            i = attrs.length;
                            while (i--) {
                                if (attrs[i]) {
                                    name = attrs[i].name;
                                    if (name.indexOf("data-") === 0) {
                                        name = camelCase(name.slice(5));
                                        dataAttr(elem, name, data[name]);
                                    }
                                }
                            }
                            dataPriv.set(elem, "hasDataAttrs", true);
                        }
                    }
                    return data;
                }
                if (typeof key === "object") {
                    return this.each(function() {
                        dataUser.set(this, key);
                    });
                }
                return access(this, function(value) {
                    var data;
                    if (elem && value === undefined) {
                        data = dataUser.get(elem, key);
                        if (data !== undefined) {
                            return data;
                        }
                        data = dataAttr(elem, key);
                        if (data !== undefined) {
                            return data;
                        }
                        return;
                    }
                    this.each(function() {
                        dataUser.set(this, key, value);
                    });
                }, null, value, arguments.length > 1, null, true);
            },
            removeData: function(key) {
                return this.each(function() {
                    dataUser.remove(this, key);
                });
            }
        });
        jQuery.extend({
            queue: function(elem, type, data) {
                var queue;
                if (elem) {
                    type = (type || "fx") + "queue";
                    queue = dataPriv.get(elem, type);
                    if (data) {
                        if (!queue || Array.isArray(data)) {
                            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                        } else {
                            queue.push(data);
                        }
                    }
                    return queue || [];
                }
            },
            dequeue: function(elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks(elem, type),
                    next = function() {
                        jQuery.dequeue(elem, type);
                    };
                if (fn === "inprogress") {
                    fn = queue.shift();
                    startLength--;
                }
                if (fn) {
                    if (type === "fx") {
                        queue.unshift("inprogress");
                    }
                    delete hooks.stop;
                    fn.call(elem, next, hooks);
                }
                if (!startLength && hooks) {
                    hooks.empty.fire();
                }
            },
            _queueHooks: function(elem, type) {
                var key = type + "queueHooks";
                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function() {
                        dataPriv.remove(elem, [type + "queue", key]);
                    })
                });
            }
        });
        jQuery.fn.extend({
            queue: function(type, data) {
                var setter = 2;
                if (typeof type !== "string") {
                    data = type;
                    type = "fx";
                    setter--;
                }
                if (arguments.length < setter) {
                    return jQuery.queue(this[0], type);
                }
                return data === undefined ? this : this.each(function() {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type);
                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            dequeue: function(type) {
                return this.each(function() {
                    jQuery.dequeue(this, type);
                });
            },
            clearQueue: function(type) {
                return this.queue(type || "fx", []);
            },
            promise: function(type, obj) {
                var tmp, count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function() {
                        if (!(--count)) {
                            defer.resolveWith(elements, [elements]);
                        }
                    };
                if (typeof type !== "string") {
                    obj = type;
                    type = undefined;
                }
                type = type || "fx";
                while (i--) {
                    tmp = dataPriv.get(elements[i], type + "queueHooks");
                    if (tmp && tmp.empty) {
                        count++;
                        tmp.empty.add(resolve);
                    }
                }
                resolve();
                return defer.promise(obj);
            }
        });
        var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document.documentElement;
        var isAttached = function(elem) {
                return jQuery.contains(elem.ownerDocument, elem);
            },
            composed = {
                composed: true
            };
        if (documentElement.getRootNode) {
            isAttached = function(elem) {
                return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
            };
        }
        var isHiddenWithinTree = function(elem, el) {
            elem = el || elem;
            return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery.css(elem, "display") === "none";
        };
        var swap = function(elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }
            ret = callback.apply(elem, args || []);
            for (name in options) {
                elem.style[name] = old[name];
            }
            return ret;
        };

        function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale, maxIterations = 20,
                currentValue = tween ? function() {
                    return tween.cur();
                } : function() {
                    return jQuery.css(elem, prop, "");
                },
                initial = currentValue(),
                unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
                initial = initial / 2;
                unit = unit || initialInUnit[3];
                initialInUnit = +initial || 1;
                while (maxIterations--) {
                    jQuery.style(elem, prop, initialInUnit + unit);
                    if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                        maxIterations = 0;
                    }
                    initialInUnit = initialInUnit / scale;
                }
                initialInUnit = initialInUnit * 2;
                jQuery.style(elem, prop, initialInUnit + unit);
                valueParts = valueParts || [];
            }
            if (valueParts) {
                initialInUnit = +initialInUnit || +initial || 0;
                adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
                if (tween) {
                    tween.unit = unit;
                    tween.start = initialInUnit;
                    tween.end = adjusted;
                }
            }
            return adjusted;
        }
        var defaultDisplayMap = {};

        function getDefaultDisplay(elem) {
            var temp, doc = elem.ownerDocument,
                nodeName = elem.nodeName,
                display = defaultDisplayMap[nodeName];
            if (display) {
                return display;
            }
            temp = doc.body.appendChild(doc.createElement(nodeName));
            display = jQuery.css(temp, "display");
            temp.parentNode.removeChild(temp);
            if (display === "none") {
                display = "block";
            }
            defaultDisplayMap[nodeName] = display;
            return display;
        }

        function showHide(elements, show) {
            var display, elem, values = [],
                index = 0,
                length = elements.length;
            for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                display = elem.style.display;
                if (show) {
                    if (display === "none") {
                        values[index] = dataPriv.get(elem, "display") || null;
                        if (!values[index]) {
                            elem.style.display = "";
                        }
                    }
                    if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                        values[index] = getDefaultDisplay(elem);
                    }
                } else {
                    if (display !== "none") {
                        values[index] = "none";
                        dataPriv.set(elem, "display", display);
                    }
                }
            }
            for (index = 0; index < length; index++) {
                if (values[index] != null) {
                    elements[index].style.display = values[index];
                }
            }
            return elements;
        }
        jQuery.fn.extend({
            show: function() {
                return showHide(this, true);
            },
            hide: function() {
                return showHide(this);
            },
            toggle: function(state) {
                if (typeof state === "boolean") {
                    return state ? this.show() : this.hide();
                }
                return this.each(function() {
                    if (isHiddenWithinTree(this)) {
                        jQuery(this).show();
                    } else {
                        jQuery(this).hide();
                    }
                });
            }
        });
        var rcheckableType = (/^(?:checkbox|radio)$/i);
        var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]*)/i);
        var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);
        var wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;

        function getAll(context, tag) {
            var ret;
            if (typeof context.getElementsByTagName !== "undefined") {
                ret = context.getElementsByTagName(tag || "*");
            } else if (typeof context.querySelectorAll !== "undefined") {
                ret = context.querySelectorAll(tag || "*");
            } else {
                ret = [];
            }
            if (tag === undefined || tag && nodeName(context, tag)) {
                return jQuery.merge([context], ret);
            }
            return ret;
        }

        function setGlobalEval(elems, refElements) {
            var i = 0,
                l = elems.length;
            for (; i < l; i++) {
                dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
            }
        }
        var rhtml = /<|&#?\w+;/;

        function buildFragment(elems, context, scripts, selection, ignored) {
            var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (toType(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = "";
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while ((elem = nodes[i++])) {
                if (selection && jQuery.inArray(elem, selection) > -1) {
                    if (ignored) {
                        ignored.push(elem);
                    }
                    continue;
                }
                attached = isAttached(elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (attached) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while ((elem = tmp[j++])) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        }
        (function() {
            var fragment = document.createDocumentFragment(),
                div = fragment.appendChild(document.createElement("div")),
                input = document.createElement("input");
            input.setAttribute("type", "radio");
            input.setAttribute("checked", "checked");
            input.setAttribute("name", "t");
            div.appendChild(input);
            support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
            div.innerHTML = "<textarea>x</textarea>";
            support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        })();
        var
            rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

        function returnTrue() {
            return true;
        }

        function returnFalse() {
            return false;
        }

        function expectSync(elem, type) {
            return (elem === safeActiveElement()) === (type === "focus");
        }

        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch (err) {}
        }

        function on(elem, types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    on(elem, type, selector, data, types[type], one);
                }
                return elem;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return elem;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return elem.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        }
        jQuery.event = {
            global: {},
            add: function(elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                if (!elemData) {
                    return;
                }
                if (handler.handler) {
                    handleObjIn = handler;
                    handler = handleObjIn.handler;
                    selector = handleObjIn.selector;
                }
                if (selector) {
                    jQuery.find.matchesSelector(documentElement, selector);
                }
                if (!handler.guid) {
                    handler.guid = jQuery.guid++;
                }
                if (!(events = elemData.events)) {
                    events = elemData.events = {};
                }
                if (!(eventHandle = elemData.handle)) {
                    eventHandle = elemData.handle = function(e) {
                        return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                    };
                }
                types = (types || "").match(rnothtmlwhite) || [""];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || "").split(".").sort();
                    if (!type) {
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    special = jQuery.event.special[type] || {};
                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join(".")
                    }, handleObjIn);
                    if (!(handlers = events[type])) {
                        handlers = events[type] = [];
                        handlers.delegateCount = 0;
                        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                            if (elem.addEventListener) {
                                elem.addEventListener(type, eventHandle);
                            }
                        }
                    }
                    if (special.add) {
                        special.add.call(elem, handleObj);
                        if (!handleObj.handler.guid) {
                            handleObj.handler.guid = handler.guid;
                        }
                    }
                    if (selector) {
                        handlers.splice(handlers.delegateCount++, 0, handleObj);
                    } else {
                        handlers.push(handleObj);
                    }
                    jQuery.event.global[type] = true;
                }
            },
            remove: function(elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                if (!elemData || !(events = elemData.events)) {
                    return;
                }
                types = (types || "").match(rnothtmlwhite) || [""];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || "").split(".").sort();
                    if (!type) {
                        for (type in events) {
                            jQuery.event.remove(elem, type + types[t], handler, selector, true);
                        }
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    handlers = events[type] || [];
                    tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                    origCount = j = handlers.length;
                    while (j--) {
                        handleObj = handlers[j];
                        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                            handlers.splice(j, 1);
                            if (handleObj.selector) {
                                handlers.delegateCount--;
                            }
                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }
                    }
                    if (origCount && !handlers.length) {
                        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                            jQuery.removeEvent(elem, type, elemData.handle);
                        }
                        delete events[type];
                    }
                }
                if (jQuery.isEmptyObject(events)) {
                    dataPriv.remove(elem, "handle events");
                }
            },
            dispatch: function(nativeEvent) {
                var event = jQuery.event.fix(nativeEvent);
                var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length),
                    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                    special = jQuery.event.special[event.type] || {};
                args[0] = event;
                for (i = 1; i < arguments.length; i++) {
                    args[i] = arguments[i];
                }
                event.delegateTarget = this;
                if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                    return;
                }
                handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                i = 0;
                while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                    event.currentTarget = matched.elem;
                    j = 0;
                    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                        if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                            event.handleObj = handleObj;
                            event.data = handleObj.data;
                            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                            if (ret !== undefined) {
                                if ((event.result = ret) === false) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            }
                        }
                    }
                }
                if (special.postDispatch) {
                    special.postDispatch.call(this, event);
                }
                return event.result;
            },
            handlers: function(event, handlers) {
                var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;
                if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
                    for (; cur !== this; cur = cur.parentNode || this) {
                        if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                            matchedHandlers = [];
                            matchedSelectors = {};
                            for (i = 0; i < delegateCount; i++) {
                                handleObj = handlers[i];
                                sel = handleObj.selector + " ";
                                if (matchedSelectors[sel] === undefined) {
                                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                                }
                                if (matchedSelectors[sel]) {
                                    matchedHandlers.push(handleObj);
                                }
                            }
                            if (matchedHandlers.length) {
                                handlerQueue.push({
                                    elem: cur,
                                    handlers: matchedHandlers
                                });
                            }
                        }
                    }
                }
                cur = this;
                if (delegateCount < handlers.length) {
                    handlerQueue.push({
                        elem: cur,
                        handlers: handlers.slice(delegateCount)
                    });
                }
                return handlerQueue;
            },
            addProp: function(name, hook) {
                Object.defineProperty(jQuery.Event.prototype, name, {
                    enumerable: true,
                    configurable: true,
                    get: isFunction(hook) ? function() {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    } : function() {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },
                    set: function(value) {
                        Object.defineProperty(this, name, {
                            enumerable: true,
                            configurable: true,
                            writable: true,
                            value: value
                        });
                    }
                });
            },
            fix: function(originalEvent) {
                return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
            },
            special: {
                load: {
                    noBubble: true
                },
                click: {
                    setup: function(data) {
                        var el = this || data;
                        if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                            leverageNative(el, "click", returnTrue);
                        }
                        return false;
                    },
                    trigger: function(data) {
                        var el = this || data;
                        if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                            leverageNative(el, "click");
                        }
                        return true;
                    },
                    _default: function(event) {
                        var target = event.target;
                        return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                    }
                },
                beforeunload: {
                    postDispatch: function(event) {
                        if (event.result !== undefined && event.originalEvent) {
                            event.originalEvent.returnValue = event.result;
                        }
                    }
                }
            }
        };

        function leverageNative(el, type, expectSync) {
            if (!expectSync) {
                if (dataPriv.get(el, type) === undefined) {
                    jQuery.event.add(el, type, returnTrue);
                }
                return;
            }
            dataPriv.set(el, type, false);
            jQuery.event.add(el, type, {
                namespace: false,
                handler: function(event) {
                    var notAsync, result, saved = dataPriv.get(this, type);
                    if ((event.isTrigger & 1) && this[type]) {
                        if (!saved.length) {
                            saved = slice.call(arguments);
                            dataPriv.set(this, type, saved);
                            notAsync = expectSync(this, type);
                            this[type]();
                            result = dataPriv.get(this, type);
                            if (saved !== result || notAsync) {
                                dataPriv.set(this, type, false);
                            } else {
                                result = {};
                            }
                            if (saved !== result) {
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                return result.value;
                            }
                        } else if ((jQuery.event.special[type] || {}).delegateType) {
                            event.stopPropagation();
                        }
                    } else if (saved.length) {
                        dataPriv.set(this, type, {
                            value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                        });
                        event.stopImmediatePropagation();
                    }
                }
            });
        }
        jQuery.removeEvent = function(elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle);
            }
        };
        jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props);
            }
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
                this.target = (src.target && src.target.nodeType === 3) ? src.target.parentNode : src.target;
                this.currentTarget = src.currentTarget;
                this.relatedTarget = src.relatedTarget;
            } else {
                this.type = src;
            }
            if (props) {
                jQuery.extend(this, props);
            }
            this.timeStamp = src && src.timeStamp || Date.now();
            this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: false,
            preventDefault: function() {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue;
                if (e && !this.isSimulated) {
                    e.preventDefault();
                }
            },
            stopPropagation: function() {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue;
                if (e && !this.isSimulated) {
                    e.stopPropagation();
                }
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue;
                if (e && !this.isSimulated) {
                    e.stopImmediatePropagation();
                }
                this.stopPropagation();
            }
        };
        jQuery.each({
            altKey: true,
            bubbles: true,
            cancelable: true,
            changedTouches: true,
            ctrlKey: true,
            detail: true,
            eventPhase: true,
            metaKey: true,
            pageX: true,
            pageY: true,
            shiftKey: true,
            view: true,
            "char": true,
            code: true,
            charCode: true,
            key: true,
            keyCode: true,
            button: true,
            buttons: true,
            clientX: true,
            clientY: true,
            offsetX: true,
            offsetY: true,
            pointerId: true,
            pointerType: true,
            screenX: true,
            screenY: true,
            targetTouches: true,
            toElement: true,
            touches: true,
            which: function(event) {
                var button = event.button;
                if (event.which == null && rkeyEvent.test(event.type)) {
                    return event.charCode != null ? event.charCode : event.keyCode;
                }
                if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                    if (button & 1) {
                        return 1;
                    }
                    if (button & 2) {
                        return 3;
                    }
                    if (button & 4) {
                        return 2;
                    }
                    return 0;
                }
                return event.which;
            }
        }, jQuery.event.addProp);
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(type, delegateType) {
            jQuery.event.special[type] = {
                setup: function() {
                    leverageNative(this, type, expectSync);
                    return false;
                },
                trigger: function() {
                    leverageNative(this, type);
                    return true;
                },
                delegateType: delegateType
            };
        });
        jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function(event) {
                    var ret, target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;
                    if (!related || (related !== target && !jQuery.contains(target, related))) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply(this, arguments);
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });
        jQuery.fn.extend({
            on: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn);
            },
            one: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn, 1);
            },
            off: function(types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) {
                    handleObj = types.handleObj;
                    jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                    return this;
                }
                if (typeof types === "object") {
                    for (type in types) {
                        this.off(type, selector, types[type]);
                    }
                    return this;
                }
                if (selector === false || typeof selector === "function") {
                    fn = selector;
                    selector = undefined;
                }
                if (fn === false) {
                    fn = returnFalse;
                }
                return this.each(function() {
                    jQuery.event.remove(this, types, fn, selector);
                });
            }
        });
        var
            rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
            rnoInnerhtml = /<script|<style|<link/i,
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

        function manipulationTarget(elem, content) {
            if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
                return jQuery(elem).children("tbody")[0] || elem;
            }
            return elem;
        }

        function disableScript(elem) {
            elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
            return elem;
        }

        function restoreScript(elem) {
            if ((elem.type || "").slice(0, 5) === "true/") {
                elem.type = elem.type.slice(5);
            } else {
                elem.removeAttribute("type");
            }
            return elem;
        }

        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
                return;
            }
            if (dataPriv.hasData(src)) {
                pdataOld = dataPriv.access(src);
                pdataCur = dataPriv.set(dest, pdataOld);
                events = pdataOld.events;
                if (events) {
                    delete pdataCur.handle;
                    pdataCur.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }
            }
            if (dataUser.hasData(src)) {
                udataOld = dataUser.access(src);
                udataCur = jQuery.extend({}, udataOld);
                dataUser.set(dest, udataCur);
            }
        }

        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            if (nodeName === "input" && rcheckableType.test(src.type)) {
                dest.checked = src.checked;
            } else if (nodeName === "input" || nodeName === "textarea") {
                dest.defaultValue = src.defaultValue;
            }
        }

        function domManip(collection, args, callback, ignored) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0,
                l = collection.length,
                iNoClone = l - 1,
                value = args[0],
                valueIsFunction = isFunction(value);
            if (valueIsFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
                return collection.each(function(index) {
                    var self = collection.eq(index);
                    if (valueIsFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    domManip(self, args, callback, ignored);
                });
            }
            if (l) {
                fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first || ignored) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(collection[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src && (node.type || "").toLowerCase() !== "module") {
                                    if (jQuery._evalUrl && !node.noModule) {
                                        jQuery._evalUrl(node.src, {
                                            nonce: node.nonce || node.getAttribute("nonce")
                                        });
                                    }
                                } else {
                                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                                }
                            }
                        }
                    }
                }
            }
            return collection;
        }

        function remove(elem, selector, keepData) {
            var node, nodes = selector ? jQuery.filter(selector, elem) : elem,
                i = 0;
            for (;
                (node = nodes[i]) != null; i++) {
                if (!keepData && node.nodeType === 1) {
                    jQuery.cleanData(getAll(node));
                }
                if (node.parentNode) {
                    if (keepData && isAttached(node)) {
                        setGlobalEval(getAll(node, "script"));
                    }
                    node.parentNode.removeChild(node);
                }
            }
            return elem;
        }
        jQuery.extend({
            htmlPrefilter: function(html) {
                return html.replace(rxhtmlTag, "<$1></$2>");
            },
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(true),
                    inPage = isAttached(elem);
                if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                    destElements = getAll(clone);
                    srcElements = getAll(elem);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        fixInput(srcElements[i], destElements[i]);
                    }
                }
                if (dataAndEvents) {
                    if (deepDataAndEvents) {
                        srcElements = srcElements || getAll(elem);
                        destElements = destElements || getAll(clone);
                        for (i = 0, l = srcElements.length; i < l; i++) {
                            cloneCopyEvent(srcElements[i], destElements[i]);
                        }
                    } else {
                        cloneCopyEvent(elem, clone);
                    }
                }
                destElements = getAll(clone, "script");
                if (destElements.length > 0) {
                    setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                }
                return clone;
            },
            cleanData: function(elems) {
                var data, elem, type, special = jQuery.event.special,
                    i = 0;
                for (;
                    (elem = elems[i]) !== undefined; i++) {
                    if (acceptData(elem)) {
                        if ((data = elem[dataPriv.expando])) {
                            if (data.events) {
                                for (type in data.events) {
                                    if (special[type]) {
                                        jQuery.event.remove(elem, type);
                                    } else {
                                        jQuery.removeEvent(elem, type, data.handle);
                                    }
                                }
                            }
                            elem[dataPriv.expando] = undefined;
                        }
                        if (elem[dataUser.expando]) {
                            elem[dataUser.expando] = undefined;
                        }
                    }
                }
            }
        });
        jQuery.fn.extend({
            detach: function(selector) {
                return remove(this, selector, true);
            },
            remove: function(selector) {
                return remove(this, selector);
            },
            text: function(value) {
                return access(this, function(value) {
                    return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
                }, null, value, arguments.length);
            },
            append: function() {
                return domManip(this, arguments, function(elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem);
                    }
                });
            },
            prepend: function() {
                return domManip(this, arguments, function(elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild);
                    }
                });
            },
            before: function() {
                return domManip(this, arguments, function(elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this);
                    }
                });
            },
            after: function() {
                return domManip(this, arguments, function(elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this.nextSibling);
                    }
                });
            },
            empty: function() {
                var elem, i = 0;
                for (;
                    (elem = this[i]) != null; i++) {
                    if (elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem, false));
                        elem.textContent = "";
                    }
                }
                return this;
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                return this.map(function() {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
            },
            html: function(value) {
                return access(this, function(value) {
                    var elem = this[0] || {},
                        i = 0,
                        l = this.length;
                    if (value === undefined && elem.nodeType === 1) {
                        return elem.innerHTML;
                    }
                    if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                        value = jQuery.htmlPrefilter(value);
                        try {
                            for (; i < l; i++) {
                                elem = this[i] || {};
                                if (elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem, false));
                                    elem.innerHTML = value;
                                }
                            }
                            elem = 0;
                        } catch (e) {}
                    }
                    if (elem) {
                        this.empty().append(value);
                    }
                }, null, value, arguments.length);
            },
            replaceWith: function() {
                var ignored = [];
                return domManip(this, arguments, function(elem) {
                    var parent = this.parentNode;
                    if (jQuery.inArray(this, ignored) < 0) {
                        jQuery.cleanData(getAll(this));
                        if (parent) {
                            parent.replaceChild(elem, this);
                        }
                    }
                }, ignored);
            }
        });
        jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(name, original) {
            jQuery.fn[name] = function(selector) {
                var elems, ret = [],
                    insert = jQuery(selector),
                    last = insert.length - 1,
                    i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    push.apply(ret, elems.get());
                }
                return this.pushStack(ret);
            };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var getStyles = function(elem) {
            var view = elem.ownerDocument.defaultView;
            if (!view || !view.opener) {
                view = window;
            }
            return view.getComputedStyle(elem);
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
            function computeStyleTests() {
                if (!div) {
                    return;
                }
                container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
                    "margin-top:1px;padding:0;border:0";
                div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
                    "margin:auto;border:1px;padding:1px;" +
                    "width:60%;top:1%";
                documentElement.appendChild(container).appendChild(div);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = divStyle.top !== "1%";
                reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
                div.style.right = "60%";
                pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
                boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
                div.style.position = "absolute";
                scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
                documentElement.removeChild(container);
                div = null;
            }

            function roundPixelMeasures(measure) {
                return Math.round(parseFloat(measure));
            }
            var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"),
                div = document.createElement("div");
            if (!div.style) {
                return;
            }
            div.style.backgroundClip = "content-box";
            div.cloneNode(true).style.backgroundClip = "";
            support.clearCloneStyle = div.style.backgroundClip === "content-box";
            jQuery.extend(support, {
                boxSizingReliable: function() {
                    computeStyleTests();
                    return boxSizingReliableVal;
                },
                pixelBoxStyles: function() {
                    computeStyleTests();
                    return pixelBoxStylesVal;
                },
                pixelPosition: function() {
                    computeStyleTests();
                    return pixelPositionVal;
                },
                reliableMarginLeft: function() {
                    computeStyleTests();
                    return reliableMarginLeftVal;
                },
                scrollboxSize: function() {
                    computeStyleTests();
                    return scrollboxSizeVal;
                }
            });
        })();

        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            if (computed) {
                ret = computed.getPropertyValue(name) || computed[name];
                if (ret === "" && !isAttached(elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret !== undefined ? ret + "" : ret;
        }

        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function() {
                    if (conditionFn()) {
                        delete this.get;
                        return;
                    }
                    return (this.get = hookFn).apply(this, arguments);
                }
            };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"],
            emptyStyle = document.createElement("div").style,
            vendorProps = {};

        function vendorPropName(name) {
            var capName = name[0].toUpperCase() + name.slice(1),
                i = cssPrefixes.length;
            while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in emptyStyle) {
                    return name;
                }
            }
        }

        function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name];
            if (final) {
                return final;
            }
            if (name in emptyStyle) {
                return name;
            }
            return vendorProps[name] = vendorPropName(name) || name;
        }
        var
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rcustomProp = /^--/,
            cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            };

        function setPositiveNumber(elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
        }

        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
            var i = dimension === "width" ? 1 : 0,
                extra = 0,
                delta = 0;
            if (box === (isBorderBox ? "border" : "content")) {
                return 0;
            }
            for (; i < 4; i += 2) {
                if (box === "margin") {
                    delta += jQuery.css(elem, box + cssExpand[i], true, styles);
                }
                if (!isBorderBox) {
                    delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                    if (box !== "padding") {
                        delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                    } else {
                        extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                    }
                } else {
                    if (box === "content") {
                        delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                    }
                    if (box !== "margin") {
                        delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                    }
                }
            }
            if (!isBorderBox && computedVal >= 0) {
                delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                    computedVal -
                    delta -
                    extra -
                    0.5)) || 0;
            }
            return delta;
        }

        function getWidthOrHeight(elem, dimension, extra) {
            var styles = getStyles(elem),
                boxSizingNeeded = !support.boxSizingReliable() || extra,
                isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                valueIsBorderBox = isBorderBox,
                val = curCSS(elem, dimension, styles),
                offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
            if (rnumnonpx.test(val)) {
                if (!extra) {
                    return val;
                }
                val = "auto";
            }
            if ((!support.boxSizingReliable() && isBorderBox || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
                isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
                valueIsBorderBox = offsetProp in elem;
                if (valueIsBorderBox) {
                    val = elem[offsetProp];
                }
            }
            val = parseFloat(val) || 0;
            return (val +
                boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val)) + "px";
        }
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return ret === "" ? "1" : ret;
                        }
                    }
                }
            },
            cssNumber: {
                "animationIterationCount": true,
                "columnCount": true,
                "fillOpacity": true,
                "flexGrow": true,
                "flexShrink": true,
                "fontWeight": true,
                "gridArea": true,
                "gridColumn": true,
                "gridColumnEnd": true,
                "gridColumnStart": true,
                "gridRow": true,
                "gridRowEnd": true,
                "gridRowStart": true,
                "lineHeight": true,
                "opacity": true,
                "order": true,
                "orphans": true,
                "widows": true,
                "zIndex": true,
                "zoom": true
            },
            cssProps: {},
            style: function(elem, name, value, extra) {
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                    return;
                }
                var ret, type, hooks, origName = camelCase(name),
                    isCustomProp = rcustomProp.test(name),
                    style = elem.style;
                if (!isCustomProp) {
                    name = finalPropName(origName);
                }
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (value !== undefined) {
                    type = typeof value;
                    if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                        value = adjustCSS(elem, name, ret);
                        type = "number";
                    }
                    if (value == null || value !== value) {
                        return;
                    }
                    if (type === "number" && !isCustomProp) {
                        value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                    }
                    if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                        style[name] = "inherit";
                    }
                    if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                        if (isCustomProp) {
                            style.setProperty(name, value);
                        } else {
                            style[name] = value;
                        }
                    }
                } else {
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                        return ret;
                    }
                    return style[name];
                }
            },
            css: function(elem, name, extra, styles) {
                var val, num, hooks, origName = camelCase(name),
                    isCustomProp = rcustomProp.test(name);
                if (!isCustomProp) {
                    name = finalPropName(origName);
                }
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (hooks && "get" in hooks) {
                    val = hooks.get(elem, true, extra);
                }
                if (val === undefined) {
                    val = curCSS(elem, name, styles);
                }
                if (val === "normal" && name in cssNormalTransform) {
                    val = cssNormalTransform[name];
                }
                if (extra === "" || extra) {
                    num = parseFloat(val);
                    return extra === true || isFinite(num) ? num || 0 : val;
                }
                return val;
            }
        });
        jQuery.each(["height", "width"], function(i, dimension) {
            jQuery.cssHooks[dimension] = {
                get: function(elem, computed, extra) {
                    if (computed) {
                        return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                            return getWidthOrHeight(elem, dimension, extra);
                        }) : getWidthOrHeight(elem, dimension, extra);
                    }
                },
                set: function(elem, value, extra) {
                    var matches, styles = getStyles(elem),
                        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
                        boxSizingNeeded = scrollboxSizeBuggy || extra,
                        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                        subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                    if (isBorderBox && scrollboxSizeBuggy) {
                        subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                            parseFloat(styles[dimension]) -
                            boxModelAdjustment(elem, dimension, "border", false, styles) -
                            0.5);
                    }
                    if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                        elem.style[dimension] = value;
                        value = jQuery.css(elem, dimension);
                    }
                    return setPositiveNumber(elem, value, subtract);
                }
            };
        });
        jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
            if (computed) {
                return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left -
                    swap(elem, {
                        marginLeft: 0
                    }, function() {
                        return elem.getBoundingClientRect().left;
                    })) + "px";
            }
        });
        jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function(value) {
                    var i = 0,
                        expanded = {},
                        parts = typeof value === "string" ? value.split(" ") : [value];
                    for (; i < 4; i++) {
                        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    }
                    return expanded;
                }
            };
            if (prefix !== "margin") {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
        });
        jQuery.fn.extend({
            css: function(name, value) {
                return access(this, function(elem, name, value) {
                    var styles, len, map = {},
                        i = 0;
                    if (Array.isArray(name)) {
                        styles = getStyles(elem);
                        len = name.length;
                        for (; i < len; i++) {
                            map[name[i]] = jQuery.css(elem, name[i], false, styles);
                        }
                        return map;
                    }
                    return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                }, name, value, arguments.length > 1);
            }
        });

        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end, easing, unit) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || jQuery.easing._default;
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
            },
            cur: function() {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function(percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                if (this.options.duration) {
                    this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                } else {
                    this.pos = eased = percent;
                }
                this.now = (this.end - this.start) * eased + this.start;
                if (this.options.step) {
                    this.options.step.call(this.elem, this.now, this);
                }
                if (hooks && hooks.set) {
                    hooks.set(this);
                } else {
                    Tween.propHooks._default.set(this);
                }
                return this;
            }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
            _default: {
                get: function(tween) {
                    var result;
                    if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                        return tween.elem[tween.prop];
                    }
                    result = jQuery.css(tween.elem, tween.prop, "");
                    return !result || result === "auto" ? 0 : result;
                },
                set: function(tween) {
                    if (jQuery.fx.step[tween.prop]) {
                        jQuery.fx.step[tween.prop](tween);
                    } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                    } else {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
                if (tween.elem.nodeType && tween.elem.parentNode) {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        };
        jQuery.easing = {
            linear: function(p) {
                return p;
            },
            swing: function(p) {
                return 0.5 - Math.cos(p * Math.PI) / 2;
            },
            _default: "swing"
        };
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.step = {};
        var
            fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/,
            rrun = /queueHooks$/;

        function schedule() {
            if (inProgress) {
                if (document.hidden === false && window.requestAnimationFrame) {
                    window.requestAnimationFrame(schedule);
                } else {
                    window.setTimeout(schedule, jQuery.fx.interval);
                }
                jQuery.fx.tick();
            }
        }

        function createFxNow() {
            window.setTimeout(function() {
                fxNow = undefined;
            });
            return (fxNow = Date.now());
        }

        function genFx(type, includeWidth) {
            var which, i = 0,
                attrs = {
                    height: type
                };
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs["margin" + which] = attrs["padding" + which] = type;
            }
            if (includeWidth) {
                attrs.opacity = attrs.width = type;
            }
            return attrs;
        }

        function createTween(value, prop, animation) {
            var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
                index = 0,
                length = collection.length;
            for (; index < length; index++) {
                if ((tween = collection[index].call(animation, prop, value))) {
                    return tween;
                }
            }
        }

        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props,
                anim = this,
                orig = {},
                style = elem.style,
                hidden = elem.nodeType && isHiddenWithinTree(elem),
                dataShow = dataPriv.get(elem, "fxshow");
            if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, "fx");
                if (hooks.unqueued == null) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function() {
                        if (!hooks.unqueued) {
                            oldfire();
                        }
                    };
                }
                hooks.unqueued++;
                anim.always(function() {
                    anim.always(function() {
                        hooks.unqueued--;
                        if (!jQuery.queue(elem, "fx").length) {
                            hooks.empty.fire();
                        }
                    });
                });
            }
            for (prop in props) {
                value = props[prop];
                if (rfxtypes.test(value)) {
                    delete props[prop];
                    toggle = toggle || value === "toggle";
                    if (value === (hidden ? "hide" : "show")) {
                        if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                            hidden = true;
                        } else {
                            continue;
                        }
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                }
            }
            propTween = !jQuery.isEmptyObject(props);
            if (!propTween && jQuery.isEmptyObject(orig)) {
                return;
            }
            if (isBox && elem.nodeType === 1) {
                opts.overflow = [style.overflow, style.overflowX, style.overflowY];
                restoreDisplay = dataShow && dataShow.display;
                if (restoreDisplay == null) {
                    restoreDisplay = dataPriv.get(elem, "display");
                }
                display = jQuery.css(elem, "display");
                if (display === "none") {
                    if (restoreDisplay) {
                        display = restoreDisplay;
                    } else {
                        showHide([elem], true);
                        restoreDisplay = elem.style.display || restoreDisplay;
                        display = jQuery.css(elem, "display");
                        showHide([elem]);
                    }
                }
                if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                    if (jQuery.css(elem, "float") === "none") {
                        if (!propTween) {
                            anim.done(function() {
                                style.display = restoreDisplay;
                            });
                            if (restoreDisplay == null) {
                                display = style.display;
                                restoreDisplay = display === "none" ? "" : display;
                            }
                        }
                        style.display = "inline-block";
                    }
                }
            }
            if (opts.overflow) {
                style.overflow = "hidden";
                anim.always(function() {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
            propTween = false;
            for (prop in orig) {
                if (!propTween) {
                    if (dataShow) {
                        if ("hidden" in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = dataPriv.access(elem, "fxshow", {
                            display: restoreDisplay
                        });
                    }
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        showHide([elem], true);
                    }
                    anim.done(function() {
                        if (!hidden) {
                            showHide([elem]);
                        }
                        dataPriv.remove(elem, "fxshow");
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                }
                propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = propTween.start;
                    if (hidden) {
                        propTween.end = propTween.start;
                        propTween.start = 0;
                    }
                }
            }
        }

        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
                name = camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (Array.isArray(value)) {
                    easing = value[1];
                    value = props[index] = value[0];
                }
                if (index !== name) {
                    props[name] = value;
                    delete props[index];
                }
                hooks = jQuery.cssHooks[name];
                if (hooks && "expand" in hooks) {
                    value = hooks.expand(value);
                    delete props[name];
                    for (index in value) {
                        if (!(index in props)) {
                            props[index] = value[index];
                            specialEasing[index] = easing;
                        }
                    }
                } else {
                    specialEasing[name] = easing;
                }
            }
        }

        function Animation(elem, properties, options) {
            var result, stopped, index = 0,
                length = Animation.prefilters.length,
                deferred = jQuery.Deferred().always(function() {
                    delete tick.elem;
                }),
                tick = function() {
                    if (stopped) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(),
                        remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                        temp = remaining / animation.duration || 0,
                        percent = 1 - temp,
                        index = 0,
                        length = animation.tweens.length;
                    for (; index < length; index++) {
                        animation.tweens[index].run(percent);
                    }
                    deferred.notifyWith(elem, [animation, percent, remaining]);
                    if (percent < 1 && length) {
                        return remaining;
                    }
                    if (!length) {
                        deferred.notifyWith(elem, [animation, 1, 0]);
                    }
                    deferred.resolveWith(elem, [animation]);
                    return false;
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(true, {
                        specialEasing: {},
                        easing: jQuery.easing._default
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function(prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        animation.tweens.push(tween);
                        return tween;
                    },
                    stop: function(gotoEnd) {
                        var index = 0,
                            length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) {
                            return this;
                        }
                        stopped = true;
                        for (; index < length; index++) {
                            animation.tweens[index].run(1);
                        }
                        if (gotoEnd) {
                            deferred.notifyWith(elem, [animation, 1, 0]);
                            deferred.resolveWith(elem, [animation, gotoEnd]);
                        } else {
                            deferred.rejectWith(elem, [animation, gotoEnd]);
                        }
                        return this;
                    }
                }),
                props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
                result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                if (result) {
                    if (isFunction(result.stop)) {
                        jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                    }
                    return result;
                }
            }
            jQuery.map(props, createTween, animation);
            if (isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation);
            }
            animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            }));
            return animation;
        }
        jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
                "*": [function(prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
            },
            tweener: function(props, callback) {
                if (isFunction(props)) {
                    callback = props;
                    props = ["*"];
                } else {
                    props = props.match(rnothtmlwhite);
                }
                var prop, index = 0,
                    length = props.length;
                for (; index < length; index++) {
                    prop = props[index];
                    Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                    Animation.tweeners[prop].unshift(callback);
                }
            },
            prefilters: [defaultPrefilter],
            prefilter: function(callback, prepend) {
                if (prepend) {
                    Animation.prefilters.unshift(callback);
                } else {
                    Animation.prefilters.push(callback);
                }
            }
        });
        jQuery.speed = function(speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing || isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !isFunction(easing) && easing
            };
            if (jQuery.fx.off) {
                opt.duration = 0;
            } else {
                if (typeof opt.duration !== "number") {
                    if (opt.duration in jQuery.fx.speeds) {
                        opt.duration = jQuery.fx.speeds[opt.duration];
                    } else {
                        opt.duration = jQuery.fx.speeds._default;
                    }
                }
            }
            if (opt.queue == null || opt.queue === true) {
                opt.queue = "fx";
            }
            opt.old = opt.complete;
            opt.complete = function() {
                if (isFunction(opt.old)) {
                    opt.old.call(this);
                }
                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue);
                }
            };
            return opt;
        };
        jQuery.fn.extend({
            fadeTo: function(speed, to, easing, callback) {
                return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                    opacity: to
                }, speed, easing, callback);
            },
            animate: function(prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop),
                    optall = jQuery.speed(speed, easing, callback),
                    doAnimation = function() {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        if (empty || dataPriv.get(this, "finish")) {
                            anim.stop(true);
                        }
                    };
                doAnimation.finish = doAnimation;
                return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function(type, clearQueue, gotoEnd) {
                var stopQueue = function(hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop;
                    stop(gotoEnd);
                };
                if (typeof type !== "string") {
                    gotoEnd = clearQueue;
                    clearQueue = type;
                    type = undefined;
                }
                if (clearQueue && type !== false) {
                    this.queue(type || "fx", []);
                }
                return this.each(function() {
                    var dequeue = true,
                        index = type != null && type + "queueHooks",
                        timers = jQuery.timers,
                        data = dataPriv.get(this);
                    if (index) {
                        if (data[index] && data[index].stop) {
                            stopQueue(data[index]);
                        }
                    } else {
                        for (index in data) {
                            if (data[index] && data[index].stop && rrun.test(index)) {
                                stopQueue(data[index]);
                            }
                        }
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                            timers[index].anim.stop(gotoEnd);
                            dequeue = false;
                            timers.splice(index, 1);
                        }
                    }
                    if (dequeue || !gotoEnd) {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            finish: function(type) {
                if (type !== false) {
                    type = type || "fx";
                }
                return this.each(function() {
                    var index, data = dataPriv.get(this),
                        queue = data[type + "queue"],
                        hooks = data[type + "queueHooks"],
                        timers = jQuery.timers,
                        length = queue ? queue.length : 0;
                    data.finish = true;
                    jQuery.queue(this, type, []);
                    if (hooks && hooks.stop) {
                        hooks.stop.call(this, true);
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && timers[index].queue === type) {
                            timers[index].anim.stop(true);
                            timers.splice(index, 1);
                        }
                    }
                    for (index = 0; index < length; index++) {
                        if (queue[index] && queue[index].finish) {
                            queue[index].finish.call(this);
                        }
                    }
                    delete data.finish;
                });
            }
        });
        jQuery.each(["toggle", "show", "hide"], function(i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function(speed, easing, callback) {
                return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
        });
        jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function(name, props) {
            jQuery.fn[name] = function(speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        });
        jQuery.timers = [];
        jQuery.fx.tick = function() {
            var timer, i = 0,
                timers = jQuery.timers;
            fxNow = Date.now();
            for (; i < timers.length; i++) {
                timer = timers[i];
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1);
                }
            }
            if (!timers.length) {
                jQuery.fx.stop();
            }
            fxNow = undefined;
        };
        jQuery.fx.timer = function(timer) {
            jQuery.timers.push(timer);
            jQuery.fx.start();
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function() {
            if (inProgress) {
                return;
            }
            inProgress = true;
            schedule();
        };
        jQuery.fx.stop = function() {
            inProgress = null;
        };
        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        };
        jQuery.fn.delay = function(time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";
            return this.queue(type, function(next, hooks) {
                var timeout = window.setTimeout(next, time);
                hooks.stop = function() {
                    window.clearTimeout(timeout);
                };
            });
        };
        (function() {
            var input = document.createElement("input"),
                select = document.createElement("select"),
                opt = select.appendChild(document.createElement("option"));
            input.type = "checkbox";
            support.checkOn = input.value !== "";
            support.optSelected = opt.selected;
            input = document.createElement("input");
            input.value = "t";
            input.type = "radio";
            support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function(name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function(name) {
                return this.each(function() {
                    jQuery.removeAttr(this, name);
                });
            }
        });
        jQuery.extend({
            attr: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                if (typeof elem.getAttribute === "undefined") {
                    return jQuery.prop(elem, name, value);
                }
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                }
                if (value !== undefined) {
                    if (value === null) {
                        jQuery.removeAttr(elem, name);
                        return;
                    }
                    if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    }
                    elem.setAttribute(name, value + "");
                    return value;
                }
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                }
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            },
            attrHooks: {
                type: {
                    set: function(elem, value) {
                        if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                            var val = elem.value;
                            elem.setAttribute("type", value);
                            if (val) {
                                elem.value = val;
                            }
                            return value;
                        }
                    }
                }
            },
            removeAttr: function(elem, value) {
                var name, i = 0,
                    attrNames = value && value.match(rnothtmlwhite);
                if (attrNames && elem.nodeType === 1) {
                    while ((name = attrNames[i++])) {
                        elem.removeAttribute(name);
                    }
                }
            }
        });
        boolHook = {
            set: function(elem, value, name) {
                if (value === false) {
                    jQuery.removeAttr(elem, name);
                } else {
                    elem.setAttribute(name, name);
                }
                return name;
            }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function(elem, name, isXML) {
                var ret, handle, lowercaseName = name.toLowerCase();
                if (!isXML) {
                    handle = attrHandle[lowercaseName];
                    attrHandle[lowercaseName] = ret;
                    ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                    attrHandle[lowercaseName] = handle;
                }
                return ret;
            };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i,
            rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
            prop: function(name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function(name) {
                return this.each(function() {
                    delete this[jQuery.propFix[name] || name];
                });
            }
        });
        jQuery.extend({
            prop: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    name = jQuery.propFix[name] || name;
                    hooks = jQuery.propHooks[name];
                }
                if (value !== undefined) {
                    if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    }
                    return (elem[name] = value);
                }
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                }
                return elem[name];
            },
            propHooks: {
                tabIndex: {
                    get: function(elem) {
                        var tabindex = jQuery.find.attr(elem, "tabindex");
                        if (tabindex) {
                            return parseInt(tabindex, 10);
                        }
                        if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                            return 0;
                        }
                        return -1;
                    }
                }
            },
            propFix: {
                "for": "htmlFor",
                "class": "className"
            }
        });
        if (!support.optSelected) {
            jQuery.propHooks.selected = {
                get: function(elem) {
                    var parent = elem.parentNode;
                    if (parent && parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                    return null;
                },
                set: function(elem) {
                    var parent = elem.parentNode;
                    if (parent) {
                        parent.selectedIndex;
                        if (parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                    }
                }
            };
        }
        jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            jQuery.propFix[this.toLowerCase()] = this;
        });

        function stripAndCollapse(value) {
            var tokens = value.match(rnothtmlwhite) || [];
            return tokens.join(" ");
        }

        function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || "";
        }

        function classesToArray(value) {
            if (Array.isArray(value)) {
                return value;
            }
            if (typeof value === "string") {
                return value.match(rnothtmlwhite) || [];
            }
            return [];
        }
        jQuery.fn.extend({
            addClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) {
                    return this.each(function(j) {
                        jQuery(this).addClass(value.call(this, j, getClass(this)));
                    });
                }
                classes = classesToArray(value);
                if (classes.length) {
                    while ((elem = this[i++])) {
                        curValue = getClass(elem);
                        cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
                        if (cur) {
                            j = 0;
                            while ((clazz = classes[j++])) {
                                if (cur.indexOf(" " + clazz + " ") < 0) {
                                    cur += clazz + " ";
                                }
                            }
                            finalValue = stripAndCollapse(cur);
                            if (curValue !== finalValue) {
                                elem.setAttribute("class", finalValue);
                            }
                        }
                    }
                }
                return this;
            },
            removeClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) {
                    return this.each(function(j) {
                        jQuery(this).removeClass(value.call(this, j, getClass(this)));
                    });
                }
                if (!arguments.length) {
                    return this.attr("class", "");
                }
                classes = classesToArray(value);
                if (classes.length) {
                    while ((elem = this[i++])) {
                        curValue = getClass(elem);
                        cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
                        if (cur) {
                            j = 0;
                            while ((clazz = classes[j++])) {
                                while (cur.indexOf(" " + clazz + " ") > -1) {
                                    cur = cur.replace(" " + clazz + " ", " ");
                                }
                            }
                            finalValue = stripAndCollapse(cur);
                            if (curValue !== finalValue) {
                                elem.setAttribute("class", finalValue);
                            }
                        }
                    }
                }
                return this;
            },
            toggleClass: function(value, stateVal) {
                var type = typeof value,
                    isValidValue = type === "string" || Array.isArray(value);
                if (typeof stateVal === "boolean" && isValidValue) {
                    return stateVal ? this.addClass(value) : this.removeClass(value);
                }
                if (isFunction(value)) {
                    return this.each(function(i) {
                        jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                    });
                }
                return this.each(function() {
                    var className, i, self, classNames;
                    if (isValidValue) {
                        i = 0;
                        self = jQuery(this);
                        classNames = classesToArray(value);
                        while ((className = classNames[i++])) {
                            if (self.hasClass(className)) {
                                self.removeClass(className);
                            } else {
                                self.addClass(className);
                            }
                        }
                    } else if (value === undefined || type === "boolean") {
                        className = getClass(this);
                        if (className) {
                            dataPriv.set(this, "__className__", className);
                        }
                        if (this.setAttribute) {
                            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                        }
                    }
                });
            },
            hasClass: function(selector) {
                var className, elem, i = 0;
                className = " " + selector + " ";
                while ((elem = this[i++])) {
                    if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                        return true;
                    }
                }
                return false;
            }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
            val: function(value) {
                var hooks, ret, valueIsFunction, elem = this[0];
                if (!arguments.length) {
                    if (elem) {
                        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                            return ret;
                        }
                        ret = elem.value;
                        if (typeof ret === "string") {
                            return ret.replace(rreturn, "");
                        }
                        return ret == null ? "" : ret;
                    }
                    return;
                }
                valueIsFunction = isFunction(value);
                return this.each(function(i) {
                    var val;
                    if (this.nodeType !== 1) {
                        return;
                    }
                    if (valueIsFunction) {
                        val = value.call(this, i, jQuery(this).val());
                    } else {
                        val = value;
                    }
                    if (val == null) {
                        val = "";
                    } else if (typeof val === "number") {
                        val += "";
                    } else if (Array.isArray(val)) {
                        val = jQuery.map(val, function(value) {
                            return value == null ? "" : value + "";
                        });
                    }
                    hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                    if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                        this.value = val;
                    }
                });
            }
        });
        jQuery.extend({
            valHooks: {
                option: {
                    get: function(elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return val != null ? val : stripAndCollapse(jQuery.text(elem));
                    }
                },
                select: {
                    get: function(elem) {
                        var value, option, i, options = elem.options,
                            index = elem.selectedIndex,
                            one = elem.type === "select-one",
                            values = one ? null : [],
                            max = one ? index + 1 : options.length;
                        if (index < 0) {
                            i = max;
                        } else {
                            i = one ? index : 0;
                        }
                        for (; i < max; i++) {
                            option = options[i];
                            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                                value = jQuery(option).val();
                                if (one) {
                                    return value;
                                }
                                values.push(value);
                            }
                        }
                        return values;
                    },
                    set: function(elem, value) {
                        var optionSet, option, options = elem.options,
                            values = jQuery.makeArray(value),
                            i = options.length;
                        while (i--) {
                            option = options[i];
                            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                                optionSet = true;
                            }
                        }
                        if (!optionSet) {
                            elem.selectedIndex = -1;
                        }
                        return values;
                    }
                }
            }
        });
        jQuery.each(["radio", "checkbox"], function() {
            jQuery.valHooks[this] = {
                set: function(elem, value) {
                    if (Array.isArray(value)) {
                        return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                    }
                }
            };
            if (!support.checkOn) {
                jQuery.valHooks[this].get = function(elem) {
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                };
            }
        });
        support.focusin = "onfocusin" in window;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            stopPropagationCallback = function(e) {
                e.stopPropagation();
            };
        jQuery.extend(jQuery.event, {
            trigger: function(event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document],
                    type = hasOwn.call(event, "type") ? event.type : event,
                    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                cur = lastElement = tmp = elem = elem || document;
                if (elem.nodeType === 3 || elem.nodeType === 8) {
                    return;
                }
                if (rfocusMorph.test(type + jQuery.event.triggered)) {
                    return;
                }
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    namespaces.sort();
                }
                ontype = type.indexOf(":") < 0 && "on" + type;
                event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join(".");
                event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                event.result = undefined;
                if (!event.target) {
                    event.target = elem;
                }
                data = data == null ? [event] : jQuery.makeArray(data, [event]);
                special = jQuery.event.special[type] || {};
                if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                    return;
                }
                if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                    bubbleType = special.delegateType || type;
                    if (!rfocusMorph.test(bubbleType + type)) {
                        cur = cur.parentNode;
                    }
                    for (; cur; cur = cur.parentNode) {
                        eventPath.push(cur);
                        tmp = cur;
                    }
                    if (tmp === (elem.ownerDocument || document)) {
                        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                    }
                }
                i = 0;
                while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                    lastElement = cur;
                    event.type = i > 1 ? bubbleType : special.bindType || type;
                    handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                    if (handle) {
                        handle.apply(cur, data);
                    }
                    handle = ontype && cur[ontype];
                    if (handle && handle.apply && acceptData(cur)) {
                        event.result = handle.apply(cur, data);
                        if (event.result === false) {
                            event.preventDefault();
                        }
                    }
                }
                event.type = type;
                if (!onlyHandlers && !event.isDefaultPrevented()) {
                    if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                        if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                            tmp = elem[ontype];
                            if (tmp) {
                                elem[ontype] = null;
                            }
                            jQuery.event.triggered = type;
                            if (event.isPropagationStopped()) {
                                lastElement.addEventListener(type, stopPropagationCallback);
                            }
                            elem[type]();
                            if (event.isPropagationStopped()) {
                                lastElement.removeEventListener(type, stopPropagationCallback);
                            }
                            jQuery.event.triggered = undefined;
                            if (tmp) {
                                elem[ontype] = tmp;
                            }
                        }
                    }
                }
                return event.result;
            },
            simulate: function(type, elem, event) {
                var e = jQuery.extend(new jQuery.Event(), event, {
                    type: type,
                    isSimulated: true
                });
                jQuery.event.trigger(e, null, elem);
            }
        });
        jQuery.fn.extend({
            trigger: function(type, data) {
                return this.each(function() {
                    jQuery.event.trigger(type, data, this);
                });
            },
            triggerHandler: function(type, data) {
                var elem = this[0];
                if (elem) {
                    return jQuery.event.trigger(type, data, elem, true);
                }
            }
        });
        if (!support.focusin) {
            jQuery.each({
                focus: "focusin",
                blur: "focusout"
            }, function(orig, fix) {
                var handler = function(event) {
                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
                };
                jQuery.event.special[fix] = {
                    setup: function() {
                        var doc = this.ownerDocument || this,
                            attaches = dataPriv.access(doc, fix);
                        if (!attaches) {
                            doc.addEventListener(orig, handler, true);
                        }
                        dataPriv.access(doc, fix, (attaches || 0) + 1);
                    },
                    teardown: function() {
                        var doc = this.ownerDocument || this,
                            attaches = dataPriv.access(doc, fix) - 1;
                        if (!attaches) {
                            doc.removeEventListener(orig, handler, true);
                            dataPriv.remove(doc, fix);
                        } else {
                            dataPriv.access(doc, fix, attaches);
                        }
                    }
                };
            });
        }
        var location = window.location;
        var nonce = Date.now();
        var rquery = (/\?/);
        jQuery.parseXML = function(data) {
            var xml;
            if (!data || typeof data !== "string") {
                return null;
            }
            try {
                xml = (new window.DOMParser()).parseFromString(data, "text/xml");
            } catch (e) {
                xml = undefined;
            }
            if (!xml || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data);
            }
            return xml;
        };
        var
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;

        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (Array.isArray(obj)) {
                jQuery.each(obj, function(i, v) {
                    if (traditional || rbracket.test(prefix)) {
                        add(prefix, v);
                    } else {
                        buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                    }
                });
            } else if (!traditional && toType(obj) === "object") {
                for (name in obj) {
                    buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                }
            } else {
                add(prefix, obj);
            }
        }
        jQuery.param = function(a, traditional) {
            var prefix, s = [],
                add = function(key, valueOrFunction) {
                    var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                    s[s.length] = encodeURIComponent(key) + "=" +
                        encodeURIComponent(value == null ? "" : value);
                };
            if (a == null) {
                return "";
            }
            if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                jQuery.each(a, function() {
                    add(this.name, this.value);
                });
            } else {
                for (prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }
            return s.join("&");
        };
        jQuery.fn.extend({
            serialize: function() {
                return jQuery.param(this.serializeArray());
            },
            serializeArray: function() {
                return this.map(function() {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this;
                }).filter(function() {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                }).map(function(i, elem) {
                    var val = jQuery(this).val();
                    if (val == null) {
                        return null;
                    }
                    if (Array.isArray(val)) {
                        return jQuery.map(val, function(val) {
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            };
                        });
                    }
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }).get();
            }
        });
        var
            r20 = /%20/g,
            rhash = /#.*$/,
            rantiCache = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
            rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            prefilters = {},
            transports = {},
            allTypes = "*/".concat("*"),
            originAnchor = document.createElement("a");
        originAnchor.href = location.href;

        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                if (typeof dataTypeExpression !== "string") {
                    func = dataTypeExpression;
                    dataTypeExpression = "*";
                }
                var dataType, i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
                if (isFunction(func)) {
                    while ((dataType = dataTypes[i++])) {
                        if (dataType[0] === "+") {
                            dataType = dataType.slice(1) || "*";
                            (structure[dataType] = structure[dataType] || []).unshift(func);
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    }
                }
            };
        }

        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {},
                seekingTransport = (structure === transports);

            function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                        options.dataTypes.unshift(dataTypeOrTransport);
                        inspect(dataTypeOrTransport);
                        return false;
                    } else if (seekingTransport) {
                        return !(selected = dataTypeOrTransport);
                    }
                });
                return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }

        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
                if (src[key] !== undefined) {
                    (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                }
            }
            if (deep) {
                jQuery.extend(true, target, deep);
            }
            return target;
        }

        function ajaxHandleResponses(s, jqXHR, responses) {
            var ct, type, finalDataType, firstDataType, contents = s.contents,
                dataTypes = s.dataTypes;
            while (dataTypes[0] === "*") {
                dataTypes.shift();
                if (ct === undefined) {
                    ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                }
            }
            if (ct) {
                for (type in contents) {
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break;
                    }
                }
            }
            if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0];
            } else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                        finalDataType = type;
                        break;
                    }
                    if (!firstDataType) {
                        firstDataType = type;
                    }
                }
                finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                    dataTypes.unshift(finalDataType);
                }
                return responses[finalDataType];
            }
        }

        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {},
                dataTypes = s.dataTypes.slice();
            if (dataTypes[1]) {
                for (conv in s.converters) {
                    converters[conv.toLowerCase()] = s.converters[conv];
                }
            }
            current = dataTypes.shift();
            while (current) {
                if (s.responseFields[current]) {
                    jqXHR[s.responseFields[current]] = response;
                }
                if (!prev && isSuccess && s.dataFilter) {
                    response = s.dataFilter(response, s.dataType);
                }
                prev = current;
                current = dataTypes.shift();
                if (current) {
                    if (current === "*") {
                        current = prev;
                    } else if (prev !== "*" && prev !== current) {
                        conv = converters[prev + " " + current] || converters["* " + current];
                        if (!conv) {
                            for (conv2 in converters) {
                                tmp = conv2.split(" ");
                                if (tmp[1] === current) {
                                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                    if (conv) {
                                        if (conv === true) {
                                            conv = converters[conv2];
                                        } else if (converters[conv2] !== true) {
                                            current = tmp[0];
                                            dataTypes.unshift(tmp[1]);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        if (conv !== true) {
                            if (conv && s.throws) {
                                response = conv(response);
                            } else {
                                try {
                                    response = conv(response);
                                } catch (e) {
                                    return {
                                        state: "parsererror",
                                        error: conv ? e : "No conversion from " + prev + " to " + current
                                    };
                                }
                            }
                        }
                    }
                }
            }
            return {
                state: "success",
                data: response
            };
        }
        jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: location.href,
                type: "GET",
                isLocal: rlocalProtocol.test(location.protocol),
                global: true,
                processData: true,
                async: true,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": true,
                    "text json": JSON.parse,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: true,
                    context: true
                }
            },
            ajaxSetup: function(target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function(url, options) {
                if (typeof url === "object") {
                    options = url;
                    url = undefined;
                }
                options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function(key) {
                            var match;
                            if (completed) {
                                if (!responseHeaders) {
                                    responseHeaders = {};
                                    while ((match = rheaders.exec(responseHeadersString))) {
                                        responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                                    }
                                }
                                match = responseHeaders[key.toLowerCase() + " "];
                            }
                            return match == null ? null : match.join(", ");
                        },
                        getAllResponseHeaders: function() {
                            return completed ? responseHeadersString : null;
                        },
                        setRequestHeader: function(name, value) {
                            if (completed == null) {
                                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                                requestHeaders[name] = value;
                            }
                            return this;
                        },
                        overrideMimeType: function(type) {
                            if (completed == null) {
                                s.mimeType = type;
                            }
                            return this;
                        },
                        statusCode: function(map) {
                            var code;
                            if (map) {
                                if (completed) {
                                    jqXHR.always(map[jqXHR.status]);
                                } else {
                                    for (code in map) {
                                        statusCode[code] = [statusCode[code], map[code]];
                                    }
                                }
                            }
                            return this;
                        },
                        abort: function(statusText) {
                            var finalText = statusText || strAbort;
                            if (transport) {
                                transport.abort(finalText);
                            }
                            done(0, finalText);
                            return this;
                        }
                    };
                deferred.promise(jqXHR);
                s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
                s.type = options.method || options.type || s.method || s.type;
                s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
                if (s.crossDomain == null) {
                    urlAnchor = document.createElement("a");
                    try {
                        urlAnchor.href = s.url;
                        urlAnchor.href = urlAnchor.href;
                        s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                    } catch (e) {
                        s.crossDomain = true;
                    }
                }
                if (s.data && s.processData && typeof s.data !== "string") {
                    s.data = jQuery.param(s.data, s.traditional);
                }
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                if (completed) {
                    return jqXHR;
                }
                fireGlobals = jQuery.event && s.global;
                if (fireGlobals && jQuery.active++ === 0) {
                    jQuery.event.trigger("ajaxStart");
                }
                s.type = s.type.toUpperCase();
                s.hasContent = !rnoContent.test(s.type);
                cacheURL = s.url.replace(rhash, "");
                if (!s.hasContent) {
                    uncached = s.url.slice(cacheURL.length);
                    if (s.data && (s.processData || typeof s.data === "string")) {
                        cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                        delete s.data;
                    }
                    if (s.cache === false) {
                        cacheURL = cacheURL.replace(rantiCache, "$1");
                        uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
                    }
                    s.url = cacheURL + uncached;
                } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                    s.data = s.data.replace(r20, "+");
                }
                if (s.ifModified) {
                    if (jQuery.lastModified[cacheURL]) {
                        jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                    }
                    if (jQuery.etag[cacheURL]) {
                        jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                    }
                }
                if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                    jqXHR.setRequestHeader("Content-Type", s.contentType);
                }
                jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] +
                    (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                for (i in s.headers) {
                    jqXHR.setRequestHeader(i, s.headers[i]);
                }
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
                    return jqXHR.abort();
                }
                strAbort = "abort";
                completeDeferred.add(s.complete);
                jqXHR.done(s.success);
                jqXHR.fail(s.error);
                transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                if (!transport) {
                    done(-1, "No Transport");
                } else {
                    jqXHR.readyState = 1;
                    if (fireGlobals) {
                        globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                    }
                    if (completed) {
                        return jqXHR;
                    }
                    if (s.async && s.timeout > 0) {
                        timeoutTimer = window.setTimeout(function() {
                            jqXHR.abort("timeout");
                        }, s.timeout);
                    }
                    try {
                        completed = false;
                        transport.send(requestHeaders, done);
                    } catch (e) {
                        if (completed) {
                            throw e;
                        }
                        done(-1, e);
                    }
                }

                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    if (completed) {
                        return;
                    }
                    completed = true;
                    if (timeoutTimer) {
                        window.clearTimeout(timeoutTimer);
                    }
                    transport = undefined;
                    responseHeadersString = headers || "";
                    jqXHR.readyState = status > 0 ? 4 : 0;
                    isSuccess = status >= 200 && status < 300 || status === 304;
                    if (responses) {
                        response = ajaxHandleResponses(s, jqXHR, responses);
                    }
                    response = ajaxConvert(s, response, jqXHR, isSuccess);
                    if (isSuccess) {
                        if (s.ifModified) {
                            modified = jqXHR.getResponseHeader("Last-Modified");
                            if (modified) {
                                jQuery.lastModified[cacheURL] = modified;
                            }
                            modified = jqXHR.getResponseHeader("etag");
                            if (modified) {
                                jQuery.etag[cacheURL] = modified;
                            }
                        }
                        if (status === 204 || s.type === "HEAD") {
                            statusText = "nocontent";
                        } else if (status === 304) {
                            statusText = "notmodified";
                        } else {
                            statusText = response.state;
                            success = response.data;
                            error = response.error;
                            isSuccess = !error;
                        }
                    } else {
                        error = statusText;
                        if (status || !statusText) {
                            statusText = "error";
                            if (status < 0) {
                                status = 0;
                            }
                        }
                    }
                    jqXHR.status = status;
                    jqXHR.statusText = (nativeStatusText || statusText) + "";
                    if (isSuccess) {
                        deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                    } else {
                        deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                    }
                    jqXHR.statusCode(statusCode);
                    statusCode = undefined;
                    if (fireGlobals) {
                        globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                    }
                    completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                    if (fireGlobals) {
                        globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                        if (!(--jQuery.active)) {
                            jQuery.event.trigger("ajaxStop");
                        }
                    }
                }
                return jqXHR;
            },
            getJSON: function(url, data, callback) {
                return jQuery.get(url, data, callback, "json");
            },
            getScript: function(url, callback) {
                return jQuery.get(url, undefined, callback, "script");
            }
        });
        jQuery.each(["get", "post"], function(i, method) {
            jQuery[method] = function(url, data, callback, type) {
                if (isFunction(data)) {
                    type = type || callback;
                    callback = data;
                    data = undefined;
                }
                return jQuery.ajax(jQuery.extend({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                }, jQuery.isPlainObject(url) && url));
            };
        });
        jQuery._evalUrl = function(url, options) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                cache: true,
                async: false,
                global: false,
                converters: {
                    "text script": function() {}
                },
                dataFilter: function(response) {
                    jQuery.globalEval(response, options);
                }
            });
        };
        jQuery.fn.extend({
            wrapAll: function(html) {
                var wrap;
                if (this[0]) {
                    if (isFunction(html)) {
                        html = html.call(this[0]);
                    }
                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                    if (this[0].parentNode) {
                        wrap.insertBefore(this[0]);
                    }
                    wrap.map(function() {
                        var elem = this;
                        while (elem.firstElementChild) {
                            elem = elem.firstElementChild;
                        }
                        return elem;
                    }).append(this);
                }
                return this;
            },
            wrapInner: function(html) {
                if (isFunction(html)) {
                    return this.each(function(i) {
                        jQuery(this).wrapInner(html.call(this, i));
                    });
                }
                return this.each(function() {
                    var self = jQuery(this),
                        contents = self.contents();
                    if (contents.length) {
                        contents.wrapAll(html);
                    } else {
                        self.append(html);
                    }
                });
            },
            wrap: function(html) {
                var htmlIsFunction = isFunction(html);
                return this.each(function(i) {
                    jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
                });
            },
            unwrap: function(selector) {
                this.parent(selector).not("body").each(function() {
                    jQuery(this).replaceWith(this.childNodes);
                });
                return this;
            }
        });
        jQuery.expr.pseudos.hidden = function(elem) {
            return !jQuery.expr.pseudos.visible(elem);
        };
        jQuery.expr.pseudos.visible = function(elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery.ajaxSettings.xhr = function() {
            try {
                return new window.XMLHttpRequest();
            } catch (e) {}
        };
        var xhrSuccessStatus = {
                0: 200,
                1223: 204
            },
            xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function(options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) {
                return {
                    send: function(headers, complete) {
                        var i, xhr = options.xhr();
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }
                        for (i in headers) {
                            xhr.setRequestHeader(i, headers[i]);
                        }
                        callback = function(type) {
                            return function() {
                                if (callback) {
                                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                                    if (type === "abort") {
                                        xhr.abort();
                                    } else if (type === "error") {
                                        if (typeof xhr.status !== "number") {
                                            complete(0, "error");
                                        } else {
                                            complete(xhr.status, xhr.statusText);
                                        }
                                    } else {
                                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                            binary: xhr.response
                                        } : {
                                            text: xhr.responseText
                                        }, xhr.getAllResponseHeaders());
                                    }
                                }
                            };
                        };
                        xhr.onload = callback();
                        errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                        if (xhr.onabort !== undefined) {
                            xhr.onabort = errorCallback;
                        } else {
                            xhr.onreadystatechange = function() {
                                if (xhr.readyState === 4) {
                                    window.setTimeout(function() {
                                        if (callback) {
                                            errorCallback();
                                        }
                                    });
                                }
                            };
                        }
                        callback = callback("abort");
                        try {
                            xhr.send(options.hasContent && options.data || null);
                        } catch (e) {
                            if (callback) {
                                throw e;
                            }
                        }
                    },
                    abort: function() {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        jQuery.ajaxPrefilter(function(s) {
            if (s.crossDomain) {
                s.contents.script = false;
            }
        });
        jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, " +
                    "application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function(text) {
                    jQuery.globalEval(text);
                    return text;
                }
            }
        });
        jQuery.ajaxPrefilter("script", function(s) {
            if (s.cache === undefined) {
                s.cache = false;
            }
            if (s.crossDomain) {
                s.type = "GET";
            }
        });
        jQuery.ajaxTransport("script", function(s) {
            if (s.crossDomain || s.scriptAttrs) {
                var script, callback;
                return {
                    send: function(_, complete) {
                        script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                            charset: s.scriptCharset,
                            src: s.url
                        }).on("load error", callback = function(evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === "error" ? 404 : 200, evt.type);
                            }
                        });
                        document.head.appendChild(script[0]);
                    },
                    abort: function() {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                this[callback] = true;
                return callback;
            }
        });
        jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
            if (jsonProp || s.dataTypes[0] === "jsonp") {
                callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                } else if (s.jsonp !== false) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                }
                s.converters["script json"] = function() {
                    if (!responseContainer) {
                        jQuery.error(callbackName + " was not called");
                    }
                    return responseContainer[0];
                };
                s.dataTypes[0] = "json";
                overwritten = window[callbackName];
                window[callbackName] = function() {
                    responseContainer = arguments;
                };
                jqXHR.always(function() {
                    if (overwritten === undefined) {
                        jQuery(window).removeProp(callbackName);
                    } else {
                        window[callbackName] = overwritten;
                    }
                    if (s[callbackName]) {
                        s.jsonpCallback = originalSettings.jsonpCallback;
                        oldCallbacks.push(callbackName);
                    }
                    if (responseContainer && isFunction(overwritten)) {
                        overwritten(responseContainer[0]);
                    }
                    responseContainer = overwritten = undefined;
                });
                return "script";
            }
        });
        support.createHTMLDocument = (function() {
            var body = document.implementation.createHTMLDocument("").body;
            body.innerHTML = "<form></form><form></form>";
            return body.childNodes.length === 2;
        })();
        jQuery.parseHTML = function(data, context, keepScripts) {
            if (typeof data !== "string") {
                return [];
            }
            if (typeof context === "boolean") {
                keepScripts = context;
                context = false;
            }
            var base, parsed, scripts;
            if (!context) {
                if (support.createHTMLDocument) {
                    context = document.implementation.createHTMLDocument("");
                    base = context.createElement("base");
                    base.href = document.location.href;
                    context.head.appendChild(base);
                } else {
                    context = document;
                }
            }
            parsed = rsingleTag.exec(data);
            scripts = !keepScripts && [];
            if (parsed) {
                return [context.createElement(parsed[1])];
            }
            parsed = buildFragment([data], context, scripts);
            if (scripts && scripts.length) {
                jQuery(scripts).remove();
            }
            return jQuery.merge([], parsed.childNodes);
        };
        jQuery.fn.load = function(url, params, callback) {
            var selector, type, response, self = this,
                off = url.indexOf(" ");
            if (off > -1) {
                selector = stripAndCollapse(url.slice(off));
                url = url.slice(0, off);
            }
            if (isFunction(params)) {
                callback = params;
                params = undefined;
            } else if (params && typeof params === "object") {
                type = "POST";
            }
            if (self.length > 0) {
                jQuery.ajax({
                    url: url,
                    type: type || "GET",
                    dataType: "html",
                    data: params
                }).done(function(responseText) {
                    response = arguments;
                    self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                }).always(callback && function(jqXHR, status) {
                    self.each(function() {
                        callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                    });
                });
            }
            return this;
        };
        jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
            jQuery.fn[type] = function(fn) {
                return this.on(type, fn);
            };
        });
        jQuery.expr.pseudos.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn) {
                return elem === fn.elem;
            }).length;
        };
        jQuery.offset = {
            setOffset: function(elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
                    curElem = jQuery(elem),
                    props = {};
                if (position === "static") {
                    elem.style.position = "relative";
                }
                curOffset = curElem.offset();
                curCSSTop = jQuery.css(elem, "top");
                curCSSLeft = jQuery.css(elem, "left");
                calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
                if (calculatePosition) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }
                if (isFunction(options)) {
                    options = options.call(elem, i, jQuery.extend({}, curOffset));
                }
                if (options.top != null) {
                    props.top = (options.top - curOffset.top) + curTop;
                }
                if (options.left != null) {
                    props.left = (options.left - curOffset.left) + curLeft;
                }
                if ("using" in options) {
                    options.using.call(elem, props);
                } else {
                    curElem.css(props);
                }
            }
        };
        jQuery.fn.extend({
            offset: function(options) {
                if (arguments.length) {
                    return options === undefined ? this : this.each(function(i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
                }
                var rect, win, elem = this[0];
                if (!elem) {
                    return;
                }
                if (!elem.getClientRects().length) {
                    return {
                        top: 0,
                        left: 0
                    };
                }
                rect = elem.getBoundingClientRect();
                win = elem.ownerDocument.defaultView;
                return {
                    top: rect.top + win.pageYOffset,
                    left: rect.left + win.pageXOffset
                };
            },
            position: function() {
                if (!this[0]) {
                    return;
                }
                var offsetParent, offset, doc, elem = this[0],
                    parentOffset = {
                        top: 0,
                        left: 0
                    };
                if (jQuery.css(elem, "position") === "fixed") {
                    offset = elem.getBoundingClientRect();
                } else {
                    offset = this.offset();
                    doc = elem.ownerDocument;
                    offsetParent = elem.offsetParent || doc.documentElement;
                    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
                        offsetParent = offsetParent.parentNode;
                    }
                    if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                        parentOffset = jQuery(offsetParent).offset();
                        parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                        parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                    }
                }
                return {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                };
            },
            offsetParent: function() {
                return this.map(function() {
                    var offsetParent = this.offsetParent;
                    while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || documentElement;
                });
            }
        });
        jQuery.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function(val) {
                return access(this, function(elem, method, val) {
                    var win;
                    if (isWindow(elem)) {
                        win = elem;
                    } else if (elem.nodeType === 9) {
                        win = elem.defaultView;
                    }
                    if (val === undefined) {
                        return win ? win[prop] : elem[method];
                    }
                    if (win) {
                        win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                    } else {
                        elem[method] = val;
                    }
                }, method, val, arguments.length);
            };
        });
        jQuery.each(["top", "left"], function(i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);
                    return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
                }
            });
        });
        jQuery.each({
            Height: "height",
            Width: "width"
        }, function(name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, function(defaultExtra, funcName) {
                jQuery.fn[funcName] = function(margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                        extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                    return access(this, function(elem, type, value) {
                        var doc;
                        if (isWindow(elem)) {
                            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                        }
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;
                            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                        }
                        return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable);
                };
            });
        });
        jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
            "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
            "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
            jQuery.fn[name] = function(data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        });
        jQuery.fn.extend({
            hover: function(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            }
        });
        jQuery.fn.extend({
            bind: function(types, data, fn) {
                return this.on(types, null, data, fn);
            },
            unbind: function(types, fn) {
                return this.off(types, null, fn);
            },
            delegate: function(selector, types, data, fn) {
                return this.on(types, selector, data, fn);
            },
            undelegate: function(selector, types, fn) {
                return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
            }
        });
        jQuery.proxy = function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        };
        jQuery.holdReady = function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        };
        jQuery.isArray = Array.isArray;
        jQuery.parseJSON = JSON.parse;
        jQuery.nodeName = nodeName;
        jQuery.isFunction = isFunction;
        jQuery.isWindow = isWindow;
        jQuery.camelCase = camelCase;
        jQuery.type = toType;
        jQuery.now = Date.now;
        jQuery.isNumeric = function(obj) {
            var type = jQuery.type(obj);
            return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
        };
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return jQuery;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
        var
            _jQuery = window.jQuery,
            _$ = window.$;
        jQuery.noConflict = function(deep) {
            if (window.$ === jQuery) {
                window.$ = _$;
            }
            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
            }
            return jQuery;
        };
        if (!noGlobal) {
            window.jQuery = window.$ = jQuery;
        }
        return jQuery;
    });
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var carousel1 = __webpack_require__(29);
    var video = __webpack_require__(30);
    var utils = __webpack_require__(10);
    var hotspots = __webpack_require__(31);
    var countdown = __webpack_require__(32);
    var modal = __webpack_require__(15);
    var processInclude = __webpack_require__(1);

    function initcarousel1() {
        var $carousel1 = $('.kop-content-carousel1');
        $carousel1.each(function() {
            var $scope = $(this);
            var autoplay = $scope.data('autoplay');
            var autoplayTimeout = $scope.data('autoplaytimeout') * 1000;
            var options = {
                mouseDrag: true,
                nav: true,
                dots: true,
                margin: 0,
                stagePadding: 0,
                autoplay: autoplay,
                autoplayTimeout: autoplayTimeout,
                autoplayHoverPause: true,
                loop: true,
                navText: [utils.generateSvgString('chevron-left-large-thin', 'kop-content-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'kop-content-carousel1__arrow')]
            };
            carousel1.init($scope, options);
        });
    }

    function initProductcarousel1() {
        var $carousel1 = $('.kop-product-carousel1');
        var options = {
            items: 4,
            mouseDrag: true,
            nav: true,
            dots: false,
            margin: 20,
            stagePadding: 60,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2,
                    margin: 50,
                    stagePadding: 50,
                    nav: true
                },
                768: {
                    items: 3,
                    margin: 70,
                    stagePadding: 70,
                    nav: true
                },
                992: {
                    items: 4,
                    margin: 10,
                    stagePadding: 100,
                    nav: true
                }
            }
        };
        carousel1.init($carousel1, options);
    }

    function initBannercarousel1() {
        var $carousel1 = $('.kop-bannergroup__carousel1');
        $carousel1.each(function() {
            var $scope = $(this);
            var autoplay = $scope.data('autoplay');
            var autoplayTimeout = $scope.data('autoplaytimeout') * 1000;
            var options = {
                mouseDrag: true,
                nav: true,
                dots: false,
                margin: 0,
                stagePadding: 0,
                autoplay: autoplay,
                autoplayTimeout: autoplayTimeout,
                autoplayHoverPause: true,
                autoHeight: false,
                loop: true,
                navText: [utils.generateSvgString('chevron-left', 'kop-bannergroup__carousel1__arrow'), utils.generateSvgString('chevron-right', 'kop-bannergroup__carousel1__arrow')]
            };
            carousel1.init($scope, options);
            $scope.find('.see-details').on('click', function(e) {
                e.preventDefault();
                var details = $(this).parents('.kop-bannertile__content').find('.kop-bannertile__details');
                if (details !== undefined) {
                    modal.create('kop-bannertile__details', $(details).html(), true);
                    modal.show();
                }
            });
        });
    }

    function initProductGroupFeaturescarousel1() {
        var $carousel1 = $('.kop-productgroupfeatures__wrapper');
        $carousel1.each(function() {
            var $scope = $(this);
            var options = {
                items: 3,
                mouseDrag: true,
                nav: true,
                dots: false,
                margin: 30,
                stagePadding: 40,
                navText: [utils.generateSvgString('chevron-left-large-thin', 'kop-productgroupfeatures__arrow'), utils.generateSvgString('chevron-right-large-thin', 'kop-productgroupfeatures__arrow')],
                responsive: {
                    0: {
                        items: 2
                    },
                    544: {
                        items: 3
                    }
                }
            };
            $(window).on('load resize', function() {
                if (window.screen.width > 960) {
                    carousel1.destroy($carousel1);
                } else {
                    carousel1.init($scope, options);
                }
            });
        });
    }

    function initHotspotContentcarousel1() {
        var $kopHero = $('.kop-hero');
        $kopHero.each(function() {
            var $scope = $(this);
            var $hotspotProductcarousel1 = $scope.find('.hotspot__list[data-type="product"]');
            if ($hotspotProductcarousel1.length < 1) {
                var $contentcarousel1 = $scope.find('.hotspot__list');
                $contentcarousel1.each(function() {
                    var $contentScope = $(this);
                    var options = {
                        items: 3,
                        mouseDrag: true,
                        nav: true,
                        dots: false,
                        margin: 30,
                        stagePadding: 40,
                        navText: [utils.generateSvgString('chevron-left-large-thin', 'kop-hotspotcontent__arrow'), utils.generateSvgString('chevron-right-large-thin', 'kop-hotspotcontent__arrow')],
                        responsive: {
                            0: {
                                items: 2
                            },
                            544: {
                                items: 3
                            }
                        }
                    };
                    $(window).on('load resize', function() {
                        if (window.screen.width > 960) {
                            carousel1.destroy($contentcarousel1);
                        } else if ($hotspotProductcarousel1.length < 1) {
                            carousel1.init($contentScope, options);
                        }
                    });
                });
            }
        });
    }

    function initVideocarousel1() {
        var $videocarousel1Container = $('.kop-videocarousel1');
        var videoUrl = 'https://www.youtube.com/embed/{videoId}?' +
            'autoplay=1&amp;showinfo=0&amp;rel=0';
        var youtubeApiUrl = 'https://www.googleapis.com/youtube/v3/videos?' +
            'part=snippet&id={videoIds}&key={youtubeApiKey}&maxResults=50';
        var youtubePlaylistApiUrl = 'https://www.googleapis.com/youtube/v3/playlistItems?' +
            'part=snippet&playlistId={playlistId}&key={youtubeApiKey}&maxResults=50';
        var createThumbscarousel1 = function(items, $scope) {
            var options = {
                items: 4,
                mouseDrag: true,
                nav: true,
                dots: false,
                margin: 20,
                navText: [utils.generateSvgString('chevron-left-large-thin', 'kop-videocarousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'kop-videocarousel1__arrow')],
                responsive: {
                    0: {
                        items: 2,
                        stagePadding: 60,
                        margin: 10
                    },
                    720: {
                        items: 3,
                        stagePadding: 100
                    },
                    959: {
                        items: 4
                    }
                }
            };
            var $thumbcarousel1Container = $scope.find('.kop-videocarousel1__thumbs__carousel1');
            var $videoFrame = $scope.find('#kop-videocarousel1__video__frame').eq(0);
            var isAutoPlay = $scope.data('autoplay');
            items.forEach(function(item, index) {
                var thumbImage = item.snippet.thumbnails.high ? item.snippet.thumbnails.high.url : item.snippet.thumbnails.default.url;
                var thumbTitle = item.snippet.localized ? item.snippet.localized.title : item.snippet.title;
                var videoId = item.snippet.resourceId ? item.snippet.resourceId.videoId : item.id;
                var thumbVideoUrl = videoUrl.replace('{videoId}', videoId);
                $thumbcarousel1Container.append(function() {
                    var $thumb = $('<div/>', {
                        class: 'kop-videocarousel1__thumbnail',
                        click: function() {
                            $videoFrame.attr('src', thumbVideoUrl);
                        }
                    }).append($('<img/>', {
                        src: thumbImage,
                        alt: thumbTitle
                    })).append($('<span/>', {
                        text: thumbTitle
                    }));
                    return $thumb;
                });
                if (index === 0) {
                    var firstVideoToLoad = thumbVideoUrl;
                    if (!isAutoPlay) {
                        firstVideoToLoad = firstVideoToLoad.replace('autoplay=1', 'autoplay=0');
                    }
                    $videoFrame.attr('src', firstVideoToLoad);
                }
            });
            carousel1.init($thumbcarousel1Container, options);
        };
        var setPlayerHeight = function($scope) {
            var $iFrame = $scope.find('#kop-videocarousel1__video__frame');
            var width = $iFrame.width();
            if (width > 0) {
                $iFrame.height((width / 16) * 9);
            }
        };
        $videocarousel1Container.each(function() {
            var $scope = $(this);
            var youtubeApiKey = 'AIzaSyD6YwUiDGrVmLFEqzsR_GcAk97v5NjOzkk';
            var videoIds = $scope.data('video-ids');
            var playlistId = $scope.data('playlist-id');
            var carousel1YoutubeApiUrl = '';
            if (playlistId.length > 0) {
                carousel1YoutubeApiUrl = youtubePlaylistApiUrl.replace('{youtubeApiKey}', youtubeApiKey).replace('{playlistId}', playlistId);
            } else if (videoIds.length > 0) {
                carousel1YoutubeApiUrl = youtubeApiUrl.replace('{youtubeApiKey}', youtubeApiKey).replace('{videoIds}', videoIds);
            } else {
                return;
            }
            setPlayerHeight($scope);
            $.getJSON(carousel1YoutubeApiUrl).done(function(data) {
                if (data && data.items && data.items.length) {
                    createThumbscarousel1(data.items, $scope);
                }
            }).fail(function() {
                console.error('Youtube api fetch error, see network tab for response details');
            });
            $(window).resize(function() {
                setPlayerHeight($scope);
            });
        });
    }

    function initializeVideo() {
        var $videos = $('.kop-htmlvideo, .kop-jsvideo');
        $videos.each(function() {
            var type = $(this).data('type');
            video.init($(this), type);
        });
        $(window).on('load resize', function(e) {
            var windowSize = $(this).width();
            $videos.each(function() {
                var videoContainer = $(this).closest('.kop-hero__video');
                if (videoContainer.length > 0) {
                    var currentVideoSrc = $(this).attr('src');
                    var adjustedVideoSrc;
                    var currentPosterSrc = $(this).attr('poster');
                    var adjustedPosterSrc;
                    if (windowSize < 543) {
                        adjustedVideoSrc = videoContainer.find('[name="srcVideoMobile"]')[0].value;
                        adjustedPosterSrc = videoContainer.find('[name="srcPosterMobile"]')[0].value;
                    } else if (windowSize >= 543 && windowSize < 959) {
                        adjustedVideoSrc = videoContainer.find('[name="srcVideoTablet"]')[0].value;
                        adjustedPosterSrc = videoContainer.find('[name="srcPosterTablet"]')[0].value;
                    } else {
                        adjustedVideoSrc = videoContainer.find('[name="srcVideoDesktop"]')[0].value;
                        adjustedPosterSrc = videoContainer.find('[name="srcPosterDesktop"]')[0].value;
                    }
                    if ((adjustedVideoSrc && adjustedVideoSrc !== currentVideoSrc) || (adjustedPosterSrc && adjustedPosterSrc !== currentPosterSrc) || e.type === 'load') {
                        $(this).attr('src', adjustedVideoSrc);
                        $(this).attr('poster', adjustedPosterSrc);
                        $(videoContainer).removeClass('d-none');
                    }
                }
            });
        });
    }

    function initializeCountdown() {
        var $countdown = $('.countdown');
        $countdown.each(function(i, elem) {
            var $el = $(elem);
            countdown.init($el);
        });
    }

    function initCalendar() {
        $('.kop-caldate__popup, .kop-calgroup__historyslidegroup__popup').each(function() {
            $('body').append($(this).detach());
        });
        var onOpenModal = function(e) {
            e.preventDefault();
            var modalElemId = $(this).data('modal');
            if (modalElemId) {
                var $modal = $('#' + modalElemId);
                $modal.modal('show');
                var $carousel1 = $modal.find('.kop-slidegroup__carousel1');
                var numSlides = $carousel1.find('.kop-slidesingle').length;
                if (numSlides > 1) {
                    var carousel1StartPos = 0;
                    var options = {
                        items: 1,
                        mouseDrag: true,
                        margin: 20,
                        dots: true,
                        nav: true,
                        center: false,
                        navText: [utils.generateSvgString('chevron-left-large-thin', 'kop-slidegroup__carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'kop-slidegroup__carousel1__arrow')],
                        responsive: {
                            0: {
                                startPosition: 0,
                                stagePadding: 60
                            },
                            720: {
                                stagePadding: 100,
                                startPosition: carousel1StartPos
                            },
                            860: {
                                stagePadding: 200,
                                startPosition: carousel1StartPos
                            }
                        }
                    };
                    carousel1.init($carousel1, options);
                } else {
                    $carousel1.show();
                }
                $modal.find('.modal-fs__close').on('click', function(event) {
                    event.preventDefault();
                    carousel1.destroy($carousel1);
                    $modal.modal('hide');
                });
            }
        };
        $('.kop-caldate__diamond__cta__openmodal').on('click', onOpenModal);
        $('.kop-calgroup__cta').on('click', onOpenModal);
        $('.kop-calgroup__load-more').on('click', function(e) {
            e.preventDefault();
            var $loadMoreButton = $(this);
            var $calendarContainer = $loadMoreButton.parents('.kop-calgroup__container');
            var $visuallyHiddenMonths = $calendarContainer.find('.kop-calgroup__layout.visually-hidden');
            if ($visuallyHiddenMonths.length <= 3) {
                $loadMoreButton.hide();
            }
            $visuallyHiddenMonths.eq(0).removeClass('visually-hidden');
            $visuallyHiddenMonths.eq(1).removeClass('visually-hidden');
            $visuallyHiddenMonths.eq(2).removeClass('visually-hidden');
        });
    }

    function initKopNewsletterForm() {
        processInclude(__webpack_require__(34));
    }
    module.exports = function() {
        initcarousel1();
        initProductcarousel1();
        initProductGroupFeaturescarousel1();
        initHotspotContentcarousel1();
        initBannercarousel1();
        initializeVideo();
        initializeCountdown();
        initVideocarousel1();
        hotspots();
        initCalendar();
        initKopNewsletterForm();
    };
}), (function(module, exports) {
    'use strict';
    var defaultOptions = {
        items: 1,
        dots: false
    };
    const carousel1Pointers = {
        LEFT: 'left',
        RIGHT: 'right'
    };

    function initcarousel1sDataTracking() {
        initcarousel1TilesPageDataOrdering();
        updatecarousel1sDataTrackInformation();
    }

    function initcarousel1TilesPageDataOrdering() {
        var provider = $('.product-recommendations .product-carousel1, .recommendations-content .product-carousel1');
        if (provider.length > 0) {
            var tiles = $(provider).find('a.kop-product-carousel1__link');
            tiles.each(function(index) {
                $(this).attr('data-track-link-order', index);
            });
        }
    }

    function updatecarousel1sDataTrackInformation() {
        var nextSteps = $('.product-recommendations .owl-next, .recommendations-content .owl-next');
        if (nextSteps) {
            updatecarousel1PointersDataTrackInformation(nextSteps, carousel1Pointers.RIGHT);
        }
        var prevSteps = $('.product-recommendations .owl-prev, .recommendations-content .owl-prev');
        if (prevSteps) {
            updatecarousel1PointersDataTrackInformation(prevSteps, carousel1Pointers.LEFT);
        }
    }

    function updatecarousel1PointersDataTrackInformation(steps, pointer) {
        if (pointer === carousel1Pointers.RIGHT || pointer === carousel1Pointers.LEFT) {
            $(steps).each(function() {
                var step = this;
                var trackLinkTitle = (pointer === carousel1Pointers.RIGHT) ? 'next' : 'prev';
                var items = $(step).parents('.owl-carousel1').find('.owl-item');
                $(items).each(function() {
                    updatecarousel1Pointer(step, pointer, trackLinkTitle);
                });
            });
        }
    }

    function updatecarousel1Pointer(step, pointer, trackLinkTitle) {
        $(step).attr({
            'data-track-link-title': trackLinkTitle,
            'data-track-link-position': pointer
        });
    }

    function initialize($carousel1, options) {
        if ($ && $.fn.owlcarousel1) {
            var mergedOptions = $.extend({}, defaultOptions, options);
            $carousel1.owlcarousel1(mergedOptions);
            initcarousel1sDataTracking();
        } else {
            window.console.warn('Owl carousel1 not loaded');
        }
    }

    function destroy($carousel1) {
        $carousel1.trigger('destroy.owl.carousel1');
    }
    module.exports = {
        init: initialize,
        destroy: destroy
    };
}), (function(module, exports) {
    'use strict';
    var youTubePlayerLoaded = false;
    var youTubeOptions = {
        playerVars: {
            loop: 0,
            autoplay: 0,
            controls: 0
        },
        events: {}
    };

    function loadYouTubePlayerAPI() {
        if (youTubePlayerLoaded || window.YT) {
            return;
        }
        var tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/player_api';
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        window.onYouTubeIframeAPIReady = function() {
            youTubePlayerLoaded = true;
            $('body').trigger('yt-loaded');
        };
    }

    function generateYouTubeOptions($video, options, events) {
        var processedOptions = {};
        var processedEvents = {};
        if ($video && $video.data('options').length) {
            $video.data('options').split(' ').forEach(function(option) {
                switch (option) {
                    case 'autoplay':
                        processedOptions.autoplay = 1;
                        break;
                    case 'controls':
                        processedOptions.controls = 2;
                        break;
                    case 'loop':
                        processedOptions.loop = 1;
                        break;
                    case 'muted':
                        processedEvents.onReady = function(e) {
                            e.target.mute();
                        };
                        break;
                    default:
                        break;
                }
            });
        }
        return {
            videoId: $video.data('id'),
            playerVars: $.extend({}, youTubeOptions.playerVars, processedOptions, options),
            events: $.extend({}, youTubeOptions.events, processedEvents, events)
        };
    }

    function loadHtmlVideoPlayer($htmlvideo) {
        var loopCount = 0;
        var throttle = true;
        $htmlvideo.parent('.video__wrapper').off('mouseleave').on('mouseleave', function() {
            $(this).addClass('mouse-show-pause');
        });
        if ($htmlvideo.attr('controls')) {
            $htmlvideo.parent('.video__wrapper').find('.icon').addClass('invisible');
        }
        $htmlvideo.off('click').on('click', function(e) {
            var $el = $(e.target);
            var $this = $(this);
            if ($this.get(0).paused) {
                $this.get(0).play();
                $el.parent('.video__wrapper').removeClass('video-stopped');
                $el.parent('.video__wrapper').addClass('video-playing');
            } else {
                $this.get(0).pause();
                $el.parent('.video__wrapper').removeClass('video-stopped');
                $el.parent('.video__wrapper').addClass('video-paused');
            }
        });
        $htmlvideo.off('play').on('play', function(e) {
            var $el = $(e.target);
            if ($el.attr('data-started') !== 'true' && !$el.hasClass('thumbnail-video')) {
                $el.attr('data-started', true);
                $el.get(0).currentTime = 0;
            }
            $el.parent('.video__wrapper').removeClass('video-stopped');
            $el.parent('.video__wrapper').addClass('video-playing');
            $el.parent('.video__wrapper').removeClass('video-paused');
            $el.parent('.video__wrapper').removeClass('mouse-show-pause');
        });
        $htmlvideo.off('pause ended').on('pause ended', function(e) {
            var $el = $(e.target);
            var posterSecond = $el.attr('data-poster-second');
            if (e.type === 'ended' && posterSecond) {
                $el.get(0).currentTime = parseInt(posterSecond, 10);
                $el.attr('data-started', false);
            }
            if (!$el.hasClass('thumbnail-video')) {
                $el.parent('.video__wrapper').removeClass('video-stopped');
                $el.parent('.video__wrapper').addClass('video-paused');
            } else {
                $el.parent('.video__wrapper').addClass('video-stopped');
                $el.parent('.video__wrapper').removeClass('video-paused');
            }
            $el.parent('.video__wrapper').removeClass('video-playing');
            $el.parent('.video__wrapper').removeClass('mouse-show-pause');
        });
        $htmlvideo.off('seeked').on('seeked', function(e) {
            var $el = $(e.target);
            var $productVideoWrapper = $el.parents('.product-video');
            var posterSecond = $el.attr('data-poster-second');
            var numberOfLoops = $el.attr('data-number-of-loops');
            var loop = $el.attr('loop');
            if (loop && $productVideoWrapper.length > 0 && posterSecond && numberOfLoops) {
                if ($el.get(0).currentTime < 0.1 && throttle) {
                    throttle = false;
                    loopCount += 1;
                    setTimeout(function() {
                        throttle = true;
                    }, 100);
                }
                if (loopCount > parseInt(numberOfLoops, 10)) {
                    $el.get(0).pause();
                    $el.get(0).currentTime = parseInt(posterSecond, 10);
                    $el.attr('data-started', false);
                    loopCount = 0;
                    throttle = true;
                }
            }
        });
        $htmlvideo.off('webkitfullscreenchange mozfullscreenchange fullscreenchange').on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function(e) {
            var $el = $(e.target);
            var state = document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen;
            $('.product-gallery__video').toggleClass('d-none', !state);
            if (!state && $el.parents('.product-gallery__video').length > 0) {
                $el.get(0).pause();
            }
        });
    }

    function initialize($video, type, options) {
        var video;
        var playerOptions;
        if (type.toLowerCase() === 'file') {
            loadHtmlVideoPlayer($video);
        } else if (type.toLowerCase() === 'youtube' && !youTubePlayerLoaded) {
            loadYouTubePlayerAPI();
            playerOptions = generateYouTubeOptions($video, options);
            $('body').on('yt-loaded', function() {
                video = new window.YT.Player($video.attr('id'), playerOptions);
            });
        } else if (type.toLowerCase() === 'youtube') {
            playerOptions = generateYouTubeOptions($video, options);
            video = new window.YT.Player($video.attr('id'), playerOptions);
        }
        return video;
    }
    module.exports = {
        init: initialize
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var modalClass = 'hotspotQuickViewModal';
    var carousel1 = __webpack_require__(29);
    var form = __webpack_require__(5);
    var quickview = __webpack_require__(17);
    var utils = __webpack_require__(10);

    function closeMiniModal(e) {
        e.preventDefault();
        var $target = $(e.target);
        var $modal = $target.hasClass(modalClass) ? $target : $target.parents('.' + modalClass);
        $modal.removeClass('show');
        $modal.removeAttr('id');
    }

    function bootstrapModal($modal) {
        $modal.addClass('show').off('hotspot').on('click.hotspot', '[data-dismiss="modal"]', closeMiniModal).on('click.hotspot', function(e) {
            if ($(e.target).hasClass(modalClass)) {
                closeMiniModal(e);
            }
        });
    }

    function initTabletProductcarousel1($hotspotcontainer) {
        var $carousel1 = $('<div class="kop-hotspot-carousel1 owl-carousel1"></div>').append($hotspotcontainer.html());
        $hotspotcontainer.after($carousel1);
        var options = {
            items: 4,
            mouseDrag: true,
            nav: true,
            dots: false,
            margin: 20,
            stagePadding: 60,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'hotspot-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'hotspot-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2,
                    margin: 50,
                    stagePadding: 50,
                    nav: true
                },
                768: {
                    items: 3,
                    margin: 70,
                    stagePadding: 70,
                    nav: true
                },
                992: {
                    items: 4,
                    margin: 10,
                    stagePadding: 100,
                    nav: true
                }
            }
        };
        carousel1.init($carousel1, options);
    }

    function loadProductQuickview($modal, quickviewUrl) {
        $modal.parents('.kop-hero__wrapper').spinner().start();
        var productUrl = quickviewUrl.replace('Product-ShowQuickView', 'Product-Show');
        $.ajax({
            url: quickviewUrl,
            method: 'GET',
            dataType: 'html',
            success: function(html) {
                $modal.attr('id', 'quickViewModal');
                $modal.find('.modal-body').empty().html(html);
                bootstrapModal($modal);
                $modal.find('.full-pdp-link').attr('href', productUrl);
                $modal.find('.size-chart').attr('href', productUrl);
                form.init();
                $modal.trigger('quickview:show');
                $.spinner().stop();
            },
            error: function() {
                $.spinner().stop();
            }
        });
    }

    function loadContentModal($modal, $hotspot) {
        var $content = $($hotspot.attr('href'));
        var $el = $('<div class="kop__hotspot__content"></div>').append($content.html());
        $modal.find('.modal-body').empty().append($el);
        bootstrapModal($modal);
    }

    function openMiniModal(e) {
        e.preventDefault();
        var $this = $(e.target);
        var $modal = $this.parents('.kop-hero').find('.' + modalClass);
        if ($this.data('type') === 'product') {
            loadProductQuickview($modal, $this.attr('href'));
        } else if ($this.data('type') === 'content') {
            loadContentModal($modal, $this);
        }
    }

    function initialize() {
        $('.kop-hero__hotspot[data-type!="anchor"]').on('click.hotspot', openMiniModal);
        quickview.init();
        $(document).ready(function() {
            $('.kop-hero .hotspot__list[data-type="product"]').each(function() {
                initTabletProductcarousel1($(this));
            });
        });
    }
    module.exports = initialize;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    __webpack_require__(33);

    function initialize($el) {
        if ('countDown' in $.fn) {
            $el.countDown({
                css_class: 'countdown-kop',
                always_show_days: false,
                with_labels: true,
                with_seconds: true,
                with_separators: true,
                with_hh_leading_zero: true,
                with_mm_leading_zero: true,
                with_ss_leading_zero: true,
                label_dd: 'days',
                label_hh: 'hrs',
                label_mm: 'mins',
                label_ss: 'secs',
                separator: ':',
                separator_days: ':'
            });
        }
    }
    module.exports = {
        init: initialize
    };
}), (function(module, exports) {
    (function($, window, document, undefined) {
        "use strict";
        var pluginName = 'countDown';
        var defaults = {
            css_class: 'countdown',
            always_show_days: false,
            with_labels: true,
            with_seconds: true,
            with_separators: true,
            with_hh_leading_zero: true,
            with_mm_leading_zero: true,
            with_ss_leading_zero: true,
            label_dd: 'days',
            label_hh: 'hours',
            label_mm: 'minutes',
            label_ss: 'seconds',
            separator: ':',
            separator_days: ','
        };

        function CountDown(element, options) {
            this.element = $(element);
            this.options = $.extend({}, defaults, options);
            this._defaults = defaults;
            this._name = pluginName;
            this.init();
        }
        $.extend(CountDown.prototype, {
            init: function() {
                if (this.element.children().length) {
                    return;
                }
                if (this.element.attr('datetime')) {
                    this.endDate = this.parseEndDate(this.element.attr('datetime'));
                }
                if (this.endDate === undefined) {
                    this.endDate = this.parseEndDate(this.element.text());
                }
                if (this.endDate === undefined) {
                    return;
                }
                if (this.element.is('time')) {
                    this.timeElement = this.element;
                } else {
                    this.timeElement = $('<time></time>');
                    this.element.html(this.timeElement);
                }
                this.markup();
                this.setTimeoutDelay = this.sToMs(1);
                this.daysVisible = true;
                this.timeElement.on('time.elapsed', this.options.onTimeElapsed);
                this.timeElement.on('time.tick', this.options.onTick);
                this.doCountDown();
            },
            parseEndDate: function(str) {
                var d;
                d = this.parseDuration(str);
                if (d instanceof Date) {
                    return d;
                }
                d = this.parseDateTime(str);
                if (d instanceof Date) {
                    return d;
                }
                d = this.parseHumanReadableDuration(str);
                if (d instanceof Date) {
                    return d;
                }
                d = Date.parse(str);
                if (!isNaN(d)) {
                    return new Date(d);
                }
            },
            parseDuration: function(str) {
                var timeArray = str.match(/^P(?:(\d+)D)?T?(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)(?:\.(\d{1,3}))?S)?$/);
                if (timeArray) {
                    var d, dd, hh, mm, ss, ms;
                    dd = timeArray[1] ? this.dToMs(timeArray[1]) : 0;
                    hh = timeArray[2] ? this.hToMs(timeArray[2]) : 0;
                    mm = timeArray[3] ? this.mToMs(timeArray[3]) : 0;
                    ss = timeArray[4] ? this.sToMs(timeArray[4]) : 0;
                    ms = timeArray[5] ? parseInt(timeArray[5], 10) : 0;
                    d = new Date();
                    d.setTime(d.getTime() + dd + hh + mm + ss + ms);
                    return d;
                }
            },
            parseDateTime: function(str) {
                var timeArray = str.match(/^(\d{4,})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2})(?:\:(\d{2}))?(?:\.(\d{1,3}))?([Z\+\-\:\d]+)?$/);
                if (timeArray) {
                    var offset = timeArray[8] ? timeArray[8].match(/^([\+\-])?(\d{2}):?(\d{2})$/) : undefined;
                    var utcOffset = 0;
                    if (offset) {
                        utcOffset = this.hToMs(offset[2]) + this.mToMs(offset[3]);
                        utcOffset = (offset[1] === '-') ? utcOffset : -utcOffset;
                    }
                    var d, yy, mo, dd, hh, mm, ss, ms;
                    yy = timeArray[1];
                    mo = timeArray[2] - 1;
                    dd = timeArray[3];
                    hh = timeArray[4] || 0;
                    mm = timeArray[5] || 0;
                    ss = timeArray[6] || 0;
                    ms = timeArray[7] || 0;
                    d = new Date(Date.UTC(yy, mo, dd, hh, mm, ss, ms));
                    d.setTime(d.getTime() + utcOffset);
                    return d;
                }
            },
            parseHumanReadableDuration: function(str) {
                var timeArray = str.match(/^(?:(\d+).+\s)?(\d+)[h:]\s?(\d+)[m:]?\s?(\d+)?[s]?(?:\.(\d{1,3}))?$/);
                if (timeArray) {
                    var d, dd, hh, mm, ss, ms;
                    d = new Date();
                    dd = timeArray[1] ? this.dToMs(timeArray[1]) : 0;
                    hh = timeArray[2] ? this.hToMs(timeArray[2]) : 0;
                    mm = timeArray[3] ? this.mToMs(timeArray[3]) : 0;
                    ss = timeArray[4] ? this.sToMs(timeArray[4]) : 0;
                    ms = timeArray[5] ? parseInt(timeArray[5], 10) : 0;
                    d.setTime(d.getTime() + dd + hh + mm + ss + ms);
                    return d;
                }
            },
            sToMs: function(s) {
                return parseInt(s, 10) * 1000;
            },
            mToMs: function(m) {
                return parseInt(m, 10) * 60 * 1000;
            },
            hToMs: function(h) {
                return parseInt(h, 10) * 60 * 60 * 1000;
            },
            dToMs: function(d) {
                return parseInt(d, 10) * 24 * 60 * 60 * 1000;
            },
            msToS: function(ms) {
                return parseInt((ms / 1000) % 60, 10);
            },
            msToM: function(ms) {
                return parseInt((ms / 1000 / 60) % 60, 10);
            },
            msToH: function(ms) {
                return parseInt((ms / 1000 / 60 / 60) % 24, 10);
            },
            msToD: function(ms) {
                return parseInt((ms / 1000 / 60 / 60 / 24), 10);
            },
            markup: function() {
                var html = ['<span class="item item-dd">', '<span class="dd"></span>', '<span class="label label-dd">', this.options.label_dd, '</span>', '</span>', '<span class="separator separator-dd">', this.options.separator_days, '</span>', '<span class="item item-hh">', '<span class="hh-1"></span>', '<span class="hh-2"></span>', '<span class="label label-hh">', this.options.label_hh, '</span>', '</span>', '<span class="separator">', this.options.separator, '</span>', '<span class="item item-mm">', '<span class="mm-1"></span>', '<span class="mm-2"></span>', '<span class="label label-mm">', this.options.label_mm, '</span>', '</span>', '<span class="separator">', this.options.separator, '</span>', '<span class="item item-ss">', '<span class="ss-1"></span>', '<span class="ss-2"></span>', '<span class="label label-ss">', this.options.label_ss, '</span>', '</span>'];
                this.timeElement.html(html.join(''));
                if (!this.options.with_labels) {
                    this.timeElement.find('.label').remove();
                }
                if (!this.options.with_separators) {
                    this.timeElement.find('.separator').remove();
                }
                if (!this.options.with_seconds) {
                    this.timeElement.find('.item-ss').remove();
                    this.timeElement.find('.separator').last().remove();
                }
                this.item_dd = this.timeElement.find('.item-dd');
                this.separator_dd = this.timeElement.find('.separator-dd');
                this.remaining_dd = this.timeElement.find('.dd');
                this.remaining_hh1 = this.timeElement.find('.hh-1');
                this.remaining_hh2 = this.timeElement.find('.hh-2');
                this.remaining_mm1 = this.timeElement.find('.mm-1');
                this.remaining_mm2 = this.timeElement.find('.mm-2');
                this.remaining_ss1 = this.timeElement.find('.ss-1');
                this.remaining_ss2 = this.timeElement.find('.ss-2');
                this.timeElement.addClass(this.options.css_class);
            },
            doCountDown: function() {
                var ms = this.endDate.getTime() - new Date().getTime();
                var ss = this.msToS(ms);
                var mm = this.msToM(ms);
                var hh = this.msToH(ms);
                var dd = this.msToD(ms);
                if (ms <= 0) {
                    ss = mm = hh = dd = 0;
                }
                this.displayRemainingTime({
                    'ss': ss < 10 ? (this.options.with_ss_leading_zero ? '0' : ' ') + ss.toString() : ss.toString(),
                    'mm': mm < 10 ? (this.options.with_mm_leading_zero ? '0' : ' ') + mm.toString() : mm.toString(),
                    'hh': hh < 10 ? (this.options.with_hh_leading_zero ? '0' : ' ') + hh.toString() : hh.toString(),
                    'dd': dd.toString()
                });
                if (!this.options.with_seconds && dd === 0 && mm === 0 && hh === 0) {
                    ss = 0;
                }
                if (dd === 0 && mm === 0 && hh === 0 && ss === 0) {
                    return this.timeElement.trigger('time.elapsed');
                }
                var self = this;
                window.setTimeout(function() {
                    self.doCountDown();
                }, self.setTimeoutDelay);
                return this.timeElement.trigger('time.tick', ms);
            },
            displayRemainingTime: function(remaining) {
                var attr = [];
                attr.push('P');
                if (remaining.dd !== '0') {
                    attr.push(remaining.dd, 'D');
                }
                attr.push('T', remaining.hh, 'H', remaining.mm, 'M');
                if (this.options.with_seconds) {
                    attr.push(remaining.ss, 'S');
                }
                this.timeElement.attr('datetime', attr.join(''));
                if (this.daysVisible && !this.options.always_show_days && remaining.dd === '0') {
                    this.item_dd.remove();
                    this.separator_dd.remove();
                    this.daysVisible = false;
                }
                this.remaining_dd.text(remaining.dd);
                this.remaining_hh1.text(remaining.hh[0].trim());
                this.remaining_hh2.text(remaining.hh[1]);
                this.remaining_mm1.text(remaining.mm[0].trim());
                this.remaining_mm2.text(remaining.mm[1]);
                this.remaining_ss1.text(remaining.ss[0].trim());
                this.remaining_ss2.text(remaining.ss[1]);
            }
        });
        $.fn[pluginName] = function(options) {
            var args = arguments;
            if (options === undefined || typeof options === 'object') {
                return this.each(function() {
                    if (!$.data(this, 'plugin_' + pluginName)) {
                        $.data(this, 'plugin_' + pluginName, new CountDown(this, options));
                    }
                });
            } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
                var returns;
                this.each(function() {
                    var instance = $.data(this, 'plugin_' + pluginName);
                    if (instance instanceof CountDown && typeof instance[options] === 'function') {
                        returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
                    }
                    if (options === 'destroy') {
                        $.data(this, 'plugin_' + pluginName, null);
                    }
                });
                return returns !== undefined ? returns : this;
            }
        };
    })(window.jQuery, window, document);
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var modal = __webpack_require__(15);
    var formValidation = __webpack_require__(3);

    function handleSubmitKopNewsletterForm() {
        $('body').on('submit', 'form.kop-newsletter-form', function(e) {
            e.preventDefault();
            var $currentForm = $(this);
            $currentForm.spinner().start();
            $.ajax({
                url: $currentForm.attr('action'),
                method: $currentForm.attr('method'),
                data: $currentForm.serialize(),
                success: function(data) {
                    formValidation($currentForm, data);
                    $currentForm.spinner().stop();
                    if (data.success) {
                        modal.create('kopNewsletterFormViewModal', data.successHtml, true);
                        modal.show();
                    }
                },
                error: function(data) {
                    $currentForm.spinner().stop();
                    if (data.responseJSON && data.responseJSON.redirectUrl) {
                        window.location.href = data.responseJSON.redirectUrl;
                    }
                }
            });
        });
    }

    function helperInit() {
        $('body').on('ready', 'form.kop-newsletter-form', function() {
            $(this).find('input:radio').prop('indeterminate', false);
        });
    }
    module.exports = function() {
        helperInit();
        handleSubmitKopNewsletterForm();
        __webpack_require__(8).init();
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    __webpack_require__(36);
    __webpack_require__(37);
    __webpack_require__(38);
    __webpack_require__(39);
    __webpack_require__(40);
    __webpack_require__(41);
    __webpack_require__(42);
    $(function() {
        $('[data-toggle="tooltip"]').addClass('initialized').tooltip();
        $(document).on('ajaxComplete', function() {
            $('[data-toggle="tooltip"]:not(.initialized)').addClass('initialized').tooltip();
        });
    });
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var Util = function($) {
        var TRANSITION_END = 'transitionend';
        var MAX_UID = 1000000;
        var MILLISECONDS_MULTIPLIER = 1000;

        function toType(obj) {
            return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
        }

        function getSpecialTransitionEndEvent() {
            return {
                bindType: TRANSITION_END,
                delegateType: TRANSITION_END,
                handle: function handle(event) {
                    if ($(event.target).is(this)) {
                        return event.handleObj.handler.apply(this, arguments);
                    }
                    return undefined;
                }
            };
        }

        function transitionEndEmulator(duration) {
            var _this = this;
            var called = false;
            $(this).one(Util.TRANSITION_END, function() {
                called = true;
            });
            setTimeout(function() {
                if (!called) {
                    Util.triggerTransitionEnd(_this);
                }
            }, duration);
            return this;
        }

        function setTransitionEndSupport() {
            $.fn.emulateTransitionEnd = transitionEndEmulator;
            $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
        }
        var Util = {
            TRANSITION_END: 'bsTransitionEnd',
            getUID: function getUID(prefix) {
                do {
                    prefix += ~~(Math.random() * MAX_UID);
                } while (document.getElementById(prefix));
                return prefix;
            },
            getSelectorFromElement: function getSelectorFromElement(element) {
                var selector = element.getAttribute('data-target');
                if (!selector || selector === '#') {
                    selector = element.getAttribute('href') || '';
                }
                try {
                    var $selector = $(document).find(selector);
                    return $selector.length > 0 ? selector : null;
                } catch (err) {
                    return null;
                }
            },
            getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
                if (!element) {
                    return 0;
                }
                var transitionDuration = $(element).css('transition-duration');
                var floatTransitionDuration = parseFloat(transitionDuration);
                if (!floatTransitionDuration) {
                    return 0;
                }
                transitionDuration = transitionDuration.split(',')[0];
                return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;
            },
            reflow: function reflow(element) {
                return element.offsetHeight;
            },
            triggerTransitionEnd: function triggerTransitionEnd(element) {
                $(element).trigger(TRANSITION_END);
            },
            supportsTransitionEnd: function supportsTransitionEnd() {
                return Boolean(TRANSITION_END);
            },
            isElement: function isElement(obj) {
                return (obj[0] || obj).nodeType;
            },
            typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
                for (var property in configTypes) {
                    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
                        var expectedTypes = configTypes[property];
                        var value = config[property];
                        var valueType = value && Util.isElement(value) ? 'element' : toType(value);
                        if (!new RegExp(expectedTypes).test(valueType)) {
                            throw new Error(componentName.toUpperCase() + ': ' + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
                        }
                    }
                }
            }
        };
        setTransitionEndSupport();
        return Util;
    }(_jquery2.default);
    exports.default = Util;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Alert = function($) {
        var NAME = 'alert';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.alert';
        var EVENT_KEY = '.' + DATA_KEY;
        var DATA_API_KEY = '.data-api';
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var Selector = {
            DISMISS: '[data-dismiss="alert"]'
        };
        var Event = {
            CLOSE: 'close' + EVENT_KEY,
            CLOSED: 'closed' + EVENT_KEY,
            CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
            ALERT: 'alert',
            FADE: 'fade',
            SHOW: 'show'
        };
        var Alert = function() {
            function Alert(element) {
                _classCallCheck(this, Alert);
                this._element = element;
            }
            _createClass(Alert, [{
                key: 'close',
                value: function close(element) {
                    element = element || this._element;
                    var rootElement = this._getRootElement(element);
                    var customEvent = this._triggerCloseEvent(rootElement);
                    if (customEvent.isDefaultPrevented()) {
                        return;
                    }
                    this._removeElement(rootElement);
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    $.removeData(this._element, DATA_KEY);
                    this._element = null;
                }
            }, {
                key: '_getRootElement',
                value: function _getRootElement(element) {
                    var selector = _util2.default.getSelectorFromElement(element);
                    var parent = false;
                    if (selector) {
                        parent = $(selector)[0];
                    }
                    if (!parent) {
                        parent = $(element).closest('.' + ClassName.ALERT)[0];
                    }
                    return parent;
                }
            }, {
                key: '_triggerCloseEvent',
                value: function _triggerCloseEvent(element) {
                    var closeEvent = $.Event(Event.CLOSE);
                    $(element).trigger(closeEvent);
                    return closeEvent;
                }
            }, {
                key: '_removeElement',
                value: function _removeElement(element) {
                    var _this = this;
                    $(element).removeClass(ClassName.SHOW);
                    if (!$(element).hasClass(ClassName.FADE)) {
                        this._destroyElement(element);
                        return;
                    }
                    var transitionDuration = _util2.default.getTransitionDurationFromElement(element);
                    $(element).one(_util2.default.TRANSITION_END, function(event) {
                        return _this._destroyElement(element, event);
                    }).emulateTransitionEnd(transitionDuration);
                }
            }, {
                key: '_destroyElement',
                value: function _destroyElement(element) {
                    $(element).detach().trigger(Event.CLOSED).remove();
                }
            }], [{
                key: '_jQueryInterface',
                value: function _jQueryInterface(config) {
                    return this.each(function() {
                        var $element = $(this);
                        var data = $element.data(DATA_KEY);
                        if (!data) {
                            data = new Alert(this);
                            $element.data(DATA_KEY, data);
                        }
                        if (config === 'close') {
                            data[config](this);
                        }
                    });
                }
            }, {
                key: '_handleDismiss',
                value: function _handleDismiss(alertInstance) {
                    return function(event) {
                        if (event) {
                            event.preventDefault();
                        }
                        alertInstance.close(this);
                    };
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }]);
            return Alert;
        }();
        $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
        $.fn[NAME] = Alert._jQueryInterface;
        $.fn[NAME].Constructor = Alert;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return Alert._jQueryInterface;
        };
        return Alert;
    }(_jquery2.default);
    exports.default = Alert;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Collapse = function($) {
        var NAME = 'collapse';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.collapse';
        var EVENT_KEY = '.' + DATA_KEY;
        var DATA_API_KEY = '.data-api';
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var Default = {
            toggle: true,
            parent: ''
        };
        var DefaultType = {
            toggle: 'boolean',
            parent: '(string|element)'
        };
        var Event = {
            SHOW: 'show' + EVENT_KEY,
            SHOWN: 'shown' + EVENT_KEY,
            HIDE: 'hide' + EVENT_KEY,
            HIDDEN: 'hidden' + EVENT_KEY,
            CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
            SHOW: 'show',
            COLLAPSE: 'collapse',
            COLLAPSING: 'collapsing',
            COLLAPSED: 'collapsed'
        };
        var Dimension = {
            WIDTH: 'width',
            HEIGHT: 'height'
        };
        var Selector = {
            ACTIVES: '.show, .collapsing',
            DATA_TOGGLE: '[data-toggle="collapse"]'
        };
        var Collapse = function() {
            function Collapse(element, config) {
                _classCallCheck(this, Collapse);
                this._isTransitioning = false;
                this._element = element;
                this._config = this._getConfig(config);
                this._triggerArray = $.makeArray($('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
                var tabToggles = $(Selector.DATA_TOGGLE);
                for (var i = 0; i < tabToggles.length; i++) {
                    var elem = tabToggles[i];
                    var selector = _util2.default.getSelectorFromElement(elem);
                    if (selector !== null && $(selector).filter(element).length > 0) {
                        this._selector = selector;
                        this._triggerArray.push(elem);
                    }
                }
                this._parent = this._config.parent ? this._getParent() : null;
                if (!this._config.parent) {
                    this._addAriaAndCollapsedClass(this._element, this._triggerArray);
                }
                if (this._config.toggle) {
                    this.toggle();
                }
            }
            _createClass(Collapse, [{
                key: 'toggle',
                value: function toggle() {
                    if ($(this._element).hasClass(ClassName.SHOW)) {
                        this.hide();
                    } else {
                        this.show();
                    }
                }
            }, {
                key: 'show',
                value: function show() {
                    var _this = this;
                    if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
                        return;
                    }
                    var actives = void 0;
                    var activesData = void 0;
                    if (this._parent) {
                        actives = $.makeArray($(this._parent).find(Selector.ACTIVES).filter('[data-parent="' + this._config.parent + '"]'));
                        if (actives.length === 0) {
                            actives = null;
                        }
                    }
                    if (actives) {
                        activesData = $(actives).not(this._selector).data(DATA_KEY);
                        if (activesData && activesData._isTransitioning) {
                            return;
                        }
                    }
                    var startEvent = $.Event(Event.SHOW);
                    $(this._element).trigger(startEvent);
                    if (startEvent.isDefaultPrevented()) {
                        return;
                    }
                    if (actives) {
                        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');
                        if (!activesData) {
                            $(actives).data(DATA_KEY, null);
                        }
                    }
                    var dimension = this._getDimension();
                    $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
                    this._element.style[dimension] = 0;
                    if (this._triggerArray.length > 0) {
                        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
                    }
                    this.setTransitioning(true);
                    var complete = function complete() {
                        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
                        _this._element.style[dimension] = '';
                        _this.setTransitioning(false);
                        $(_this._element).trigger(Event.SHOWN);
                    };
                    var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
                    var scrollSize = 'scroll' + capitalizedDimension;
                    var transitionDuration = _util2.default.getTransitionDurationFromElement(this._element);
                    $(this._element).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                    this._element.style[dimension] = this._element[scrollSize] + 'px';
                }
            }, {
                key: 'hide',
                value: function hide() {
                    var _this2 = this;
                    if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
                        return;
                    }
                    var startEvent = $.Event(Event.HIDE);
                    $(this._element).trigger(startEvent);
                    if (startEvent.isDefaultPrevented()) {
                        return;
                    }
                    var dimension = this._getDimension();
                    this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + 'px';
                    _util2.default.reflow(this._element);
                    $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);
                    if (this._triggerArray.length > 0) {
                        for (var i = 0; i < this._triggerArray.length; i++) {
                            var trigger = this._triggerArray[i];
                            var selector = _util2.default.getSelectorFromElement(trigger);
                            if (selector !== null) {
                                var $elem = $(selector);
                                if (!$elem.hasClass(ClassName.SHOW)) {
                                    $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
                                }
                            }
                        }
                    }
                    this.setTransitioning(true);
                    var complete = function complete() {
                        _this2.setTransitioning(false);
                        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
                    };
                    this._element.style[dimension] = '';
                    var transitionDuration = _util2.default.getTransitionDurationFromElement(this._element);
                    $(this._element).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                }
            }, {
                key: 'setTransitioning',
                value: function setTransitioning(isTransitioning) {
                    this._isTransitioning = isTransitioning;
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    $.removeData(this._element, DATA_KEY);
                    this._config = null;
                    this._parent = null;
                    this._element = null;
                    this._triggerArray = null;
                    this._isTransitioning = null;
                }
            }, {
                key: '_getConfig',
                value: function _getConfig(config) {
                    config = _extends({}, Default, config);
                    config.toggle = Boolean(config.toggle);
                    _util2.default.typeCheckConfig(NAME, config, DefaultType);
                    return config;
                }
            }, {
                key: '_getDimension',
                value: function _getDimension() {
                    var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
                    return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
                }
            }, {
                key: '_getParent',
                value: function _getParent() {
                    var _this3 = this;
                    var parent = null;
                    if (_util2.default.isElement(this._config.parent)) {
                        parent = this._config.parent;
                        if (typeof this._config.parent.jquery !== 'undefined') {
                            parent = this._config.parent[0];
                        }
                    } else {
                        parent = $(this._config.parent)[0];
                    }
                    var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
                    $(parent).find(selector).each(function(i, element) {
                        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
                    });
                    return parent;
                }
            }, {
                key: '_addAriaAndCollapsedClass',
                value: function _addAriaAndCollapsedClass(element, triggerArray) {
                    if (element) {
                        var isOpen = $(element).hasClass(ClassName.SHOW);
                        if (triggerArray.length > 0) {
                            $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
                        }
                    }
                }
            }], [{
                key: '_getTargetFromElement',
                value: function _getTargetFromElement(element) {
                    var selector = _util2.default.getSelectorFromElement(element);
                    return selector ? $(selector)[0] : null;
                }
            }, {
                key: '_jQueryInterface',
                value: function _jQueryInterface(config) {
                    return this.each(function() {
                        var $this = $(this);
                        var data = $this.data(DATA_KEY);
                        var _config = _extends({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);
                        if (!data && _config.toggle && /show|hide/.test(config)) {
                            _config.toggle = false;
                        }
                        if (!data) {
                            data = new Collapse(this, _config);
                            $this.data(DATA_KEY, data);
                        }
                        if (typeof config === 'string') {
                            if (typeof data[config] === 'undefined') {
                                throw new TypeError('No method named "' + config + '"');
                            }
                            data[config]();
                        }
                    });
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }, {
                key: 'Default',
                get: function get() {
                    return Default;
                }
            }]);
            return Collapse;
        }();
        $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
            if (event.currentTarget.tagName === 'A') {
                event.preventDefault();
            }
            var $trigger = $(this);
            var selector = _util2.default.getSelectorFromElement(this);
            $(selector).each(function() {
                var $target = $(this);
                var data = $target.data(DATA_KEY);
                var config = data ? 'toggle' : $trigger.data();
                Collapse._jQueryInterface.call($target, config);
            });
        });
        $.fn[NAME] = Collapse._jQueryInterface;
        $.fn[NAME].Constructor = Collapse;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return Collapse._jQueryInterface;
        };
        return Collapse;
    }(_jquery2.default);
    exports.default = Collapse;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Modal = function($) {
        var NAME = 'modal';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.modal';
        var EVENT_KEY = '.' + DATA_KEY;
        var DATA_API_KEY = '.data-api';
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var ESCAPE_KEYCODE = 27;
        var Default = {
            backdrop: true,
            keyboard: true,
            focus: true,
            show: true
        };
        var DefaultType = {
            backdrop: '(boolean|string)',
            keyboard: 'boolean',
            focus: 'boolean',
            show: 'boolean'
        };
        var Event = {
            HIDE: 'hide' + EVENT_KEY,
            HIDDEN: 'hidden' + EVENT_KEY,
            SHOW: 'show' + EVENT_KEY,
            SHOWN: 'shown' + EVENT_KEY,
            FOCUSIN: 'focusin' + EVENT_KEY,
            RESIZE: 'resize' + EVENT_KEY,
            CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,
            KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,
            MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,
            MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,
            CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
            SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
            BACKDROP: 'modal-backdrop',
            OPEN: 'modal-open',
            FADE: 'fade',
            SHOW: 'show'
        };
        var Selector = {
            DIALOG: '.modal-dialog',
            DATA_TOGGLE: '[data-toggle="modal"]',
            DATA_DISMISS: '[data-dismiss="modal"]',
            FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
            STICKY_CONTENT: '.sticky-top',
            NAVBAR_TOGGLER: '.navbar-toggler'
        };
        var Modal = function() {
            function Modal(element, config) {
                _classCallCheck(this, Modal);
                this._config = this._getConfig(config);
                this._element = element;
                this._dialog = $(element).find(Selector.DIALOG)[0];
                this._backdrop = null;
                this._isShown = false;
                this._isBodyOverflowing = false;
                this._ignoreBackdropClick = false;
                this._scrollbarWidth = 0;
            }
            _createClass(Modal, [{
                key: 'toggle',
                value: function toggle(relatedTarget) {
                    return this._isShown ? this.hide() : this.show(relatedTarget);
                }
            }, {
                key: 'show',
                value: function show(relatedTarget) {
                    var _this = this;
                    if (this._isTransitioning || this._isShown) {
                        return;
                    }
                    if ($(this._element).hasClass(ClassName.FADE)) {
                        this._isTransitioning = true;
                    }
                    var showEvent = $.Event(Event.SHOW, {
                        relatedTarget: relatedTarget
                    });
                    $(this._element).trigger(showEvent);
                    if (this._isShown || showEvent.isDefaultPrevented()) {
                        return;
                    }
                    this._isShown = true;
                    this._checkScrollbar();
                    this._setScrollbar();
                    this._adjustDialog();
                    $(document.body).addClass(ClassName.OPEN);
                    this._setEscapeEvent();
                    this._setResizeEvent();
                    $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function(event) {
                        return _this.hide(event);
                    });
                    $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function() {
                        $(_this._element).one(Event.MOUSEUP_DISMISS, function(event) {
                            if ($(event.target).is(_this._element)) {
                                _this._ignoreBackdropClick = true;
                            }
                        });
                    });
                    this._showBackdrop(function() {
                        return _this._showElement(relatedTarget);
                    });
                }
            }, {
                key: 'hide',
                value: function hide(event) {
                    var _this2 = this;
                    if (event) {
                        event.preventDefault();
                    }
                    if (this._isTransitioning || !this._isShown) {
                        return;
                    }
                    var hideEvent = $.Event(Event.HIDE);
                    $(this._element).trigger(hideEvent);
                    if (!this._isShown || hideEvent.isDefaultPrevented()) {
                        return;
                    }
                    this._isShown = false;
                    var transition = $(this._element).hasClass(ClassName.FADE);
                    if (transition) {
                        this._isTransitioning = true;
                    }
                    this._setEscapeEvent();
                    this._setResizeEvent();
                    $(document).off(Event.FOCUSIN);
                    $(this._element).removeClass(ClassName.SHOW);
                    $(this._element).off(Event.CLICK_DISMISS);
                    $(this._dialog).off(Event.MOUSEDOWN_DISMISS);
                    if (transition) {
                        var transitionDuration = _util2.default.getTransitionDurationFromElement(this._element);
                        $(this._element).one(_util2.default.TRANSITION_END, function(event) {
                            return _this2._hideModal(event);
                        }).emulateTransitionEnd(transitionDuration);
                    } else {
                        this._hideModal();
                    }
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    $.removeData(this._element, DATA_KEY);
                    $(window, document, this._element, this._backdrop).off(EVENT_KEY);
                    this._config = null;
                    this._element = null;
                    this._dialog = null;
                    this._backdrop = null;
                    this._isShown = null;
                    this._isBodyOverflowing = null;
                    this._ignoreBackdropClick = null;
                    this._scrollbarWidth = null;
                }
            }, {
                key: 'handleUpdate',
                value: function handleUpdate() {
                    this._adjustDialog();
                }
            }, {
                key: '_getConfig',
                value: function _getConfig(config) {
                    config = _extends({}, Default, config);
                    _util2.default.typeCheckConfig(NAME, config, DefaultType);
                    return config;
                }
            }, {
                key: '_showElement',
                value: function _showElement(relatedTarget) {
                    var _this3 = this;
                    var transition = $(this._element).hasClass(ClassName.FADE);
                    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
                        document.body.appendChild(this._element);
                    }
                    this._element.style.display = 'block';
                    this._element.removeAttribute('aria-hidden');
                    this._element.scrollTop = 0;
                    if (transition) {
                        _util2.default.reflow(this._element);
                    }
                    $(this._element).addClass(ClassName.SHOW);
                    if (this._config.focus) {
                        this._enforceFocus();
                    }
                    var shownEvent = $.Event(Event.SHOWN, {
                        relatedTarget: relatedTarget
                    });
                    var transitionComplete = function transitionComplete() {
                        if (_this3._config.focus) {
                            _this3._element.focus();
                        }
                        _this3._isTransitioning = false;
                        $(_this3._element).trigger(shownEvent);
                    };
                    if (transition) {
                        var transitionDuration = _util2.default.getTransitionDurationFromElement(this._element);
                        $(this._dialog).one(_util2.default.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
                    } else {
                        transitionComplete();
                    }
                }
            }, {
                key: '_enforceFocus',
                value: function _enforceFocus() {
                    var _this4 = this;
                    $(document).off(Event.FOCUSIN).on(Event.FOCUSIN, function(event) {
                        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
                            _this4._element.focus();
                        }
                    });
                }
            }, {
                key: '_setEscapeEvent',
                value: function _setEscapeEvent() {
                    var _this5 = this;
                    if (this._isShown && this._config.keyboard) {
                        $(this._element).on(Event.KEYDOWN_DISMISS, function(event) {
                            if (event.which === ESCAPE_KEYCODE) {
                                event.preventDefault();
                                _this5.hide();
                            }
                        });
                    } else if (!this._isShown) {
                        $(this._element).off(Event.KEYDOWN_DISMISS);
                    }
                }
            }, {
                key: '_setResizeEvent',
                value: function _setResizeEvent() {
                    var _this6 = this;
                    if (this._isShown) {
                        $(window).on(Event.RESIZE, function(event) {
                            return _this6.handleUpdate(event);
                        });
                    } else {
                        $(window).off(Event.RESIZE);
                    }
                }
            }, {
                key: '_hideModal',
                value: function _hideModal() {
                    var _this7 = this;
                    this._element.style.display = 'none';
                    this._element.setAttribute('aria-hidden', true);
                    this._isTransitioning = false;
                    this._showBackdrop(function() {
                        $(document.body).removeClass(ClassName.OPEN);
                        _this7._resetAdjustments();
                        _this7._resetScrollbar();
                        $(_this7._element).trigger(Event.HIDDEN);
                    });
                }
            }, {
                key: '_removeBackdrop',
                value: function _removeBackdrop() {
                    if (this._backdrop) {
                        $(this._backdrop).remove();
                        this._backdrop = null;
                    }
                }
            }, {
                key: '_showBackdrop',
                value: function _showBackdrop(callback) {
                    var _this8 = this;
                    var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';
                    if (this._isShown && this._config.backdrop) {
                        this._backdrop = document.createElement('div');
                        this._backdrop.className = ClassName.BACKDROP;
                        if (animate) {
                            $(this._backdrop).addClass(animate);
                        }
                        $(this._backdrop).appendTo(document.body);
                        $(this._element).on(Event.CLICK_DISMISS, function(event) {
                            if (_this8._ignoreBackdropClick) {
                                _this8._ignoreBackdropClick = false;
                                return;
                            }
                            if (event.target !== event.currentTarget) {
                                return;
                            }
                            if (_this8._config.backdrop === 'static') {
                                _this8._element.focus();
                            } else {
                                _this8.hide();
                            }
                        });
                        if (animate) {
                            _util2.default.reflow(this._backdrop);
                        }
                        $(this._backdrop).addClass(ClassName.SHOW);
                        if (!callback) {
                            return;
                        }
                        if (!animate) {
                            callback();
                            return;
                        }
                        var backdropTransitionDuration = _util2.default.getTransitionDurationFromElement(this._backdrop);
                        $(this._backdrop).one(_util2.default.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
                    } else if (!this._isShown && this._backdrop) {
                        $(this._backdrop).removeClass(ClassName.SHOW);
                        var callbackRemove = function callbackRemove() {
                            _this8._removeBackdrop();
                            if (callback) {
                                callback();
                            }
                        };
                        if ($(this._element).hasClass(ClassName.FADE)) {
                            var _backdropTransitionDuration = _util2.default.getTransitionDurationFromElement(this._backdrop);
                            $(this._backdrop).one(_util2.default.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
                        } else {
                            callbackRemove();
                        }
                    } else if (callback) {
                        callback();
                    }
                }
            }, {
                key: '_adjustDialog',
                value: function _adjustDialog() {
                    var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                    if (!this._isBodyOverflowing && isModalOverflowing) {
                        this._element.style.paddingLeft = this._scrollbarWidth + 'px';
                    }
                    if (this._isBodyOverflowing && !isModalOverflowing) {
                        this._element.style.paddingRight = this._scrollbarWidth + 'px';
                    }
                }
            }, {
                key: '_resetAdjustments',
                value: function _resetAdjustments() {
                    this._element.style.paddingLeft = '';
                    this._element.style.paddingRight = '';
                }
            }, {
                key: '_checkScrollbar',
                value: function _checkScrollbar() {
                    var rect = document.body.getBoundingClientRect();
                    this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
                    this._scrollbarWidth = this._getScrollbarWidth();
                }
            }, {
                key: '_setScrollbar',
                value: function _setScrollbar() {
                    var _this9 = this;
                    if (this._isBodyOverflowing) {
                        $(Selector.FIXED_CONTENT).each(function(index, element) {
                            var actualPadding = $(element)[0].style.paddingRight;
                            var calculatedPadding = $(element).css('padding-right');
                            $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + 'px');
                        });
                        $(Selector.STICKY_CONTENT).each(function(index, element) {
                            var actualMargin = $(element)[0].style.marginRight;
                            var calculatedMargin = $(element).css('margin-right');
                            $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + 'px');
                        });
                        $(Selector.NAVBAR_TOGGLER).each(function(index, element) {
                            var actualMargin = $(element)[0].style.marginRight;
                            var calculatedMargin = $(element).css('margin-right');
                            $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + 'px');
                        });
                        var actualPadding = document.body.style.paddingRight;
                        var calculatedPadding = $(document.body).css('padding-right');
                        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + 'px');
                    }
                }
            }, {
                key: '_resetScrollbar',
                value: function _resetScrollbar() {
                    $(Selector.FIXED_CONTENT).each(function(index, element) {
                        var padding = $(element).data('padding-right');
                        if (typeof padding !== 'undefined') {
                            $(element).css('padding-right', padding).removeData('padding-right');
                        }
                    });
                    $(Selector.STICKY_CONTENT + ', ' + Selector.NAVBAR_TOGGLER).each(function(index, element) {
                        var margin = $(element).data('margin-right');
                        if (typeof margin !== 'undefined') {
                            $(element).css('margin-right', margin).removeData('margin-right');
                        }
                    });
                    var padding = $(document.body).data('padding-right');
                    if (typeof padding !== 'undefined') {
                        $(document.body).css('padding-right', padding).removeData('padding-right');
                    }
                }
            }, {
                key: '_getScrollbarWidth',
                value: function _getScrollbarWidth() {
                    var scrollDiv = document.createElement('div');
                    scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
                    document.body.appendChild(scrollDiv);
                    var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
                    document.body.removeChild(scrollDiv);
                    return scrollbarWidth;
                }
            }], [{
                key: '_jQueryInterface',
                value: function _jQueryInterface(config, relatedTarget) {
                    return this.each(function() {
                        var data = $(this).data(DATA_KEY);
                        var _config = _extends({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);
                        if (!data) {
                            data = new Modal(this, _config);
                            $(this).data(DATA_KEY, data);
                        }
                        if (typeof config === 'string') {
                            if (typeof data[config] === 'undefined') {
                                throw new TypeError('No method named "' + config + '"');
                            }
                            data[config](relatedTarget);
                        } else if (_config.show) {
                            data.show(relatedTarget);
                        }
                    });
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }, {
                key: 'Default',
                get: function get() {
                    return Default;
                }
            }]);
            return Modal;
        }();
        $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
            var _this10 = this;
            var target = void 0;
            var selector = _util2.default.getSelectorFromElement(this);
            if (selector) {
                target = $(selector)[0];
            }
            var config = $(target).data(DATA_KEY) ? 'toggle' : _extends({}, $(target).data(), $(this).data());
            if (this.tagName === 'A' || this.tagName === 'AREA') {
                event.preventDefault();
            }
            var $target = $(target).one(Event.SHOW, function(showEvent) {
                if (showEvent.isDefaultPrevented()) {
                    return;
                }
                $target.one(Event.HIDDEN, function() {
                    if ($(_this10).is(':visible')) {
                        _this10.focus();
                    }
                });
            });
            Modal._jQueryInterface.call($(target), config, this);
        });
        $.fn[NAME] = Modal._jQueryInterface;
        $.fn[NAME].Constructor = Modal;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return Modal._jQueryInterface;
        };
        return Modal;
    }(_jquery2.default);
    exports.default = Modal;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var ScrollSpy = function($) {
        var NAME = 'scrollspy';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.scrollspy';
        var EVENT_KEY = '.' + DATA_KEY;
        var DATA_API_KEY = '.data-api';
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var Default = {
            offset: 10,
            method: 'auto',
            target: ''
        };
        var DefaultType = {
            offset: 'number',
            method: 'string',
            target: '(string|element)'
        };
        var Event = {
            ACTIVATE: 'activate' + EVENT_KEY,
            SCROLL: 'scroll' + EVENT_KEY,
            LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
            DROPDOWN_ITEM: 'dropdown-item',
            DROPDOWN_MENU: 'dropdown-menu',
            ACTIVE: 'active'
        };
        var Selector = {
            DATA_SPY: '[data-spy="scroll"]',
            ACTIVE: '.active',
            NAV_LIST_GROUP: '.nav, .list-group',
            NAV_LINKS: '.nav-link',
            NAV_ITEMS: '.nav-item',
            LIST_ITEMS: '.list-group-item',
            DROPDOWN: '.dropdown',
            DROPDOWN_ITEMS: '.dropdown-item',
            DROPDOWN_TOGGLE: '.dropdown-toggle'
        };
        var OffsetMethod = {
            OFFSET: 'offset',
            POSITION: 'position'
        };
        var ScrollSpy = function() {
            function ScrollSpy(element, config) {
                var _this = this;
                _classCallCheck(this, ScrollSpy);
                this._element = element;
                this._scrollElement = element.tagName === 'BODY' ? window : element;
                this._config = this._getConfig(config);
                this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.LIST_ITEMS + ',') + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);
                this._offsets = [];
                this._targets = [];
                this._activeTarget = null;
                this._scrollHeight = 0;
                $(this._scrollElement).on(Event.SCROLL, function(event) {
                    return _this._process(event);
                });
                this.refresh();
                this._process();
            }
            _createClass(ScrollSpy, [{
                key: 'refresh',
                value: function refresh() {
                    var _this2 = this;
                    var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
                    var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
                    var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
                    this._offsets = [];
                    this._targets = [];
                    this._scrollHeight = this._getScrollHeight();
                    var targets = $.makeArray($(this._selector));
                    targets.map(function(element) {
                        var target = void 0;
                        var targetSelector = _util2.default.getSelectorFromElement(element);
                        if (targetSelector) {
                            target = $(targetSelector)[0];
                        }
                        if (target) {
                            var targetBCR = target.getBoundingClientRect();
                            if (targetBCR.width || targetBCR.height) {
                                return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
                            }
                        }
                        return null;
                    }).filter(function(item) {
                        return item;
                    }).sort(function(a, b) {
                        return a[0] - b[0];
                    }).forEach(function(item) {
                        _this2._offsets.push(item[0]);
                        _this2._targets.push(item[1]);
                    });
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    $.removeData(this._element, DATA_KEY);
                    $(this._scrollElement).off(EVENT_KEY);
                    this._element = null;
                    this._scrollElement = null;
                    this._config = null;
                    this._selector = null;
                    this._offsets = null;
                    this._targets = null;
                    this._activeTarget = null;
                    this._scrollHeight = null;
                }
            }, {
                key: '_getConfig',
                value: function _getConfig(config) {
                    config = _extends({}, Default, config);
                    if (typeof config.target !== 'string') {
                        var id = $(config.target).attr('id');
                        if (!id) {
                            id = _util2.default.getUID(NAME);
                            $(config.target).attr('id', id);
                        }
                        config.target = '#' + id;
                    }
                    _util2.default.typeCheckConfig(NAME, config, DefaultType);
                    return config;
                }
            }, {
                key: '_getScrollTop',
                value: function _getScrollTop() {
                    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
                }
            }, {
                key: '_getScrollHeight',
                value: function _getScrollHeight() {
                    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
                }
            }, {
                key: '_getOffsetHeight',
                value: function _getOffsetHeight() {
                    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
                }
            }, {
                key: '_process',
                value: function _process() {
                    var scrollTop = this._getScrollTop() + this._config.offset;
                    var scrollHeight = this._getScrollHeight();
                    var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
                    if (this._scrollHeight !== scrollHeight) {
                        this.refresh();
                    }
                    if (scrollTop >= maxScroll) {
                        var target = this._targets[this._targets.length - 1];
                        if (this._activeTarget !== target) {
                            this._activate(target);
                        }
                        return;
                    }
                    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
                        this._activeTarget = null;
                        this._clear();
                        return;
                    }
                    for (var i = this._offsets.length; i--;) {
                        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);
                        if (isActiveTarget) {
                            this._activate(this._targets[i]);
                        }
                    }
                }
            }, {
                key: '_activate',
                value: function _activate(target) {
                    this._activeTarget = target;
                    this._clear();
                    var queries = this._selector.split(',');
                    queries = queries.map(function(selector) {
                        return selector + '[data-target="' + target + '"],' + (selector + '[href="' + target + '"]');
                    });
                    var $link = $(queries.join(','));
                    if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
                        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
                        $link.addClass(ClassName.ACTIVE);
                    } else {
                        $link.addClass(ClassName.ACTIVE);
                        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ', ' + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE);
                        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
                    }
                    $(this._scrollElement).trigger(Event.ACTIVATE, {
                        relatedTarget: target
                    });
                }
            }, {
                key: '_clear',
                value: function _clear() {
                    $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
                }
            }], [{
                key: '_jQueryInterface',
                value: function _jQueryInterface(config) {
                    return this.each(function() {
                        var data = $(this).data(DATA_KEY);
                        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;
                        if (!data) {
                            data = new ScrollSpy(this, _config);
                            $(this).data(DATA_KEY, data);
                        }
                        if (typeof config === 'string') {
                            if (typeof data[config] === 'undefined') {
                                throw new TypeError('No method named "' + config + '"');
                            }
                            data[config]();
                        }
                    });
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }, {
                key: 'Default',
                get: function get() {
                    return Default;
                }
            }]);
            return ScrollSpy;
        }();
        $(window).on(Event.LOAD_DATA_API, function() {
            var scrollSpys = $.makeArray($(Selector.DATA_SPY));
            for (var i = scrollSpys.length; i--;) {
                var $spy = $(scrollSpys[i]);
                ScrollSpy._jQueryInterface.call($spy, $spy.data());
            }
        });
        $.fn[NAME] = ScrollSpy._jQueryInterface;
        $.fn[NAME].Constructor = ScrollSpy;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return ScrollSpy._jQueryInterface;
        };
        return ScrollSpy;
    }(_jquery2.default);
    exports.default = ScrollSpy;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Tab = function($) {
        var NAME = 'tab';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.tab';
        var EVENT_KEY = '.' + DATA_KEY;
        var DATA_API_KEY = '.data-api';
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var Event = {
            HIDE: 'hide' + EVENT_KEY,
            HIDDEN: 'hidden' + EVENT_KEY,
            SHOW: 'show' + EVENT_KEY,
            SHOWN: 'shown' + EVENT_KEY,
            CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
            DROPDOWN_MENU: 'dropdown-menu',
            ACTIVE: 'active',
            DISABLED: 'disabled',
            FADE: 'fade',
            SHOW: 'show'
        };
        var Selector = {
            DROPDOWN: '.dropdown',
            NAV_LIST_GROUP: '.nav, .list-group',
            ACTIVE: '.active',
            ACTIVE_UL: '> li > .active',
            DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
            DROPDOWN_TOGGLE: '.dropdown-toggle',
            DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
        };
        var Tab = function() {
            function Tab(element) {
                _classCallCheck(this, Tab);
                this._element = element;
            }
            _createClass(Tab, [{
                key: 'show',
                value: function show() {
                    var _this = this;
                    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
                        return;
                    }
                    var target = void 0;
                    var previous = void 0;
                    var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
                    var selector = _util2.default.getSelectorFromElement(this._element);
                    if (listElement) {
                        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
                        previous = $.makeArray($(listElement).find(itemSelector));
                        previous = previous[previous.length - 1];
                    }
                    var hideEvent = $.Event(Event.HIDE, {
                        relatedTarget: this._element
                    });
                    var showEvent = $.Event(Event.SHOW, {
                        relatedTarget: previous
                    });
                    if (previous) {
                        $(previous).trigger(hideEvent);
                    }
                    $(this._element).trigger(showEvent);
                    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
                        return;
                    }
                    if (selector) {
                        target = $(selector)[0];
                    }
                    this._activate(this._element, listElement);
                    var complete = function complete() {
                        var hiddenEvent = $.Event(Event.HIDDEN, {
                            relatedTarget: _this._element
                        });
                        var shownEvent = $.Event(Event.SHOWN, {
                            relatedTarget: previous
                        });
                        $(previous).trigger(hiddenEvent);
                        $(_this._element).trigger(shownEvent);
                    };
                    if (target) {
                        this._activate(target, target.parentNode, complete);
                    } else {
                        complete();
                    }
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    $.removeData(this._element, DATA_KEY);
                    this._element = null;
                }
            }, {
                key: '_activate',
                value: function _activate(element, container, callback) {
                    var _this2 = this;
                    var activeElements = void 0;
                    if (container.nodeName === 'UL') {
                        activeElements = $(container).find(Selector.ACTIVE_UL);
                    } else {
                        activeElements = $(container).children(Selector.ACTIVE);
                    }
                    var active = activeElements[0];
                    var isTransitioning = callback && active && $(active).hasClass(ClassName.FADE);
                    var complete = function complete() {
                        return _this2._transitionComplete(element, active, callback);
                    };
                    if (active && isTransitioning) {
                        var transitionDuration = _util2.default.getTransitionDurationFromElement(active);
                        $(active).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                    } else {
                        complete();
                    }
                }
            }, {
                key: '_transitionComplete',
                value: function _transitionComplete(element, active, callback) {
                    if (active) {
                        $(active).removeClass(ClassName.SHOW + ' ' + ClassName.ACTIVE);
                        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];
                        if (dropdownChild) {
                            $(dropdownChild).removeClass(ClassName.ACTIVE);
                        }
                        if (active.getAttribute('role') === 'tab') {
                            active.setAttribute('aria-selected', false);
                        }
                    }
                    $(element).addClass(ClassName.ACTIVE);
                    if (element.getAttribute('role') === 'tab') {
                        element.setAttribute('aria-selected', true);
                    }
                    _util2.default.reflow(element);
                    $(element).addClass(ClassName.SHOW);
                    if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
                        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];
                        if (dropdownElement) {
                            $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
                        }
                        element.setAttribute('aria-expanded', true);
                    }
                    if (callback) {
                        callback();
                    }
                }
            }], [{
                key: '_jQueryInterface',
                value: function _jQueryInterface(config) {
                    return this.each(function() {
                        var $this = $(this);
                        var data = $this.data(DATA_KEY);
                        if (!data) {
                            data = new Tab(this);
                            $this.data(DATA_KEY, data);
                        }
                        if (typeof config === 'string') {
                            if (typeof data[config] === 'undefined') {
                                throw new TypeError('No method named "' + config + '"');
                            }
                            data[config]();
                        }
                    });
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }]);
            return Tab;
        }();
        $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
            event.preventDefault();
            Tab._jQueryInterface.call($(this), 'show');
        });
        $.fn[NAME] = Tab._jQueryInterface;
        $.fn[NAME].Constructor = Tab;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return Tab._jQueryInterface;
        };
        return Tab;
    }(_jquery2.default);
    exports.default = Tab;
}), (function(module, exports, __webpack_require__) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _jquery = __webpack_require__(27);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _popper = __webpack_require__(43);
    var _popper2 = _interopRequireDefault(_popper);
    var _util = __webpack_require__(36);
    var _util2 = _interopRequireDefault(_util);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Tooltip = function($) {
        var NAME = 'tooltip';
        var VERSION = '4.1.0';
        var DATA_KEY = 'bs.tooltip';
        var EVENT_KEY = '.' + DATA_KEY;
        var JQUERY_NO_CONFLICT = $.fn[NAME];
        var CLASS_PREFIX = 'bs-tooltip';
        var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');
        var DefaultType = {
            animation: 'boolean',
            template: 'string',
            title: '(string|element|function)',
            trigger: 'string',
            delay: '(number|object)',
            html: 'boolean',
            selector: '(string|boolean)',
            placement: '(string|function)',
            offset: '(number|string)',
            container: '(string|element|boolean)',
            fallbackPlacement: '(string|array)',
            boundary: '(string|element)'
        };
        var AttachmentMap = {
            AUTO: 'auto',
            TOP: 'top',
            RIGHT: 'right',
            BOTTOM: 'bottom',
            LEFT: 'left'
        };
        var Default = {
            animation: true,
            template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
            trigger: 'hover focus',
            title: '',
            delay: 0,
            html: false,
            selector: false,
            placement: 'top',
            offset: 0,
            container: false,
            fallbackPlacement: 'flip',
            boundary: 'scrollParent'
        };
        var HoverState = {
            SHOW: 'show',
            OUT: 'out'
        };
        var Event = {
            HIDE: 'hide' + EVENT_KEY,
            HIDDEN: 'hidden' + EVENT_KEY,
            SHOW: 'show' + EVENT_KEY,
            SHOWN: 'shown' + EVENT_KEY,
            INSERTED: 'inserted' + EVENT_KEY,
            CLICK: 'click' + EVENT_KEY,
            FOCUSIN: 'focusin' + EVENT_KEY,
            FOCUSOUT: 'focusout' + EVENT_KEY,
            MOUSEENTER: 'mouseenter' + EVENT_KEY,
            MOUSELEAVE: 'mouseleave' + EVENT_KEY
        };
        var ClassName = {
            FADE: 'fade',
            SHOW: 'show'
        };
        var Selector = {
            TOOLTIP: '.tooltip',
            TOOLTIP_INNER: '.tooltip-inner',
            ARROW: '.arrow'
        };
        var Trigger = {
            HOVER: 'hover',
            FOCUS: 'focus',
            CLICK: 'click',
            MANUAL: 'manual'
        };
        var Tooltip = function() {
            function Tooltip(element, config) {
                _classCallCheck(this, Tooltip);
                if (typeof _popper2.default === 'undefined') {
                    throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');
                }
                this._isEnabled = true;
                this._timeout = 0;
                this._hoverState = '';
                this._activeTrigger = {};
                this._popper = null;
                this.element = element;
                this.config = this._getConfig(config);
                this.tip = null;
                this._setListeners();
            }
            _createClass(Tooltip, [{
                key: 'enable',
                value: function enable() {
                    this._isEnabled = true;
                }
            }, {
                key: 'disable',
                value: function disable() {
                    this._isEnabled = false;
                }
            }, {
                key: 'toggleEnabled',
                value: function toggleEnabled() {
                    this._isEnabled = !this._isEnabled;
                }
            }, {
                key: 'toggle',
                value: function toggle(event) {
                    if (!this._isEnabled) {
                        return;
                    }
                    if (event) {
                        var dataKey = this.constructor.DATA_KEY;
                        var context = $(event.currentTarget).data(dataKey);
                        if (!context) {
                            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                            $(event.currentTarget).data(dataKey, context);
                        }
                        context._activeTrigger.click = !context._activeTrigger.click;
                        if (context._isWithActiveTrigger()) {
                            context._enter(null, context);
                        } else {
                            context._leave(null, context);
                        }
                    } else {
                        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
                            this._leave(null, this);
                            return;
                        }
                        this._enter(null, this);
                    }
                }
            }, {
                key: 'dispose',
                value: function dispose() {
                    clearTimeout(this._timeout);
                    $.removeData(this.element, this.constructor.DATA_KEY);
                    $(this.element).off(this.constructor.EVENT_KEY);
                    $(this.element).closest('.modal').off('hide.bs.modal');
                    if (this.tip) {
                        $(this.tip).remove();
                    }
                    this._isEnabled = null;
                    this._timeout = null;
                    this._hoverState = null;
                    this._activeTrigger = null;
                    if (this._popper !== null) {
                        this._popper.destroy();
                    }
                    this._popper = null;
                    this.element = null;
                    this.config = null;
                    this.tip = null;
                }
            }, {
                key: 'show',
                value: function show() {
                    var _this = this;
                    if ($(this.element).css('display') === 'none') {
                        throw new Error('Please use show on visible elements');
                    }
                    var showEvent = $.Event(this.constructor.Event.SHOW);
                    if (this.isWithContent() && this._isEnabled) {
                        $(this.element).trigger(showEvent);
                        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);
                        if (showEvent.isDefaultPrevented() || !isInTheDom) {
                            return;
                        }
                        var tip = this.getTipElement();
                        var tipId = _util2.default.getUID(this.constructor.NAME);
                        tip.setAttribute('id', tipId);
                        this.element.setAttribute('aria-describedby', tipId);
                        this.setContent();
                        if (this.config.animation) {
                            $(tip).addClass(ClassName.FADE);
                        }
                        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;
                        var attachment = this._getAttachment(placement);
                        this.addAttachmentClass(attachment);
                        var container = this.config.container === false ? document.body : $(this.config.container);
                        $(tip).data(this.constructor.DATA_KEY, this);
                        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
                            $(tip).appendTo(container);
                        }
                        $(this.element).trigger(this.constructor.Event.INSERTED);
                        this._popper = new _popper2.default(this.element, tip, {
                            placement: attachment,
                            modifiers: {
                                offset: {
                                    offset: this.config.offset
                                },
                                flip: {
                                    behavior: this.config.fallbackPlacement
                                },
                                arrow: {
                                    element: Selector.ARROW
                                },
                                preventOverflow: {
                                    boundariesElement: this.config.boundary
                                }
                            },
                            onCreate: function onCreate(data) {
                                if (data.originalPlacement !== data.placement) {
                                    _this._handlePopperPlacementChange(data);
                                }
                            },
                            onUpdate: function onUpdate(data) {
                                _this._handlePopperPlacementChange(data);
                            }
                        });
                        $(tip).addClass(ClassName.SHOW);
                        if ('ontouchstart' in document.documentElement) {
                            $(document.body).children().on('mouseover', null, $.noop);
                        }
                        var complete = function complete() {
                            if (_this.config.animation) {
                                _this._fixTransition();
                            }
                            var prevHoverState = _this._hoverState;
                            _this._hoverState = null;
                            $(_this.element).trigger(_this.constructor.Event.SHOWN);
                            if (prevHoverState === HoverState.OUT) {
                                _this._leave(null, _this);
                            }
                        };
                        if ($(this.tip).hasClass(ClassName.FADE)) {
                            var transitionDuration = _util2.default.getTransitionDurationFromElement(this.tip);
                            $(this.tip).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        } else {
                            complete();
                        }
                    }
                }
            }, {
                key: 'hide',
                value: function hide(callback) {
                    var _this2 = this;
                    var tip = this.getTipElement();
                    var hideEvent = $.Event(this.constructor.Event.HIDE);
                    var complete = function complete() {
                        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
                            tip.parentNode.removeChild(tip);
                        }
                        _this2._cleanTipClass();
                        _this2.element.removeAttribute('aria-describedby');
                        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
                        if (_this2._popper !== null) {
                            _this2._popper.destroy();
                        }
                        if (callback) {
                            callback();
                        }
                    };
                    $(this.element).trigger(hideEvent);
                    if (hideEvent.isDefaultPrevented()) {
                        return;
                    }
                    $(tip).removeClass(ClassName.SHOW);
                    if ('ontouchstart' in document.documentElement) {
                        $(document.body).children().off('mouseover', null, $.noop);
                    }
                    this._activeTrigger[Trigger.CLICK] = false;
                    this._activeTrigger[Trigger.FOCUS] = false;
                    this._activeTrigger[Trigger.HOVER] = false;
                    if ($(this.tip).hasClass(ClassName.FADE)) {
                        var transitionDuration = _util2.default.getTransitionDurationFromElement(tip);
                        $(tip).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                    } else {
                        complete();
                    }
                    this._hoverState = '';
                }
            }, {
                key: 'update',
                value: function update() {
                    if (this._popper !== null) {
                        this._popper.scheduleUpdate();
                    }
                }
            }, {
                key: 'isWithContent',
                value: function isWithContent() {
                    return Boolean(this.getTitle());
                }
            }, {
                key: 'addAttachmentClass',
                value: function addAttachmentClass(attachment) {
                    $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
                }
            }, {
                key: 'getTipElement',
                value: function getTipElement() {
                    this.tip = this.tip || $(this.config.template)[0];
                    return this.tip;
                }
            }, {
                key: 'setContent',
                value: function setContent() {
                    var $tip = $(this.getTipElement());
                    this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
                    $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
                }
            }, {
                key: 'setElementContent',
                value: function setElementContent($element, content) {
                    var html = this.config.html;
                    if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {
                        if (html) {
                            if (!$(content).parent().is($element)) {
                                $element.empty().append(content);
                            }
                        } else {
                            $element.text($(content).text());
                        }
                    } else {
                        $element[html ? 'html' : 'text'](content);
                    }
                }
            }, {
                key: 'getTitle',
                value: function getTitle() {
                    var title = this.element.getAttribute('data-original-title');
                    if (!title) {
                        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
                    }
                    return title;
                }
            }, {
                key: '_getAttachment',
                value: function _getAttachment(placement) {
                    return AttachmentMap[placement.toUpperCase()];
                }
            }, {
                key: '_setListeners',
                value: function _setListeners() {
                    var _this3 = this;
                    var triggers = this.config.trigger.split(' ');
                    triggers.forEach(function(trigger) {
                        if (trigger === 'click') {
                            $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function(event) {
                                return _this3.toggle(event);
                            });
                        } else if (trigger !== Trigger.MANUAL) {
                            var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
                            var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
                            $(_this3.element).on(eventIn, _this3.config.selector, function(event) {
                                return _this3._enter(event);
                            }).on(eventOut, _this3.config.selector, function(event) {
                                return _this3._leave(event);
                            });
                        }
                        $(_this3.element).closest('.modal').on('hide.bs.modal', function() {
                            return _this3.hide();
                        });
                    });
                    if (this.config.selector) {
                        this.config = _extends({}, this.config, {
                            trigger: 'manual',
                            selector: ''
                        });
                    } else {
                        this._fixTitle();
                    }
                }
            }, {
                key: '_fixTitle',
                value: function _fixTitle() {
                    var titleType = _typeof(this.element.getAttribute('data-original-title'));
                    if (this.element.getAttribute('title') || titleType !== 'string') {
                        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
                        this.element.setAttribute('title', '');
                    }
                }
            }, {
                key: '_enter',
                value: function _enter(event, context) {
                    var dataKey = this.constructor.DATA_KEY;
                    context = context || $(event.currentTarget).data(dataKey);
                    if (!context) {
                        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                        $(event.currentTarget).data(dataKey, context);
                    }
                    if (event) {
                        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
                    }
                    if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
                        context._hoverState = HoverState.SHOW;
                        return;
                    }
                    clearTimeout(context._timeout);
                    context._hoverState = HoverState.SHOW;
                    if (!context.config.delay || !context.config.delay.show) {
                        context.show();
                        return;
                    }
                    context._timeout = setTimeout(function() {
                        if (context._hoverState === HoverState.SHOW) {
                            context.show();
                        }
                    }, context.config.delay.show);
                }
            }, {
                key: '_leave',
                value: function _leave(event, context) {
                    var dataKey = this.constructor.DATA_KEY;
                    context = context || $(event.currentTarget).data(dataKey);
                    if (!context) {
                        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                        $(event.currentTarget).data(dataKey, context);
                    }
                    if (event) {
                        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
                    }
                    if (context._isWithActiveTrigger()) {
                        return;
                    }
                    clearTimeout(context._timeout);
                    context._hoverState = HoverState.OUT;
                    if (!context.config.delay || !context.config.delay.hide) {
                        context.hide();
                        return;
                    }
                    context._timeout = setTimeout(function() {
                        if (context._hoverState === HoverState.OUT) {
                            context.hide();
                        }
                    }, context.config.delay.hide);
                }
            }, {
                key: '_isWithActiveTrigger',
                value: function _isWithActiveTrigger() {
                    for (var trigger in this._activeTrigger) {
                        if (this._activeTrigger[trigger]) {
                            return true;
                        }
                    }
                    return false;
                }
            }, {
                key: '_getConfig',
                value: function _getConfig(config) {
                    config = _extends({}, this.constructor.Default, $(this.element).data(), config);
                    if (typeof config.delay === 'number') {
                        config.delay = {
                            show: config.delay,
                            hide: config.delay
                        };
                    }
                    if (typeof config.title === 'number') {
                        config.title = config.title.toString();
                    }
                    if (typeof config.content === 'number') {
                        config.content = config.content.toString();
                    }
                    _util2.default.typeCheckConfig(NAME, config, this.constructor.DefaultType);
                    return config;
                }
            }, {
                key: '_getDelegateConfig',
                value: function _getDelegateConfig() {
                    var config = {};
                    if (this.config) {
                        for (var key in this.config) {
                            if (this.constructor.Default[key] !== this.config[key]) {
                                config[key] = this.config[key];
                            }
                        }
                    }
                    return config;
                }
            }, {
                key: '_cleanTipClass',
                value: function _cleanTipClass() {
                    var $tip = $(this.getTipElement());
                    var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
                    if (tabClass !== null && tabClass.length > 0) {
                        $tip.removeClass(tabClass.join(''));
                    }
                }
            }, {
                key: '_handlePopperPlacementChange',
                value: function _handlePopperPlacementChange(data) {
                    this._cleanTipClass();
                    this.addAttachmentClass(this._getAttachment(data.placement));
                }
            }, {
                key: '_fixTransition',
                value: function _fixTransition() {
                    var tip = this.getTipElement();
                    var initConfigAnimation = this.config.animation;
                    if (tip.getAttribute('x-placement') !== null) {
                        return;
                    }
                    $(tip).removeClass(ClassName.FADE);
                    this.config.animation = false;
                    this.hide();
                    this.show();
                    this.config.animation = initConfigAnimation;
                }
            }], [{
                key: '_jQueryInterface',
                value: function _jQueryInterface(config) {
                    return this.each(function() {
                        var data = $(this).data(DATA_KEY);
                        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;
                        if (!data && /dispose|hide/.test(config)) {
                            return;
                        }
                        if (!data) {
                            data = new Tooltip(this, _config);
                            $(this).data(DATA_KEY, data);
                        }
                        if (typeof config === 'string') {
                            if (typeof data[config] === 'undefined') {
                                throw new TypeError('No method named "' + config + '"');
                            }
                            data[config]();
                        }
                    });
                }
            }, {
                key: 'VERSION',
                get: function get() {
                    return VERSION;
                }
            }, {
                key: 'Default',
                get: function get() {
                    return Default;
                }
            }, {
                key: 'NAME',
                get: function get() {
                    return NAME;
                }
            }, {
                key: 'DATA_KEY',
                get: function get() {
                    return DATA_KEY;
                }
            }, {
                key: 'Event',
                get: function get() {
                    return Event;
                }
            }, {
                key: 'EVENT_KEY',
                get: function get() {
                    return EVENT_KEY;
                }
            }, {
                key: 'DefaultType',
                get: function get() {
                    return DefaultType;
                }
            }]);
            return Tooltip;
        }();
        $.fn[NAME] = Tooltip._jQueryInterface;
        $.fn[NAME].Constructor = Tooltip;
        $.fn[NAME].noConflict = function() {
            $.fn[NAME] = JQUERY_NO_CONFLICT;
            return Tooltip._jQueryInterface;
        };
        return Tooltip;
    }(_jquery2.default, _popper2.default);
    exports.default = Tooltip;
}), (function(module, exports, __webpack_require__) {
    (function(global) {
        (function(global, factory) {
            true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global.Popper = factory());
        }(this, (function() {
            'use strict';
            var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
            var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
            var timeoutDuration = 0;
            for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
                if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
                    timeoutDuration = 1;
                    break;
                }
            }

            function microtaskDebounce(fn) {
                var called = false;
                return function() {
                    if (called) {
                        return;
                    }
                    called = true;
                    window.Promise.resolve().then(function() {
                        called = false;
                        fn();
                    });
                };
            }

            function taskDebounce(fn) {
                var scheduled = false;
                return function() {
                    if (!scheduled) {
                        scheduled = true;
                        setTimeout(function() {
                            scheduled = false;
                            fn();
                        }, timeoutDuration);
                    }
                };
            }
            var supportsMicroTasks = isBrowser && window.Promise;
            var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

            function isFunction(functionToCheck) {
                var getType = {};
                return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
            }

            function getStyleComputedProperty(element, property) {
                if (element.nodeType !== 1) {
                    return [];
                }
                var window = element.ownerDocument.defaultView;
                var css = window.getComputedStyle(element, null);
                return property ? css[property] : css;
            }

            function getParentNode(element) {
                if (element.nodeName === 'HTML') {
                    return element;
                }
                return element.parentNode || element.host;
            }

            function getScrollParent(element) {
                if (!element) {
                    return document.body;
                }
                switch (element.nodeName) {
                    case 'HTML':
                    case 'BODY':
                        return element.ownerDocument.body;
                    case '#document':
                        return element.body;
                }
                var _getStyleComputedProp = getStyleComputedProperty(element),
                    overflow = _getStyleComputedProp.overflow,
                    overflowX = _getStyleComputedProp.overflowX,
                    overflowY = _getStyleComputedProp.overflowY;
                if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
                    return element;
                }
                return getScrollParent(getParentNode(element));
            }
            var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
            var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

            function isIE(version) {
                if (version === 11) {
                    return isIE11;
                }
                if (version === 10) {
                    return isIE10;
                }
                return isIE11 || isIE10;
            }

            function getOffsetParent(element) {
                if (!element) {
                    return document.documentElement;
                }
                var noOffsetParent = isIE(10) ? document.body : null;
                var offsetParent = element.offsetParent || null;
                while (offsetParent === noOffsetParent && element.nextElementSibling) {
                    offsetParent = (element = element.nextElementSibling).offsetParent;
                }
                var nodeName = offsetParent && offsetParent.nodeName;
                if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
                    return element ? element.ownerDocument.documentElement : document.documentElement;
                }
                if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
                    return getOffsetParent(offsetParent);
                }
                return offsetParent;
            }

            function isOffsetContainer(element) {
                var nodeName = element.nodeName;
                if (nodeName === 'BODY') {
                    return false;
                }
                return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
            }

            function getRoot(node) {
                if (node.parentNode !== null) {
                    return getRoot(node.parentNode);
                }
                return node;
            }

            function findCommonOffsetParent(element1, element2) {
                if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
                    return document.documentElement;
                }
                var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
                var start = order ? element1 : element2;
                var end = order ? element2 : element1;
                var range = document.createRange();
                range.setStart(start, 0);
                range.setEnd(end, 0);
                var commonAncestorContainer = range.commonAncestorContainer;
                if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                    if (isOffsetContainer(commonAncestorContainer)) {
                        return commonAncestorContainer;
                    }
                    return getOffsetParent(commonAncestorContainer);
                }
                var element1root = getRoot(element1);
                if (element1root.host) {
                    return findCommonOffsetParent(element1root.host, element2);
                } else {
                    return findCommonOffsetParent(element1, getRoot(element2).host);
                }
            }

            function getScroll(element) {
                var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
                var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
                var nodeName = element.nodeName;
                if (nodeName === 'BODY' || nodeName === 'HTML') {
                    var html = element.ownerDocument.documentElement;
                    var scrollingElement = element.ownerDocument.scrollingElement || html;
                    return scrollingElement[upperSide];
                }
                return element[upperSide];
            }

            function includeScroll(rect, element) {
                var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var scrollTop = getScroll(element, 'top');
                var scrollLeft = getScroll(element, 'left');
                var modifier = subtract ? -1 : 1;
                rect.top += scrollTop * modifier;
                rect.bottom += scrollTop * modifier;
                rect.left += scrollLeft * modifier;
                rect.right += scrollLeft * modifier;
                return rect;
            }

            function getBordersSize(styles, axis) {
                var sideA = axis === 'x' ? 'Left' : 'Top';
                var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
                return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
            }

            function getSize(axis, body, html, computedStyle) {
                return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
            }

            function getWindowSizes(document) {
                var body = document.body;
                var html = document.documentElement;
                var computedStyle = isIE(10) && getComputedStyle(html);
                return {
                    height: getSize('Height', body, html, computedStyle),
                    width: getSize('Width', body, html, computedStyle)
                };
            }
            var classCallCheck = function(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            };
            var createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            var defineProperty = function(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            };
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            };

            function getClientRect(offsets) {
                return _extends({}, offsets, {
                    right: offsets.left + offsets.width,
                    bottom: offsets.top + offsets.height
                });
            }

            function getBoundingClientRect(element) {
                var rect = {};
                try {
                    if (isIE(10)) {
                        rect = element.getBoundingClientRect();
                        var scrollTop = getScroll(element, 'top');
                        var scrollLeft = getScroll(element, 'left');
                        rect.top += scrollTop;
                        rect.left += scrollLeft;
                        rect.bottom += scrollTop;
                        rect.right += scrollLeft;
                    } else {
                        rect = element.getBoundingClientRect();
                    }
                } catch (e) {}
                var result = {
                    left: rect.left,
                    top: rect.top,
                    width: rect.right - rect.left,
                    height: rect.bottom - rect.top
                };
                var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
                var width = sizes.width || element.clientWidth || result.right - result.left;
                var height = sizes.height || element.clientHeight || result.bottom - result.top;
                var horizScrollbar = element.offsetWidth - width;
                var vertScrollbar = element.offsetHeight - height;
                if (horizScrollbar || vertScrollbar) {
                    var styles = getStyleComputedProperty(element);
                    horizScrollbar -= getBordersSize(styles, 'x');
                    vertScrollbar -= getBordersSize(styles, 'y');
                    result.width -= horizScrollbar;
                    result.height -= vertScrollbar;
                }
                return getClientRect(result);
            }

            function getOffsetRectRelativeToArbitraryNode(children, parent) {
                var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var isIE10 = isIE(10);
                var isHTML = parent.nodeName === 'HTML';
                var childrenRect = getBoundingClientRect(children);
                var parentRect = getBoundingClientRect(parent);
                var scrollParent = getScrollParent(children);
                var styles = getStyleComputedProperty(parent);
                var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
                var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
                if (fixedPosition && isHTML) {
                    parentRect.top = Math.max(parentRect.top, 0);
                    parentRect.left = Math.max(parentRect.left, 0);
                }
                var offsets = getClientRect({
                    top: childrenRect.top - parentRect.top - borderTopWidth,
                    left: childrenRect.left - parentRect.left - borderLeftWidth,
                    width: childrenRect.width,
                    height: childrenRect.height
                });
                offsets.marginTop = 0;
                offsets.marginLeft = 0;
                if (!isIE10 && isHTML) {
                    var marginTop = parseFloat(styles.marginTop, 10);
                    var marginLeft = parseFloat(styles.marginLeft, 10);
                    offsets.top -= borderTopWidth - marginTop;
                    offsets.bottom -= borderTopWidth - marginTop;
                    offsets.left -= borderLeftWidth - marginLeft;
                    offsets.right -= borderLeftWidth - marginLeft;
                    offsets.marginTop = marginTop;
                    offsets.marginLeft = marginLeft;
                }
                if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
                    offsets = includeScroll(offsets, parent);
                }
                return offsets;
            }

            function getViewportOffsetRectRelativeToArtbitraryNode(element) {
                var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var html = element.ownerDocument.documentElement;
                var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
                var width = Math.max(html.clientWidth, window.innerWidth || 0);
                var height = Math.max(html.clientHeight, window.innerHeight || 0);
                var scrollTop = !excludeScroll ? getScroll(html) : 0;
                var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
                var offset = {
                    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                    width: width,
                    height: height
                };
                return getClientRect(offset);
            }

            function isFixed(element) {
                var nodeName = element.nodeName;
                if (nodeName === 'BODY' || nodeName === 'HTML') {
                    return false;
                }
                if (getStyleComputedProperty(element, 'position') === 'fixed') {
                    return true;
                }
                var parentNode = getParentNode(element);
                if (!parentNode) {
                    return false;
                }
                return isFixed(parentNode);
            }

            function getFixedPositionOffsetParent(element) {
                if (!element || !element.parentElement || isIE()) {
                    return document.documentElement;
                }
                var el = element.parentElement;
                while (el && getStyleComputedProperty(el, 'transform') === 'none') {
                    el = el.parentElement;
                }
                return el || document.documentElement;
            }

            function getBoundaries(popper, reference, padding, boundariesElement) {
                var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                var boundaries = {
                    top: 0,
                    left: 0
                };
                var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
                if (boundariesElement === 'viewport') {
                    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
                } else {
                    var boundariesNode = void 0;
                    if (boundariesElement === 'scrollParent') {
                        boundariesNode = getScrollParent(getParentNode(reference));
                        if (boundariesNode.nodeName === 'BODY') {
                            boundariesNode = popper.ownerDocument.documentElement;
                        }
                    } else if (boundariesElement === 'window') {
                        boundariesNode = popper.ownerDocument.documentElement;
                    } else {
                        boundariesNode = boundariesElement;
                    }
                    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
                    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
                        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
                            height = _getWindowSizes.height,
                            width = _getWindowSizes.width;
                        boundaries.top += offsets.top - offsets.marginTop;
                        boundaries.bottom = height + offsets.top;
                        boundaries.left += offsets.left - offsets.marginLeft;
                        boundaries.right = width + offsets.left;
                    } else {
                        boundaries = offsets;
                    }
                }
                padding = padding || 0;
                var isPaddingNumber = typeof padding === 'number';
                boundaries.left += isPaddingNumber ? padding : padding.left || 0;
                boundaries.top += isPaddingNumber ? padding : padding.top || 0;
                boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
                boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
                return boundaries;
            }

            function getArea(_ref) {
                var width = _ref.width,
                    height = _ref.height;
                return width * height;
            }

            function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
                var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                if (placement.indexOf('auto') === -1) {
                    return placement;
                }
                var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
                var rects = {
                    top: {
                        width: boundaries.width,
                        height: refRect.top - boundaries.top
                    },
                    right: {
                        width: boundaries.right - refRect.right,
                        height: boundaries.height
                    },
                    bottom: {
                        width: boundaries.width,
                        height: boundaries.bottom - refRect.bottom
                    },
                    left: {
                        width: refRect.left - boundaries.left,
                        height: boundaries.height
                    }
                };
                var sortedAreas = Object.keys(rects).map(function(key) {
                    return _extends({
                        key: key
                    }, rects[key], {
                        area: getArea(rects[key])
                    });
                }).sort(function(a, b) {
                    return b.area - a.area;
                });
                var filteredAreas = sortedAreas.filter(function(_ref2) {
                    var width = _ref2.width,
                        height = _ref2.height;
                    return width >= popper.clientWidth && height >= popper.clientHeight;
                });
                var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
                var variation = placement.split('-')[1];
                return computedPlacement + (variation ? '-' + variation : '');
            }

            function getReferenceOffsets(state, popper, reference) {
                var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
                return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
            }

            function getOuterSizes(element) {
                var window = element.ownerDocument.defaultView;
                var styles = window.getComputedStyle(element);
                var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
                var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
                var result = {
                    width: element.offsetWidth + y,
                    height: element.offsetHeight + x
                };
                return result;
            }

            function getOppositePlacement(placement) {
                var hash = {
                    left: 'right',
                    right: 'left',
                    bottom: 'top',
                    top: 'bottom'
                };
                return placement.replace(/left|right|bottom|top/g, function(matched) {
                    return hash[matched];
                });
            }

            function getPopperOffsets(popper, referenceOffsets, placement) {
                placement = placement.split('-')[0];
                var popperRect = getOuterSizes(popper);
                var popperOffsets = {
                    width: popperRect.width,
                    height: popperRect.height
                };
                var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
                var mainSide = isHoriz ? 'top' : 'left';
                var secondarySide = isHoriz ? 'left' : 'top';
                var measurement = isHoriz ? 'height' : 'width';
                var secondaryMeasurement = !isHoriz ? 'height' : 'width';
                popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
                if (placement === secondarySide) {
                    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
                } else {
                    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
                }
                return popperOffsets;
            }

            function find(arr, check) {
                if (Array.prototype.find) {
                    return arr.find(check);
                }
                return arr.filter(check)[0];
            }

            function findIndex(arr, prop, value) {
                if (Array.prototype.findIndex) {
                    return arr.findIndex(function(cur) {
                        return cur[prop] === value;
                    });
                }
                var match = find(arr, function(obj) {
                    return obj[prop] === value;
                });
                return arr.indexOf(match);
            }

            function runModifiers(modifiers, data, ends) {
                var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
                modifiersToRun.forEach(function(modifier) {
                    if (modifier['function']) {
                        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
                    }
                    var fn = modifier['function'] || modifier.fn;
                    if (modifier.enabled && isFunction(fn)) {
                        data.offsets.popper = getClientRect(data.offsets.popper);
                        data.offsets.reference = getClientRect(data.offsets.reference);
                        data = fn(data, modifier);
                    }
                });
                return data;
            }

            function update() {
                if (this.state.isDestroyed) {
                    return;
                }
                var data = {
                    instance: this,
                    styles: {},
                    arrowStyles: {},
                    attributes: {},
                    flipped: false,
                    offsets: {}
                };
                data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
                data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
                data.originalPlacement = data.placement;
                data.positionFixed = this.options.positionFixed;
                data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
                data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
                data = runModifiers(this.modifiers, data);
                if (!this.state.isCreated) {
                    this.state.isCreated = true;
                    this.options.onCreate(data);
                } else {
                    this.options.onUpdate(data);
                }
            }

            function isModifierEnabled(modifiers, modifierName) {
                return modifiers.some(function(_ref) {
                    var name = _ref.name,
                        enabled = _ref.enabled;
                    return enabled && name === modifierName;
                });
            }

            function getSupportedPropertyName(property) {
                var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
                var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
                for (var i = 0; i < prefixes.length; i++) {
                    var prefix = prefixes[i];
                    var toCheck = prefix ? '' + prefix + upperProp : property;
                    if (typeof document.body.style[toCheck] !== 'undefined') {
                        return toCheck;
                    }
                }
                return null;
            }

            function destroy() {
                this.state.isDestroyed = true;
                if (isModifierEnabled(this.modifiers, 'applyStyle')) {
                    this.popper.removeAttribute('x-placement');
                    this.popper.style.position = '';
                    this.popper.style.top = '';
                    this.popper.style.left = '';
                    this.popper.style.right = '';
                    this.popper.style.bottom = '';
                    this.popper.style.willChange = '';
                    this.popper.style[getSupportedPropertyName('transform')] = '';
                }
                this.disableEventListeners();
                if (this.options.removeOnDestroy) {
                    this.popper.parentNode.removeChild(this.popper);
                }
                return this;
            }

            function getWindow(element) {
                var ownerDocument = element.ownerDocument;
                return ownerDocument ? ownerDocument.defaultView : window;
            }

            function attachToScrollParents(scrollParent, event, callback, scrollParents) {
                var isBody = scrollParent.nodeName === 'BODY';
                var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
                target.addEventListener(event, callback, {
                    passive: true
                });
                if (!isBody) {
                    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
                }
                scrollParents.push(target);
            }

            function setupEventListeners(reference, options, state, updateBound) {
                state.updateBound = updateBound;
                getWindow(reference).addEventListener('resize', state.updateBound, {
                    passive: true
                });
                var scrollElement = getScrollParent(reference);
                attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
                state.scrollElement = scrollElement;
                state.eventsEnabled = true;
                return state;
            }

            function enableEventListeners() {
                if (!this.state.eventsEnabled) {
                    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
                }
            }

            function removeEventListeners(reference, state) {
                getWindow(reference).removeEventListener('resize', state.updateBound);
                state.scrollParents.forEach(function(target) {
                    target.removeEventListener('scroll', state.updateBound);
                });
                state.updateBound = null;
                state.scrollParents = [];
                state.scrollElement = null;
                state.eventsEnabled = false;
                return state;
            }

            function disableEventListeners() {
                if (this.state.eventsEnabled) {
                    cancelAnimationFrame(this.scheduleUpdate);
                    this.state = removeEventListeners(this.reference, this.state);
                }
            }

            function isNumeric(n) {
                return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
            }

            function setStyles(element, styles) {
                Object.keys(styles).forEach(function(prop) {
                    var unit = '';
                    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                        unit = 'px';
                    }
                    element.style[prop] = styles[prop] + unit;
                });
            }

            function setAttributes(element, attributes) {
                Object.keys(attributes).forEach(function(prop) {
                    var value = attributes[prop];
                    if (value !== false) {
                        element.setAttribute(prop, attributes[prop]);
                    } else {
                        element.removeAttribute(prop);
                    }
                });
            }

            function applyStyle(data) {
                setStyles(data.instance.popper, data.styles);
                setAttributes(data.instance.popper, data.attributes);
                if (data.arrowElement && Object.keys(data.arrowStyles).length) {
                    setStyles(data.arrowElement, data.arrowStyles);
                }
                return data;
            }

            function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
                var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
                var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                popper.setAttribute('x-placement', placement);
                setStyles(popper, {
                    position: options.positionFixed ? 'fixed' : 'absolute'
                });
                return options;
            }

            function getRoundedOffsets(data, shouldRound) {
                var _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference;
                var round = Math.round,
                    floor = Math.floor;
                var noRound = function noRound(v) {
                    return v;
                };
                var referenceWidth = round(reference.width);
                var popperWidth = round(popper.width);
                var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
                var isVariation = data.placement.indexOf('-') !== -1;
                var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
                var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
                var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
                var verticalToInteger = !shouldRound ? noRound : round;
                return {
                    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
                    top: verticalToInteger(popper.top),
                    bottom: verticalToInteger(popper.bottom),
                    right: horizontalToInteger(popper.right)
                };
            }
            var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

            function computeStyle(data, options) {
                var x = options.x,
                    y = options.y;
                var popper = data.offsets.popper;
                var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
                    return modifier.name === 'applyStyle';
                }).gpuAcceleration;
                if (legacyGpuAccelerationOption !== undefined) {
                    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
                }
                var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
                var offsetParent = getOffsetParent(data.instance.popper);
                var offsetParentRect = getBoundingClientRect(offsetParent);
                var styles = {
                    position: popper.position
                };
                var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
                var sideA = x === 'bottom' ? 'top' : 'bottom';
                var sideB = y === 'right' ? 'left' : 'right';
                var prefixedProperty = getSupportedPropertyName('transform');
                var left = void 0,
                    top = void 0;
                if (sideA === 'bottom') {
                    if (offsetParent.nodeName === 'HTML') {
                        top = -offsetParent.clientHeight + offsets.bottom;
                    } else {
                        top = -offsetParentRect.height + offsets.bottom;
                    }
                } else {
                    top = offsets.top;
                }
                if (sideB === 'right') {
                    if (offsetParent.nodeName === 'HTML') {
                        left = -offsetParent.clientWidth + offsets.right;
                    } else {
                        left = -offsetParentRect.width + offsets.right;
                    }
                } else {
                    left = offsets.left;
                }
                if (gpuAcceleration && prefixedProperty) {
                    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
                    styles[sideA] = 0;
                    styles[sideB] = 0;
                    styles.willChange = 'transform';
                } else {
                    var invertTop = sideA === 'bottom' ? -1 : 1;
                    var invertLeft = sideB === 'right' ? -1 : 1;
                    styles[sideA] = top * invertTop;
                    styles[sideB] = left * invertLeft;
                    styles.willChange = sideA + ', ' + sideB;
                }
                var attributes = {
                    'x-placement': data.placement
                };
                data.attributes = _extends({}, attributes, data.attributes);
                data.styles = _extends({}, styles, data.styles);
                data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
                return data;
            }

            function isModifierRequired(modifiers, requestingName, requestedName) {
                var requesting = find(modifiers, function(_ref) {
                    var name = _ref.name;
                    return name === requestingName;
                });
                var isRequired = !!requesting && modifiers.some(function(modifier) {
                    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
                });
                if (!isRequired) {
                    var _requesting = '`' + requestingName + '`';
                    var requested = '`' + requestedName + '`';
                    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
                }
                return isRequired;
            }

            function arrow(data, options) {
                var _data$offsets$arrow;
                if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
                    return data;
                }
                var arrowElement = options.element;
                if (typeof arrowElement === 'string') {
                    arrowElement = data.instance.popper.querySelector(arrowElement);
                    if (!arrowElement) {
                        return data;
                    }
                } else {
                    if (!data.instance.popper.contains(arrowElement)) {
                        console.warn('WARNING: `arrow.element` must be child of its popper element!');
                        return data;
                    }
                }
                var placement = data.placement.split('-')[0];
                var _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference;
                var isVertical = ['left', 'right'].indexOf(placement) !== -1;
                var len = isVertical ? 'height' : 'width';
                var sideCapitalized = isVertical ? 'Top' : 'Left';
                var side = sideCapitalized.toLowerCase();
                var altSide = isVertical ? 'left' : 'top';
                var opSide = isVertical ? 'bottom' : 'right';
                var arrowElementSize = getOuterSizes(arrowElement)[len];
                if (reference[opSide] - arrowElementSize < popper[side]) {
                    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                }
                if (reference[side] + arrowElementSize > popper[opSide]) {
                    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                }
                data.offsets.popper = getClientRect(data.offsets.popper);
                var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
                var css = getStyleComputedProperty(data.instance.popper);
                var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
                var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
                var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
                sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
                data.arrowElement = arrowElement;
                data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
                return data;
            }

            function getOppositeVariation(variation) {
                if (variation === 'end') {
                    return 'start';
                } else if (variation === 'start') {
                    return 'end';
                }
                return variation;
            }
            var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
            var validPlacements = placements.slice(3);

            function clockwise(placement) {
                var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var index = validPlacements.indexOf(placement);
                var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
                return counter ? arr.reverse() : arr;
            }
            var BEHAVIORS = {
                FLIP: 'flip',
                CLOCKWISE: 'clockwise',
                COUNTERCLOCKWISE: 'counterclockwise'
            };

            function flip(data, options) {
                if (isModifierEnabled(data.instance.modifiers, 'inner')) {
                    return data;
                }
                if (data.flipped && data.placement === data.originalPlacement) {
                    return data;
                }
                var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
                var placement = data.placement.split('-')[0];
                var placementOpposite = getOppositePlacement(placement);
                var variation = data.placement.split('-')[1] || '';
                var flipOrder = [];
                switch (options.behavior) {
                    case BEHAVIORS.FLIP:
                        flipOrder = [placement, placementOpposite];
                        break;
                    case BEHAVIORS.CLOCKWISE:
                        flipOrder = clockwise(placement);
                        break;
                    case BEHAVIORS.COUNTERCLOCKWISE:
                        flipOrder = clockwise(placement, true);
                        break;
                    default:
                        flipOrder = options.behavior;
                }
                flipOrder.forEach(function(step, index) {
                    if (placement !== step || flipOrder.length === index + 1) {
                        return data;
                    }
                    placement = data.placement.split('-')[0];
                    placementOpposite = getOppositePlacement(placement);
                    var popperOffsets = data.offsets.popper;
                    var refOffsets = data.offsets.reference;
                    var floor = Math.floor;
                    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
                    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
                    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
                    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
                    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
                    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
                    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
                    if (overlapsRef || overflowsBoundaries || flippedVariation) {
                        data.flipped = true;
                        if (overlapsRef || overflowsBoundaries) {
                            placement = flipOrder[index + 1];
                        }
                        if (flippedVariation) {
                            variation = getOppositeVariation(variation);
                        }
                        data.placement = placement + (variation ? '-' + variation : '');
                        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                        data = runModifiers(data.instance.modifiers, data, 'flip');
                    }
                });
                return data;
            }

            function keepTogether(data) {
                var _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference;
                var placement = data.placement.split('-')[0];
                var floor = Math.floor;
                var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
                var side = isVertical ? 'right' : 'bottom';
                var opSide = isVertical ? 'left' : 'top';
                var measurement = isVertical ? 'width' : 'height';
                if (popper[side] < floor(reference[opSide])) {
                    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
                }
                if (popper[opSide] > floor(reference[side])) {
                    data.offsets.popper[opSide] = floor(reference[side]);
                }
                return data;
            }

            function toValue(str, measurement, popperOffsets, referenceOffsets) {
                var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
                var value = +split[1];
                var unit = split[2];
                if (!value) {
                    return str;
                }
                if (unit.indexOf('%') === 0) {
                    var element = void 0;
                    switch (unit) {
                        case '%p':
                            element = popperOffsets;
                            break;
                        case '%':
                        case '%r':
                        default:
                            element = referenceOffsets;
                    }
                    var rect = getClientRect(element);
                    return rect[measurement] / 100 * value;
                } else if (unit === 'vh' || unit === 'vw') {
                    var size = void 0;
                    if (unit === 'vh') {
                        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                    } else {
                        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                    }
                    return size / 100 * value;
                } else {
                    return value;
                }
            }

            function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
                var offsets = [0, 0];
                var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
                var fragments = offset.split(/(\+|\-)/).map(function(frag) {
                    return frag.trim();
                });
                var divider = fragments.indexOf(find(fragments, function(frag) {
                    return frag.search(/,|\s/) !== -1;
                }));
                if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
                    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
                }
                var splitRegex = /\s*,\s*|\s+/;
                var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
                ops = ops.map(function(op, index) {
                    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
                    var mergeWithPrevious = false;
                    return op.reduce(function(a, b) {
                        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
                            a[a.length - 1] = b;
                            mergeWithPrevious = true;
                            return a;
                        } else if (mergeWithPrevious) {
                            a[a.length - 1] += b;
                            mergeWithPrevious = false;
                            return a;
                        } else {
                            return a.concat(b);
                        }
                    }, []).map(function(str) {
                        return toValue(str, measurement, popperOffsets, referenceOffsets);
                    });
                });
                ops.forEach(function(op, index) {
                    op.forEach(function(frag, index2) {
                        if (isNumeric(frag)) {
                            offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
                        }
                    });
                });
                return offsets;
            }

            function offset(data, _ref) {
                var offset = _ref.offset;
                var placement = data.placement,
                    _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference;
                var basePlacement = placement.split('-')[0];
                var offsets = void 0;
                if (isNumeric(+offset)) {
                    offsets = [+offset, 0];
                } else {
                    offsets = parseOffset(offset, popper, reference, basePlacement);
                }
                if (basePlacement === 'left') {
                    popper.top += offsets[0];
                    popper.left -= offsets[1];
                } else if (basePlacement === 'right') {
                    popper.top += offsets[0];
                    popper.left += offsets[1];
                } else if (basePlacement === 'top') {
                    popper.left += offsets[0];
                    popper.top -= offsets[1];
                } else if (basePlacement === 'bottom') {
                    popper.left += offsets[0];
                    popper.top += offsets[1];
                }
                data.popper = popper;
                return data;
            }

            function preventOverflow(data, options) {
                var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
                if (data.instance.reference === boundariesElement) {
                    boundariesElement = getOffsetParent(boundariesElement);
                }
                var transformProp = getSupportedPropertyName('transform');
                var popperStyles = data.instance.popper.style;
                var top = popperStyles.top,
                    left = popperStyles.left,
                    transform = popperStyles[transformProp];
                popperStyles.top = '';
                popperStyles.left = '';
                popperStyles[transformProp] = '';
                var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
                popperStyles.top = top;
                popperStyles.left = left;
                popperStyles[transformProp] = transform;
                options.boundaries = boundaries;
                var order = options.priority;
                var popper = data.offsets.popper;
                var check = {
                    primary: function primary(placement) {
                        var value = popper[placement];
                        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                            value = Math.max(popper[placement], boundaries[placement]);
                        }
                        return defineProperty({}, placement, value);
                    },
                    secondary: function secondary(placement) {
                        var mainSide = placement === 'right' ? 'left' : 'top';
                        var value = popper[mainSide];
                        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                            value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
                        }
                        return defineProperty({}, mainSide, value);
                    }
                };
                order.forEach(function(placement) {
                    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
                    popper = _extends({}, popper, check[side](placement));
                });
                data.offsets.popper = popper;
                return data;
            }

            function shift(data) {
                var placement = data.placement;
                var basePlacement = placement.split('-')[0];
                var shiftvariation = placement.split('-')[1];
                if (shiftvariation) {
                    var _data$offsets = data.offsets,
                        reference = _data$offsets.reference,
                        popper = _data$offsets.popper;
                    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
                    var side = isVertical ? 'left' : 'top';
                    var measurement = isVertical ? 'width' : 'height';
                    var shiftOffsets = {
                        start: defineProperty({}, side, reference[side]),
                        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                    };
                    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                }
                return data;
            }

            function hide(data) {
                if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
                    return data;
                }
                var refRect = data.offsets.reference;
                var bound = find(data.instance.modifiers, function(modifier) {
                    return modifier.name === 'preventOverflow';
                }).boundaries;
                if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                    if (data.hide === true) {
                        return data;
                    }
                    data.hide = true;
                    data.attributes['x-out-of-boundaries'] = '';
                } else {
                    if (data.hide === false) {
                        return data;
                    }
                    data.hide = false;
                    data.attributes['x-out-of-boundaries'] = false;
                }
                return data;
            }

            function inner(data) {
                var placement = data.placement;
                var basePlacement = placement.split('-')[0];
                var _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference;
                var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
                var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
                popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
                data.placement = getOppositePlacement(placement);
                data.offsets.popper = getClientRect(popper);
                return data;
            }
            var modifiers = {
                shift: {
                    order: 100,
                    enabled: true,
                    fn: shift
                },
                offset: {
                    order: 200,
                    enabled: true,
                    fn: offset,
                    offset: 0
                },
                preventOverflow: {
                    order: 300,
                    enabled: true,
                    fn: preventOverflow,
                    priority: ['left', 'right', 'top', 'bottom'],
                    padding: 5,
                    boundariesElement: 'scrollParent'
                },
                keepTogether: {
                    order: 400,
                    enabled: true,
                    fn: keepTogether
                },
                arrow: {
                    order: 500,
                    enabled: true,
                    fn: arrow,
                    element: '[x-arrow]'
                },
                flip: {
                    order: 600,
                    enabled: true,
                    fn: flip,
                    behavior: 'flip',
                    padding: 5,
                    boundariesElement: 'viewport',
                    flipVariations: false,
                    flipVariationsByContent: false
                },
                inner: {
                    order: 700,
                    enabled: false,
                    fn: inner
                },
                hide: {
                    order: 800,
                    enabled: true,
                    fn: hide
                },
                computeStyle: {
                    order: 850,
                    enabled: true,
                    fn: computeStyle,
                    gpuAcceleration: true,
                    x: 'bottom',
                    y: 'right'
                },
                applyStyle: {
                    order: 900,
                    enabled: true,
                    fn: applyStyle,
                    onLoad: applyStyleOnLoad,
                    gpuAcceleration: undefined
                }
            };
            var Defaults = {
                placement: 'bottom',
                positionFixed: false,
                eventsEnabled: true,
                removeOnDestroy: false,
                onCreate: function onCreate() {},
                onUpdate: function onUpdate() {},
                modifiers: modifiers
            };
            var Popper = function() {
                function Popper(reference, popper) {
                    var _this = this;
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    classCallCheck(this, Popper);
                    this.scheduleUpdate = function() {
                        return requestAnimationFrame(_this.update);
                    };
                    this.update = debounce(this.update.bind(this));
                    this.options = _extends({}, Popper.Defaults, options);
                    this.state = {
                        isDestroyed: false,
                        isCreated: false,
                        scrollParents: []
                    };
                    this.reference = reference && reference.jquery ? reference[0] : reference;
                    this.popper = popper && popper.jquery ? popper[0] : popper;
                    this.options.modifiers = {};
                    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function(name) {
                        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                    });
                    this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                        return _extends({
                            name: name
                        }, _this.options.modifiers[name]);
                    }).sort(function(a, b) {
                        return a.order - b.order;
                    });
                    this.modifiers.forEach(function(modifierOptions) {
                        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                        }
                    });
                    this.update();
                    var eventsEnabled = this.options.eventsEnabled;
                    if (eventsEnabled) {
                        this.enableEventListeners();
                    }
                    this.state.eventsEnabled = eventsEnabled;
                }
                createClass(Popper, [{
                    key: 'update',
                    value: function update$$1() {
                        return update.call(this);
                    }
                }, {
                    key: 'destroy',
                    value: function destroy$$1() {
                        return destroy.call(this);
                    }
                }, {
                    key: 'enableEventListeners',
                    value: function enableEventListeners$$1() {
                        return enableEventListeners.call(this);
                    }
                }, {
                    key: 'disableEventListeners',
                    value: function disableEventListeners$$1() {
                        return disableEventListeners.call(this);
                    }
                }]);
                return Popper;
            }();
            Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
            Popper.placements = placements;
            Popper.Defaults = Defaults;
            return Popper;
        })));
    }.call(exports, (function() {
        return this;
    }())))
}), (function(module, exports) {
    'use strict';

    function addSpinner($target) {
        var $veil = $('<div class="veil"><div class="underlay"></div></div>');
        $veil.append('<div class="spinner"><div class="dot1"></div><div class="dot2"></div></div>');
        if ($target.get(0).tagName === 'IMG') {
            $target.after($veil);
            $veil.css({
                width: $target.width(),
                height: $target.height()
            });
            if ($target.parent().css('position') === 'static') {
                $target.parent().css('position', 'relative');
            }
        } else {
            $target.append($veil);
            if ($target.css('position') === 'static') {
                $target.parent().css('position', 'relative');
                $target.parent().addClass('veiled');
            }
            if ($target.get(0).tagName === 'BODY') {
                $veil.find('.spinner').css('position', 'fixed');
            }
        }
        $veil.click(function(e) {
            e.stopPropagation();
        });
    }

    function removeSpinner($veil) {
        if ($veil.parent().hasClass('veiled')) {
            $veil.parent().css('position', '');
            $veil.parent().removeClass('veiled');
        }
        $veil.off('click');
        $veil.remove();
    }
    $.fn.spinner = function() {
        var $element = $(this);
        var Fn = function() {
            this.start = function() {
                if ($element.length) {
                    addSpinner($element);
                }
            };
            this.stop = function() {
                if ($element.length) {
                    var $veil = $('.veil');
                    removeSpinner($veil);
                }
            };
        };
        return new Fn();
    };
    $.spinner = function() {
        var Fn = function() {
            this.start = function() {
                addSpinner($('body'));
            };
            this.stop = function() {
                removeSpinner($('.veil'));
            };
        };
        return new Fn();
    };
}), (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
     * @fileOverview TouchSwipe - jQuery Plugin
     * @version 1.6.18
     *
     * @author Matt Bryson http://www.github.com/mattbryson
     * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
     * @see http://labs.rampinteractive.co.uk/touchSwipe/
     * @see http://plugins.jquery.com/project/touchSwipe
     * @license
     * Copyright (c) 2010-2015 Matt Bryson
     * Dual licensed under the MIT or GPL Version 2 licenses.
     *
     */
    ! function(factory) {
        "function" == "function" && __webpack_require__(46) && __webpack_require__(46).jQuery ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(27)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory("undefined" != typeof module && module.exports ? __webpack_require__(27) : jQuery)
    }(function($) {
        "use strict";

        function init(options) {
            return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function() {
                var $this = $(this),
                    plugin = $this.data(PLUGIN_NS);
                plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin))
            })
        }

        function TouchSwipe(element, options) {
            function touchStart(jqEvent) {
                if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
                    var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                    if (!event.pointerType || "mouse" != event.pointerType || 0 != options.fallbackToMouseEvents) {
                        var ret, touches = event.touches,
                            evt = touches ? touches[0] : event;
                        return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function() {
                            $element.trigger("hold", [event.target]), options.hold && (ret = options.hold.call($element, event, event.target))
                        }, this), options.longTapThreshold)), setTouchInProgress(!0), null)
                    }
                }
            }

            function touchMove(jqEvent) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
                    var ret, touches = event.touches,
                        evt = touches ? touches[0] : event,
                        currentFinger = updateFingerData(evt);
                    if (endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
                        if (direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                            var inBounds = !0;
                            if (options.triggerOnTouchLeave) {
                                var bounds = getbounds(this);
                                inBounds = isInBounds(currentFinger.end, bounds)
                            }!options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase)
                        }
                    } else phase = PHASE_CANCEL, triggerHandler(event, phase);
                    ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase))
                }
            }

            function touchEnd(jqEvent) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
                    touches = event.touches;
                if (touches) {
                    if (touches.length && !inMultiFingerRelease()) return startMultiFingerRelease(event), !0;
                    if (touches.length && inMultiFingerRelease()) return !0
                }
                return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.cancelable !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null
            }

            function touchCancel() {
                fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1)
            }

            function touchLeave(jqEvent) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase))
            }

            function removeListeners() {
                $element.off(START_EV, touchStart), $element.off(CANCEL_EV, touchCancel), $element.off(MOVE_EV, touchMove), $element.off(END_EV, touchEnd), LEAVE_EV && $element.off(LEAVE_EV, touchLeave), setTouchInProgress(!1)
            }

            function getNextPhase(currentPhase) {
                var nextPhase = currentPhase,
                    validTime = validateSwipeTime(),
                    validDistance = validateSwipeDistance(),
                    didCancel = didSwipeBackToCancel();
                return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase
            }

            function triggerHandler(event, phase) {
                var ret, touches = event.touches;
                return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret
            }

            function triggerHandlerForGesture(event, phase, gesture) {
                var ret;
                if (gesture == SWIPE) {
                    if ($element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                    if (phase == PHASE_END && validateSwipe()) {
                        if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger("swipe", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                        switch (direction) {
                            case LEFT:
                                $element.trigger("swipeLeft", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                                break;
                            case RIGHT:
                                $element.trigger("swipeRight", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                                break;
                            case UP:
                                $element.trigger("swipeUp", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                                break;
                            case DOWN:
                                $element.trigger("swipeDown", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection))
                        }
                    }
                }
                if (gesture == PINCH) {
                    if ($element.trigger("pinchStatus", [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1)) return !1;
                    if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
                        case IN:
                            $element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
                            break;
                        case OUT:
                            $element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData))
                    }
                }
                return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function() {
                    doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target))
                }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger("doubletap", [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("longtap", [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret
            }

            function validateSwipeDistance() {
                var valid = !0;
                return null !== options.threshold && (valid = distance >= options.threshold), valid
            }

            function didSwipeBackToCancel() {
                var cancelled = !1;
                return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled
            }

            function validatePinchDistance() {
                return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0
            }

            function validateSwipeTime() {
                var result;
                return result = options.maxTimeThreshold ? !(duration >= options.maxTimeThreshold) : !0
            }

            function validateDefaultEvent(jqEvent, direction) {
                if (options.preventDefaultEvents !== !1)
                    if (options.allowPageScroll === NONE) jqEvent.preventDefault();
                    else {
                        var auto = options.allowPageScroll === AUTO;
                        switch (direction) {
                            case LEFT:
                                (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                                break;
                            case RIGHT:
                                (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                                break;
                            case UP:
                                (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                                break;
                            case DOWN:
                                (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                                break;
                            case NONE:
                        }
                    }
            }

            function validatePinch() {
                var hasCorrectFingerCount = validateFingers(),
                    hasEndPoint = validateEndPoint(),
                    hasCorrectDistance = validatePinchDistance();
                return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance
            }

            function hasPinches() {
                return !!(options.pinchStatus || options.pinchIn || options.pinchOut)
            }

            function didPinch() {
                return !(!validatePinch() || !hasPinches())
            }

            function validateSwipe() {
                var hasValidTime = validateSwipeTime(),
                    hasValidDistance = validateSwipeDistance(),
                    hasCorrectFingerCount = validateFingers(),
                    hasEndPoint = validateEndPoint(),
                    didCancel = didSwipeBackToCancel(),
                    valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
                return valid
            }

            function hasSwipes() {
                return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown)
            }

            function didSwipe() {
                return !(!validateSwipe() || !hasSwipes())
            }

            function validateFingers() {
                return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH
            }

            function validateEndPoint() {
                return 0 !== fingerData[0].end.x
            }

            function hasTap() {
                return !!options.tap
            }

            function hasDoubleTap() {
                return !!options.doubleTap
            }

            function hasLongTap() {
                return !!options.longTap
            }

            function validateDoubleTap() {
                if (null == doubleTapStartTime) return !1;
                var now = getTimeStamp();
                return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold
            }

            function inDoubleTap() {
                return validateDoubleTap()
            }

            function validateTap() {
                return (1 === fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold)
            }

            function validateLongTap() {
                return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance
            }

            function didTap() {
                return !(!validateTap() || !hasTap())
            }

            function didDoubleTap() {
                return !(!validateDoubleTap() || !hasDoubleTap())
            }

            function didLongTap() {
                return !(!validateLongTap() || !hasLongTap())
            }

            function startMultiFingerRelease(event) {
                previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1
            }

            function cancelMultiFingerRelease() {
                previousTouchEndTime = 0, fingerCountAtRelease = 0
            }

            function inMultiFingerRelease() {
                var withinThreshold = !1;
                if (previousTouchEndTime) {
                    var diff = getTimeStamp() - previousTouchEndTime;
                    diff <= options.fingerReleaseThreshold && (withinThreshold = !0)
                }
                return withinThreshold
            }

            function getTouchInProgress() {
                return !($element.data(PLUGIN_NS + "_intouch") !== !0)
            }

            function setTouchInProgress(val) {
                $element && (val === !0 ? ($element.on(MOVE_EV, touchMove), $element.on(END_EV, touchEnd), LEAVE_EV && $element.on(LEAVE_EV, touchLeave)) : ($element.off(MOVE_EV, touchMove, !1), $element.off(END_EV, touchEnd, !1), LEAVE_EV && $element.off(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + "_intouch", val === !0))
            }

            function createFingerData(id, evt) {
                var f = {
                    start: {
                        x: 0,
                        y: 0
                    },
                    last: {
                        x: 0,
                        y: 0
                    },
                    end: {
                        x: 0,
                        y: 0
                    }
                };
                return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f
            }

            function updateFingerData(evt) {
                var id = void 0 !== evt.identifier ? evt.identifier : 0,
                    f = getFingerData(id);
                return null === f && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f
            }

            function getFingerData(id) {
                return fingerData[id] || null
            }

            function setMaxDistance(direction, distance) {
                direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance)
            }

            function getMaxDistance(direction) {
                return maximumsMap[direction] ? maximumsMap[direction].distance : void 0
            }

            function createMaximumsData() {
                var maxData = {};
                return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData
            }

            function createMaximumVO(dir) {
                return {
                    direction: dir,
                    distance: 0
                }
            }

            function calculateDuration() {
                return endTime - startTime
            }

            function calculateTouchesDistance(startPoint, endPoint) {
                var diffX = Math.abs(startPoint.x - endPoint.x),
                    diffY = Math.abs(startPoint.y - endPoint.y);
                return Math.round(Math.sqrt(diffX * diffX + diffY * diffY))
            }

            function calculatePinchZoom(startDistance, endDistance) {
                var percent = endDistance / startDistance * 1;
                return percent.toFixed(2)
            }

            function calculatePinchDirection() {
                return 1 > pinchZoom ? OUT : IN
            }

            function calculateDistance(startPoint, endPoint) {
                return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)))
            }

            function calculateAngle(startPoint, endPoint) {
                var x = startPoint.x - endPoint.x,
                    y = endPoint.y - startPoint.y,
                    r = Math.atan2(y, x),
                    angle = Math.round(180 * r / Math.PI);
                return 0 > angle && (angle = 360 - Math.abs(angle)), angle
            }

            function calculateDirection(startPoint, endPoint) {
                if (comparePoints(startPoint, endPoint)) return NONE;
                var angle = calculateAngle(startPoint, endPoint);
                return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP
            }

            function getTimeStamp() {
                var now = new Date;
                return now.getTime()
            }

            function getbounds(el) {
                el = $(el);
                var offset = el.offset(),
                    bounds = {
                        left: offset.left,
                        right: offset.left + el.outerWidth(),
                        top: offset.top,
                        bottom: offset.top + el.outerHeight()
                    };
                return bounds
            }

            function isInBounds(point, bounds) {
                return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom
            }

            function comparePoints(pointA, pointB) {
                return pointA.x == pointB.x && pointA.y == pointB.y
            }
            var options = $.extend({}, options),
                useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
                START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
                MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
                END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
                LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? "mouseleave" : null : "mouseleave",
                CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerCancel" : "pointercancel" : "touchcancel",
                distance = 0,
                direction = null,
                currentDirection = null,
                duration = 0,
                startTouchesDistance = 0,
                endTouchesDistance = 0,
                pinchZoom = 1,
                pinchDistance = 0,
                pinchDirection = 0,
                maximumsMap = null,
                $element = $(element),
                phase = "start",
                fingerCount = 0,
                fingerData = {},
                startTime = 0,
                endTime = 0,
                previousTouchEndTime = 0,
                fingerCountAtRelease = 0,
                doubleTapStartTime = 0,
                singleTapTimeout = null,
                holdTimeout = null;
            try {
                $element.on(START_EV, touchStart), $element.on(CANCEL_EV, touchCancel)
            } catch (e) {
                $.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe")
            }
            this.enable = function() {
                return this.disable(), $element.on(START_EV, touchStart), $element.on(CANCEL_EV, touchCancel), $element
            }, this.disable = function() {
                return removeListeners(), $element
            }, this.destroy = function() {
                removeListeners(), $element.data(PLUGIN_NS, null), $element = null
            }, this.option = function(property, value) {
                if ("object" == typeof property) options = $.extend(options, property);
                else if (void 0 !== options[property]) {
                    if (void 0 === value) return options[property];
                    options[property] = value
                } else {
                    if (!property) return options;
                    $.error("Option " + property + " does not exist on jQuery.swipe.options")
                }
                return null
            }
        }
        var VERSION = "1.6.18",
            LEFT = "left",
            RIGHT = "right",
            UP = "up",
            DOWN = "down",
            IN = "in",
            OUT = "out",
            NONE = "none",
            AUTO = "auto",
            SWIPE = "swipe",
            PINCH = "pinch",
            TAP = "tap",
            DOUBLE_TAP = "doubletap",
            LONG_TAP = "longtap",
            HORIZONTAL = "horizontal",
            VERTICAL = "vertical",
            ALL_FINGERS = "all",
            DOUBLE_TAP_THRESHOLD = 10,
            PHASE_START = "start",
            PHASE_MOVE = "move",
            PHASE_END = "end",
            PHASE_CANCEL = "cancel",
            SUPPORTS_TOUCH = "ontouchstart" in window,
            SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.PointerEvent && !SUPPORTS_TOUCH,
            SUPPORTS_POINTER = (window.PointerEvent || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
            PLUGIN_NS = "TouchSwipe",
            defaults = {
                fingers: 1,
                threshold: 75,
                cancelThreshold: null,
                pinchThreshold: 20,
                maxTimeThreshold: null,
                fingerReleaseThreshold: 250,
                longTapThreshold: 500,
                doubleTapThreshold: 200,
                swipe: null,
                swipeLeft: null,
                swipeRight: null,
                swipeUp: null,
                swipeDown: null,
                swipeStatus: null,
                pinchIn: null,
                pinchOut: null,
                pinchStatus: null,
                click: null,
                tap: null,
                doubleTap: null,
                longTap: null,
                hold: null,
                triggerOnTouchEnd: !0,
                triggerOnTouchLeave: !1,
                allowPageScroll: "auto",
                fallbackToMouseEvents: !0,
                excludedElements: ".noSwipe",
                preventDefaultEvents: !0
            };
        $.fn.swipe = function(method) {
            var $this = $(this),
                plugin = $this.data(PLUGIN_NS);
            if (plugin && "string" == typeof method) {
                if (plugin[method]) return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
                $.error("Method " + method + " does not exist on jQuery.swipe")
            } else if (plugin && "object" == typeof method) plugin.option.apply(plugin, arguments);
            else if (!(plugin || "object" != typeof method && method)) return init.apply(this, arguments);
            return $this
        }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
            PHASE_START: PHASE_START,
            PHASE_MOVE: PHASE_MOVE,
            PHASE_END: PHASE_END,
            PHASE_CANCEL: PHASE_CANCEL
        }, $.fn.swipe.directions = {
            LEFT: LEFT,
            RIGHT: RIGHT,
            UP: UP,
            DOWN: DOWN,
            IN: IN,
            OUT: OUT
        }, $.fn.swipe.pageScroll = {
            NONE: NONE,
            HORIZONTAL: HORIZONTAL,
            VERTICAL: VERTICAL,
            AUTO: AUTO
        }, $.fn.swipe.fingers = {
            ONE: 1,
            TWO: 2,
            THREE: 3,
            FOUR: 4,
            FIVE: 5,
            ALL: ALL_FINGERS
        }
    });
}), (function(module, exports) {
    (function(__webpack_amd_options__) {
        module.exports = __webpack_amd_options__;
    }.call(exports, {}))
}), (function(module, exports) {
    (function(window, factory) {
        var lazySizes = factory(window, window.document);
        window.lazySizes = lazySizes;
        if (typeof module == 'object' && module.exports) {
            module.exports = lazySizes;
        }
    }(window, function l(window, document) {
        'use strict';
        if (!document.getElementsByClassName) {
            return;
        }
        var lazySizesConfig;
        var docElem = document.documentElement;
        var Date = window.Date;
        var supportPicture = window.HTMLPictureElement;
        var _addEventListener = 'addEventListener';
        var _getAttribute = 'getAttribute';
        var addEventListener = window[_addEventListener];
        var setTimeout = window.setTimeout;
        var requestAnimationFrame = window.requestAnimationFrame || setTimeout;
        var requestIdleCallback = window.requestIdleCallback;
        var regPicture = /^picture$/i;
        var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];
        var regClassCache = {};
        var forEach = Array.prototype.forEach;
        var hasClass = function(ele, cls) {
            if (!regClassCache[cls]) {
                regClassCache[cls] = new RegExp('(\\s|^)' + cls + '(\\s|$)');
            }
            return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
        };
        var addClass = function(ele, cls) {
            if (!hasClass(ele, cls)) {
                ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
            }
        };
        var removeClass = function(ele, cls) {
            var reg;
            if ((reg = hasClass(ele, cls))) {
                ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
            }
        };
        var addRemoveLoadEvents = function(dom, fn, add) {
            var action = add ? _addEventListener : 'removeEventListener';
            if (add) {
                addRemoveLoadEvents(dom, fn);
            }
            loadEvents.forEach(function(evt) {
                dom[action](evt, fn);
            });
        };
        var triggerEvent = function(elem, name, detail, noBubbles, noCancelable) {
            var event = document.createEvent('CustomEvent');
            event.initCustomEvent(name, !noBubbles, !noCancelable, detail || {});
            elem.dispatchEvent(event);
            return event;
        };
        var updatePolyfill = function(el, full) {
            var polyfill;
            if (!supportPicture && (polyfill = (window.picturefill || lazySizesConfig.pf))) {
                polyfill({
                    reevaluate: true,
                    elements: [el]
                });
            } else if (full && full.src) {
                el.src = full.src;
            }
        };
        var getCSS = function(elem, style) {
            return (getComputedStyle(elem, null) || {})[style];
        };
        var getWidth = function(elem, parent, width) {
            width = width || elem.offsetWidth;
            while (width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth) {
                width = parent.offsetWidth;
                parent = parent.parentNode;
            }
            return width;
        };
        var rAF = (function() {
            var running, waiting;
            var firstFns = [];
            var secondFns = [];
            var fns = firstFns;
            var run = function() {
                var runFns = fns;
                fns = firstFns.length ? secondFns : firstFns;
                running = true;
                waiting = false;
                while (runFns.length) {
                    runFns.shift()();
                }
                running = false;
            };
            var rafBatch = function(fn, queue) {
                if (running && !queue) {
                    fn.apply(this, arguments);
                } else {
                    fns.push(fn);
                    if (!waiting) {
                        waiting = true;
                        (document.hidden ? setTimeout : requestAnimationFrame)(run);
                    }
                }
            };
            rafBatch._lsFlush = run;
            return rafBatch;
        })();
        var rAFIt = function(fn, simple) {
            return simple ? function() {
                rAF(fn);
            } : function() {
                var that = this;
                var args = arguments;
                rAF(function() {
                    fn.apply(that, args);
                });
            };
        };
        var throttle = function(fn) {
            var running;
            var lastTime = 0;
            var gDelay = 125;
            var RIC_DEFAULT_TIMEOUT = 666;
            var rICTimeout = RIC_DEFAULT_TIMEOUT;
            var run = function() {
                running = false;
                lastTime = Date.now();
                fn();
            };
            var idleCallback = requestIdleCallback ? function() {
                requestIdleCallback(run, {
                    timeout: rICTimeout
                });
                if (rICTimeout !== RIC_DEFAULT_TIMEOUT) {
                    rICTimeout = RIC_DEFAULT_TIMEOUT;
                }
            } : rAFIt(function() {
                setTimeout(run);
            }, true);
            return function(isPriority) {
                var delay;
                if ((isPriority = isPriority === true)) {
                    rICTimeout = 44;
                }
                if (running) {
                    return;
                }
                running = true;
                delay = gDelay - (Date.now() - lastTime);
                if (delay < 0) {
                    delay = 0;
                }
                if (isPriority || (delay < 9 && requestIdleCallback)) {
                    idleCallback();
                } else {
                    setTimeout(idleCallback, delay);
                }
            };
        };
        var debounce = function(func) {
            var timeout, timestamp;
            var wait = 99;
            var run = function() {
                timeout = null;
                func();
            };
            var later = function() {
                var last = Date.now() - timestamp;
                if (last < wait) {
                    setTimeout(later, wait - last);
                } else {
                    (requestIdleCallback || run)(run);
                }
            };
            return function() {
                timestamp = Date.now();
                if (!timeout) {
                    timeout = setTimeout(later, wait);
                }
            };
        };
        var loader = (function() {
            var lazyloadElems, preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
            var eLvW, elvH, eLtop, eLleft, eLright, eLbottom;
            var defaultExpand, preloadExpand, hFac;
            var regImg = /^img$/i;
            var regIframe = /^iframe$/i;
            var supportScroll = ('onscroll' in window) && !(/glebot/.test(navigator.userAgent));
            var shrinkExpand = 0;
            var currentExpand = 0;
            var isLoading = 0;
            var lowRuns = -1;
            var resetPreloading = function(e) {
                isLoading--;
                if (e && e.target) {
                    addRemoveLoadEvents(e.target, resetPreloading);
                }
                if (!e || isLoading < 0 || !e.target) {
                    isLoading = 0;
                }
            };
            var isNestedVisible = function(elem, elemExpand) {
                var outerRect;
                var parent = elem;
                var visible = getCSS(document.body, 'visibility') == 'hidden' || getCSS(elem, 'visibility') != 'hidden';
                eLtop -= elemExpand;
                eLbottom += elemExpand;
                eLleft -= elemExpand;
                eLright += elemExpand;
                while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
                    visible = ((getCSS(parent, 'opacity') || 1) > 0);
                    if (visible && getCSS(parent, 'overflow') != 'visible') {
                        outerRect = parent.getBoundingClientRect();
                        visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
                    }
                }
                return visible;
            };
            var checkElements = function() {
                var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal;
                if ((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
                    i = 0;
                    lowRuns++;
                    if (preloadExpand == null) {
                        if (!('expand' in lazySizesConfig)) {
                            lazySizesConfig.expand = docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370;
                        }
                        defaultExpand = lazySizesConfig.expand;
                        preloadExpand = defaultExpand * lazySizesConfig.expFactor;
                    }
                    if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {
                        currentExpand = preloadExpand;
                        lowRuns = 0;
                    } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
                        currentExpand = defaultExpand;
                    } else {
                        currentExpand = shrinkExpand;
                    }
                    for (; i < eLlen; i++) {
                        if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
                            continue;
                        }
                        if (!supportScroll) {
                            unveilElement(lazyloadElems[i]);
                            continue;
                        }
                        if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {
                            elemExpand = currentExpand;
                        }
                        if (beforeExpandVal !== elemExpand) {
                            eLvW = innerWidth + (elemExpand * hFac);
                            elvH = innerHeight + elemExpand;
                            elemNegativeExpand = elemExpand * -1;
                            beforeExpandVal = elemExpand;
                        }
                        rect = lazyloadElems[i].getBoundingClientRect();
                        if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && ((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) || isNestedVisible(lazyloadElems[i], elemExpand))) {
                            unveilElement(lazyloadElems[i]);
                            loadedSomething = true;
                            if (isLoading > 9) {
                                break;
                            }
                        } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesConfig.preloadAfterLoad) && (preloadElems[0] || (!elemExpandVal && ((eLbottom || eLright || eLleft || eLtop) || lazyloadElems[i][_getAttribute](lazySizesConfig.sizesAttr) != 'auto')))) {
                            autoLoadElem = preloadElems[0] || lazyloadElems[i];
                        }
                    }
                    if (autoLoadElem && !loadedSomething) {
                        unveilElement(autoLoadElem);
                    }
                }
            };
            var throttledCheckElements = throttle(checkElements);
            var switchLoadingClass = function(e) {
                addClass(e.target, lazySizesConfig.loadedClass);
                removeClass(e.target, lazySizesConfig.loadingClass);
                addRemoveLoadEvents(e.target, rafSwitchLoadingClass);
            };
            var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
            var rafSwitchLoadingClass = function(e) {
                rafedSwitchLoadingClass({
                    target: e.target
                });
            };
            var changeIframeSrc = function(elem, src) {
                try {
                    elem.contentWindow.location.replace(src);
                } catch (e) {
                    elem.src = src;
                }
            };
            var handleSources = function(source) {
                var customMedia, parent;
                var sourceSrcset = source[_getAttribute](lazySizesConfig.srcsetAttr);
                if ((customMedia = lazySizesConfig.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')])) {
                    source.setAttribute('media', customMedia);
                }
                if (sourceSrcset) {
                    source.setAttribute('srcset', sourceSrcset);
                }
                if (customMedia) {
                    parent = source.parentNode;
                    parent.insertBefore(source.cloneNode(), source);
                    parent.removeChild(source);
                }
            };
            var lazyUnveil = rAFIt(function(elem, detail, isAuto, sizes, isImg) {
                var src, srcset, parent, isPicture, event, firesLoad;
                if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {
                    if (sizes) {
                        if (isAuto) {
                            addClass(elem, lazySizesConfig.autosizesClass);
                        } else {
                            elem.setAttribute('sizes', sizes);
                        }
                    }
                    srcset = elem[_getAttribute](lazySizesConfig.srcsetAttr);
                    src = elem[_getAttribute](lazySizesConfig.srcAttr);
                    if (isImg) {
                        parent = elem.parentNode;
                        isPicture = parent && regPicture.test(parent.nodeName || '');
                    }
                    firesLoad = detail.firesLoad || (('src' in elem) && (srcset || src || isPicture));
                    event = {
                        target: elem
                    };
                    if (firesLoad) {
                        addRemoveLoadEvents(elem, resetPreloading, true);
                        clearTimeout(resetPreloadingTimer);
                        resetPreloadingTimer = setTimeout(resetPreloading, 2500);
                        addClass(elem, lazySizesConfig.loadingClass);
                        addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
                    }
                    if (isPicture) {
                        forEach.call(parent.getElementsByTagName('source'), handleSources);
                    }
                    if (srcset) {
                        elem.setAttribute('srcset', srcset);
                    } else if (src && !isPicture) {
                        if (regIframe.test(elem.nodeName)) {
                            changeIframeSrc(elem, src);
                        } else {
                            elem.src = src;
                        }
                    }
                    if (srcset || isPicture) {
                        updatePolyfill(elem, {
                            src: src
                        });
                    }
                }
                if (elem._lazyRace) {
                    delete elem._lazyRace;
                }
                removeClass(elem, lazySizesConfig.lazyClass);
                rAF(function() {
                    if (!firesLoad || (elem.complete && elem.naturalWidth > 1)) {
                        if (firesLoad) {
                            resetPreloading(event);
                        } else {
                            isLoading--;
                        }
                        switchLoadingClass(event);
                    }
                }, true);
            });
            var unveilElement = function(elem) {
                var detail;
                var isImg = regImg.test(elem.nodeName);
                var sizes = isImg && (elem[_getAttribute](lazySizesConfig.sizesAttr) || elem[_getAttribute]('sizes'));
                var isAuto = sizes == 'auto';
                if ((isAuto || !isCompleted) && isImg && (elem.src || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesConfig.errorClass)) {
                    return;
                }
                detail = triggerEvent(elem, 'lazyunveilread').detail;
                if (isAuto) {
                    autoSizer.updateElem(elem, true, elem.offsetWidth);
                }
                elem._lazyRace = true;
                isLoading++;
                lazyUnveil(elem, detail, isAuto, sizes, isImg);
            };
            var onload = function() {
                if (isCompleted) {
                    return;
                }
                if (Date.now() - started < 999) {
                    setTimeout(onload, 999);
                    return;
                }
                var afterScroll = debounce(function() {
                    lazySizesConfig.loadMode = 3;
                    throttledCheckElements();
                });
                isCompleted = true;
                lazySizesConfig.loadMode = 3;
                throttledCheckElements();
                addEventListener('scroll', function() {
                    if (lazySizesConfig.loadMode == 3) {
                        lazySizesConfig.loadMode = 2;
                    }
                    afterScroll();
                }, true);
            };
            return {
                _: function() {
                    started = Date.now();
                    lazyloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass);
                    preloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + ' ' + lazySizesConfig.preloadClass);
                    hFac = lazySizesConfig.hFac;
                    addEventListener('scroll', throttledCheckElements, true);
                    addEventListener('resize', throttledCheckElements, true);
                    if (window.MutationObserver) {
                        new MutationObserver(throttledCheckElements).observe(docElem, {
                            childList: true,
                            subtree: true,
                            attributes: true
                        });
                    } else {
                        docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);
                        docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);
                        setInterval(throttledCheckElements, 999);
                    }
                    addEventListener('hashchange', throttledCheckElements, true);
                    ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend', 'webkitAnimationEnd'].forEach(function(name) {
                        document[_addEventListener](name, throttledCheckElements, true);
                    });
                    if ((/d$|^c/.test(document.readyState))) {
                        onload();
                    } else {
                        addEventListener('load', onload);
                        document[_addEventListener]('DOMContentLoaded', throttledCheckElements);
                        setTimeout(onload, 20000);
                    }
                    if (lazyloadElems.length) {
                        checkElements();
                        rAF._lsFlush();
                    } else {
                        throttledCheckElements();
                    }
                },
                checkElems: throttledCheckElements,
                unveil: unveilElement
            };
        })();
        var autoSizer = (function() {
            var autosizesElems;
            var sizeElement = rAFIt(function(elem, parent, event, width) {
                var sources, i, len;
                elem._lazysizesWidth = width;
                width += 'px';
                elem.setAttribute('sizes', width);
                if (regPicture.test(parent.nodeName || '')) {
                    sources = parent.getElementsByTagName('source');
                    for (i = 0, len = sources.length; i < len; i++) {
                        sources[i].setAttribute('sizes', width);
                    }
                }
                if (!event.detail.dataAttr) {
                    updatePolyfill(elem, event.detail);
                }
            });
            var getSizeElement = function(elem, dataAttr, width) {
                var event;
                var parent = elem.parentNode;
                if (parent) {
                    width = getWidth(elem, parent, width);
                    event = triggerEvent(elem, 'lazybeforesizes', {
                        width: width,
                        dataAttr: !!dataAttr
                    });
                    if (!event.defaultPrevented) {
                        width = event.detail.width;
                        if (width && width !== elem._lazysizesWidth) {
                            sizeElement(elem, parent, event, width);
                        }
                    }
                }
            };
            var updateElementsSizes = function() {
                var i;
                var len = autosizesElems.length;
                if (len) {
                    i = 0;
                    for (; i < len; i++) {
                        getSizeElement(autosizesElems[i]);
                    }
                }
            };
            var debouncedUpdateElementsSizes = debounce(updateElementsSizes);
            return {
                _: function() {
                    autosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass);
                    addEventListener('resize', debouncedUpdateElementsSizes);
                },
                checkElems: debouncedUpdateElementsSizes,
                updateElem: getSizeElement
            };
        })();
        var init = function() {
            if (!init.i) {
                init.i = true;
                autoSizer._();
                loader._();
            }
        };
        (function() {
            var prop;
            var lazySizesDefaults = {
                lazyClass: 'lazyload',
                loadedClass: 'lazyloaded',
                loadingClass: 'lazyloading',
                preloadClass: 'lazypreload',
                errorClass: 'lazyerror',
                autosizesClass: 'lazyautosizes',
                srcAttr: 'data-src',
                srcsetAttr: 'data-srcset',
                sizesAttr: 'data-sizes',
                minSize: 40,
                customMedia: {},
                init: true,
                expFactor: 1.5,
                hFac: 0.8,
                loadMode: 2
            };
            lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};
            for (prop in lazySizesDefaults) {
                if (!(prop in lazySizesConfig)) {
                    lazySizesConfig[prop] = lazySizesDefaults[prop];
                }
            }
            window.lazySizesConfig = lazySizesConfig;
            setTimeout(function() {
                if (lazySizesConfig.init) {
                    init();
                }
            });
        })();
        return {
            cfg: lazySizesConfig,
            autoSizer: autoSizer,
            loader: loader,
            init: init,
            uP: updatePolyfill,
            aC: addClass,
            rC: removeClass,
            hC: hasClass,
            fire: triggerEvent,
            gW: getWidth,
            rAF: rAF,
        };
    }));
}), (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    /*! picturefill - v3.0.2 - 2016-02-12
     * https://scottjehl.github.io/picturefill/
     * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT
     */
    /*! Gecko-Picture - v1.0
     * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture
     * Firefox's early picture implementation (prior to FF41) is static and does
     * not react to viewport changes. This tiny module fixes this.
     */
    (function(window) {
        var ua = navigator.userAgent;
        if (window.HTMLPictureElement && ((/ecko/).test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 < 45)) {
            addEventListener("resize", (function() {
                var timer;
                var dummySrc = document.createElement("source");
                var fixRespimg = function(img) {
                    var source, sizes;
                    var picture = img.parentNode;
                    if (picture.nodeName.toUpperCase() === "PICTURE") {
                        source = dummySrc.cloneNode();
                        picture.insertBefore(source, picture.firstElementChild);
                        setTimeout(function() {
                            picture.removeChild(source);
                        });
                    } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {
                        img._pfLastSize = img.offsetWidth;
                        sizes = img.sizes;
                        img.sizes += ",100vw";
                        setTimeout(function() {
                            img.sizes = sizes;
                        });
                    }
                };
                var findPictureImgs = function() {
                    var i;
                    var imgs = document.querySelectorAll("picture > img, img[srcset][sizes]");
                    for (i = 0; i < imgs.length; i++) {
                        fixRespimg(imgs[i]);
                    }
                };
                var onResize = function() {
                    clearTimeout(timer);
                    timer = setTimeout(findPictureImgs, 99);
                };
                var mq = window.matchMedia && matchMedia("(orientation: landscape)");
                var init = function() {
                    onResize();
                    if (mq && mq.addListener) {
                        mq.addListener(onResize);
                    }
                };
                dummySrc.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                if (/^[c|i]|d$/.test(document.readyState || "")) {
                    init();
                } else {
                    document.addEventListener("DOMContentLoaded", init);
                }
                return onResize;
            })());
        }
    })(window);
    /*! Picturefill - v3.0.2
     * http://scottjehl.github.io/picturefill
     * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;
     * License: MIT
     */
    (function(window, document, undefined) {
        "use strict";
        document.createElement("picture");
        var warn, eminpx, alwaysCheckWDescriptor, evalId;
        var pf = {};
        var isSupportTestReady = false;
        var noop = function() {};
        var image = document.createElement("img");
        var getImgAttr = image.getAttribute;
        var setImgAttr = image.setAttribute;
        var removeImgAttr = image.removeAttribute;
        var docElem = document.documentElement;
        var types = {};
        var cfg = {
            algorithm: ""
        };
        var srcAttr = "data-pfsrc";
        var srcsetAttr = srcAttr + "set";
        var ua = navigator.userAgent;
        var supportAbort = (/rident/).test(ua) || ((/ecko/).test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 > 35);
        var curSrcProp = "currentSrc";
        var regWDesc = /\s+\+?\d+(e\d+)?w/;
        var regSize = /(\([^)]+\))?\s*(.+)/;
        var setOptions = window.picturefillCFG;
        var baseStyle = "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)";
        var fsCss = "font-size:100%!important;";
        var isVwDirty = true;
        var cssCache = {};
        var sizeLengthCache = {};
        var DPR = window.devicePixelRatio;
        var units = {
            px: 1,
            "in": 96
        };
        var anchor = document.createElement("a");
        var alreadyRun = false;
        var regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
            regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
            regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
            regexTrailingCommas = /[,]+$/,
            regexNonNegativeInteger = /^\d+$/,
            regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
        var on = function(obj, evt, fn, capture) {
            if (obj.addEventListener) {
                obj.addEventListener(evt, fn, capture || false);
            } else if (obj.attachEvent) {
                obj.attachEvent("on" + evt, fn);
            }
        };
        var memoize = function(fn) {
            var cache = {};
            return function(input) {
                if (!(input in cache)) {
                    cache[input] = fn(input);
                }
                return cache[input];
            };
        };

        function isSpace(c) {
            return (c === "\u0020" || c === "\u0009" || c === "\u000A" || c === "\u000C" || c === "\u000D");
        }
        var evalCSS = (function() {
            var regLength = /^([\d\.]+)(em|vw|px)$/;
            var replace = function() {
                var args = arguments,
                    index = 0,
                    string = args[0];
                while (++index in args) {
                    string = string.replace(args[index], args[++index]);
                }
                return string;
            };
            var buildStr = memoize(function(css) {
                return "return " + replace((css || "").toLowerCase(), /\band\b/g, "&&", /,/g, "||", /min-([a-z-\s]+):/g, "e.$1>=", /max-([a-z-\s]+):/g, "e.$1<=", /calc([^)]+)/g, "($1)", /(\d+[\.]*[\d]*)([a-z]+)/g, "($1 * e.$2)", /^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/ig, "") + ";";
            });
            return function(css, length) {
                var parsedLength;
                if (!(css in cssCache)) {
                    cssCache[css] = false;
                    if (length && (parsedLength = css.match(regLength))) {
                        cssCache[css] = parsedLength[1] * units[parsedLength[2]];
                    } else {
                        try {
                            cssCache[css] = new Function("e", buildStr(css))(units);
                        } catch (e) {}
                    }
                }
                return cssCache[css];
            };
        })();
        var setResolution = function(candidate, sizesattr) {
            if (candidate.w) {
                candidate.cWidth = pf.calcListLength(sizesattr || "100vw");
                candidate.res = candidate.w / candidate.cWidth;
            } else {
                candidate.res = candidate.d;
            }
            return candidate;
        };
        var picturefill = function(opt) {
            if (!isSupportTestReady) {
                return;
            }
            var elements, i, plen;
            var options = opt || {};
            if (options.elements && options.elements.nodeType === 1) {
                if (options.elements.nodeName.toUpperCase() === "IMG") {
                    options.elements = [options.elements];
                } else {
                    options.context = options.elements;
                    options.elements = null;
                }
            }
            elements = options.elements || pf.qsa((options.context || document), (options.reevaluate || options.reselect) ? pf.sel : pf.selShort);
            if ((plen = elements.length)) {
                pf.setupRun(options);
                alreadyRun = true;
                for (i = 0; i < plen; i++) {
                    pf.fillImg(elements[i], options);
                }
                pf.teardownRun(options);
            }
        };
        warn = (window.console && console.warn) ? function(message) {
            console.warn(message);
        } : noop;
        if (!(curSrcProp in image)) {
            curSrcProp = "src";
        }
        types["image/jpeg"] = true;
        types["image/gif"] = true;
        types["image/png"] = true;

        function detectTypeSupport(type, typeUri) {
            var image = new window.Image();
            image.onerror = function() {
                types[type] = false;
                picturefill();
            };
            image.onload = function() {
                types[type] = image.width === 1;
                picturefill();
            };
            image.src = typeUri;
            return "pending";
        }
        types["image/svg+xml"] = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");

        function updateMetrics() {
            isVwDirty = false;
            DPR = window.devicePixelRatio;
            cssCache = {};
            sizeLengthCache = {};
            pf.DPR = DPR || 1;
            units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);
            units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);
            units.vw = units.width / 100;
            units.vh = units.height / 100;
            evalId = [units.height, units.width, DPR].join("-");
            units.em = pf.getEmValue();
            units.rem = units.em;
        }

        function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {
            var bonusFactor, tooMuch, bonus, meanDensity;
            if (cfg.algorithm === "saveData") {
                if (lowerValue > 2.7) {
                    meanDensity = dprValue + 1;
                } else {
                    tooMuch = higherValue - dprValue;
                    bonusFactor = Math.pow(lowerValue - 0.6, 1.5);
                    bonus = tooMuch * bonusFactor;
                    if (isCached) {
                        bonus += 0.1 * bonusFactor;
                    }
                    meanDensity = lowerValue + bonus;
                }
            } else {
                meanDensity = (dprValue > 1) ? Math.sqrt(lowerValue * higherValue) : lowerValue;
            }
            return meanDensity > dprValue;
        }

        function applyBestCandidate(img) {
            var srcSetCandidates;
            var matchingSet = pf.getSet(img);
            var evaluated = false;
            if (matchingSet !== "pending") {
                evaluated = evalId;
                if (matchingSet) {
                    srcSetCandidates = pf.setRes(matchingSet);
                    pf.applySetCandidate(srcSetCandidates, img);
                }
            }
            img[pf.ns].evaled = evaluated;
        }

        function ascendingSort(a, b) {
            return a.res - b.res;
        }

        function setSrcToCur(img, src, set) {
            var candidate;
            if (!set && src) {
                set = img[pf.ns].sets;
                set = set && set[set.length - 1];
            }
            candidate = getCandidateForSrc(src, set);
            if (candidate) {
                src = pf.makeUrl(src);
                img[pf.ns].curSrc = src;
                img[pf.ns].curCan = candidate;
                if (!candidate.res) {
                    setResolution(candidate, candidate.set.sizes);
                }
            }
            return candidate;
        }

        function getCandidateForSrc(src, set) {
            var i, candidate, candidates;
            if (src && set) {
                candidates = pf.parseSet(set);
                src = pf.makeUrl(src);
                for (i = 0; i < candidates.length; i++) {
                    if (src === pf.makeUrl(candidates[i].url)) {
                        candidate = candidates[i];
                        break;
                    }
                }
            }
            return candidate;
        }

        function getAllSourceElements(picture, candidates) {
            var i, len, source, srcset;
            var sources = picture.getElementsByTagName("source");
            for (i = 0, len = sources.length; i < len; i++) {
                source = sources[i];
                source[pf.ns] = true;
                srcset = source.getAttribute("srcset");
                if (srcset) {
                    candidates.push({
                        srcset: srcset,
                        media: source.getAttribute("media"),
                        type: source.getAttribute("type"),
                        sizes: source.getAttribute("sizes")
                    });
                }
            }
        }

        function parseSrcset(input, set) {
            function collectCharacters(regEx) {
                var chars, match = regEx.exec(input.substring(pos));
                if (match) {
                    chars = match[0];
                    pos += chars.length;
                    return chars;
                }
            }
            var inputLength = input.length,
                url, descriptors, currentDescriptor, state, c, pos = 0,
                candidates = [];

            function parseDescriptors() {
                var pError = false,
                    w, d, h, i, candidate = {},
                    desc, lastChar, value, intVal, floatVal;
                for (i = 0; i < descriptors.length; i++) {
                    desc = descriptors[i];
                    lastChar = desc[desc.length - 1];
                    value = desc.substring(0, desc.length - 1);
                    intVal = parseInt(value, 10);
                    floatVal = parseFloat(value);
                    if (regexNonNegativeInteger.test(value) && (lastChar === "w")) {
                        if (w || d) {
                            pError = true;
                        }
                        if (intVal === 0) {
                            pError = true;
                        } else {
                            w = intVal;
                        }
                    } else if (regexFloatingPoint.test(value) && (lastChar === "x")) {
                        if (w || d || h) {
                            pError = true;
                        }
                        if (floatVal < 0) {
                            pError = true;
                        } else {
                            d = floatVal;
                        }
                    } else if (regexNonNegativeInteger.test(value) && (lastChar === "h")) {
                        if (h || d) {
                            pError = true;
                        }
                        if (intVal === 0) {
                            pError = true;
                        } else {
                            h = intVal;
                        }
                    } else {
                        pError = true;
                    }
                }
                if (!pError) {
                    candidate.url = url;
                    if (w) {
                        candidate.w = w;
                    }
                    if (d) {
                        candidate.d = d;
                    }
                    if (h) {
                        candidate.h = h;
                    }
                    if (!h && !d && !w) {
                        candidate.d = 1;
                    }
                    if (candidate.d === 1) {
                        set.has1x = true;
                    }
                    candidate.set = set;
                    candidates.push(candidate);
                }
            }

            function tokenize() {
                collectCharacters(regexLeadingSpaces);
                currentDescriptor = "";
                state = "in descriptor";
                while (true) {
                    c = input.charAt(pos);
                    if (state === "in descriptor") {
                        if (isSpace(c)) {
                            if (currentDescriptor) {
                                descriptors.push(currentDescriptor);
                                currentDescriptor = "";
                                state = "after descriptor";
                            }
                        } else if (c === ",") {
                            pos += 1;
                            if (currentDescriptor) {
                                descriptors.push(currentDescriptor);
                            }
                            parseDescriptors();
                            return;
                        } else if (c === "\u0028") {
                            currentDescriptor = currentDescriptor + c;
                            state = "in parens";
                        } else if (c === "") {
                            if (currentDescriptor) {
                                descriptors.push(currentDescriptor);
                            }
                            parseDescriptors();
                            return;
                        } else {
                            currentDescriptor = currentDescriptor + c;
                        }
                    } else if (state === "in parens") {
                        if (c === ")") {
                            currentDescriptor = currentDescriptor + c;
                            state = "in descriptor";
                        } else if (c === "") {
                            descriptors.push(currentDescriptor);
                            parseDescriptors();
                            return;
                        } else {
                            currentDescriptor = currentDescriptor + c;
                        }
                    } else if (state === "after descriptor") {
                        if (isSpace(c)) {} else if (c === "") {
                            parseDescriptors();
                            return;
                        } else {
                            state = "in descriptor";
                            pos -= 1;
                        }
                    }
                    pos += 1;
                }
            }
            while (true) {
                collectCharacters(regexLeadingCommasOrSpaces);
                if (pos >= inputLength) {
                    return candidates;
                }
                url = collectCharacters(regexLeadingNotSpaces);
                descriptors = [];
                if (url.slice(-1) === ",") {
                    url = url.replace(regexTrailingCommas, "");
                    parseDescriptors();
                } else {
                    tokenize();
                }
            }
        }

        function parseSizes(strValue) {
            var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i;
            var regexCssCalc = /^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;
            var i;
            var unparsedSizesList;
            var unparsedSizesListLength;
            var unparsedSize;
            var lastComponentValue;
            var size;

            function parseComponentValues(str) {
                var chrctr;
                var component = "";
                var componentArray = [];
                var listArray = [];
                var parenDepth = 0;
                var pos = 0;
                var inComment = false;

                function pushComponent() {
                    if (component) {
                        componentArray.push(component);
                        component = "";
                    }
                }

                function pushComponentArray() {
                    if (componentArray[0]) {
                        listArray.push(componentArray);
                        componentArray = [];
                    }
                }
                while (true) {
                    chrctr = str.charAt(pos);
                    if (chrctr === "") {
                        pushComponent();
                        pushComponentArray();
                        return listArray;
                    } else if (inComment) {
                        if ((chrctr === "*") && (str[pos + 1] === "/")) {
                            inComment = false;
                            pos += 2;
                            pushComponent();
                            continue;
                        } else {
                            pos += 1;
                            continue;
                        }
                    } else if (isSpace(chrctr)) {
                        if ((str.charAt(pos - 1) && isSpace(str.charAt(pos - 1))) || !component) {
                            pos += 1;
                            continue;
                        } else if (parenDepth === 0) {
                            pushComponent();
                            pos += 1;
                            continue;
                        } else {
                            chrctr = " ";
                        }
                    } else if (chrctr === "(") {
                        parenDepth += 1;
                    } else if (chrctr === ")") {
                        parenDepth -= 1;
                    } else if (chrctr === ",") {
                        pushComponent();
                        pushComponentArray();
                        pos += 1;
                        continue;
                    } else if ((chrctr === "/") && (str.charAt(pos + 1) === "*")) {
                        inComment = true;
                        pos += 2;
                        continue;
                    }
                    component = component + chrctr;
                    pos += 1;
                }
            }

            function isValidNonNegativeSourceSizeValue(s) {
                if (regexCssLengthWithUnits.test(s) && (parseFloat(s) >= 0)) {
                    return true;
                }
                if (regexCssCalc.test(s)) {
                    return true;
                }
                if ((s === "0") || (s === "-0") || (s === "+0")) {
                    return true;
                }
                return false;
            }
            unparsedSizesList = parseComponentValues(strValue);
            unparsedSizesListLength = unparsedSizesList.length;
            for (i = 0; i < unparsedSizesListLength; i++) {
                unparsedSize = unparsedSizesList[i];
                lastComponentValue = unparsedSize[unparsedSize.length - 1];
                if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {
                    size = lastComponentValue;
                    unparsedSize.pop();
                } else {
                    continue;
                }
                if (unparsedSize.length === 0) {
                    return size;
                }
                unparsedSize = unparsedSize.join(" ");
                if (!(pf.matchesMedia(unparsedSize))) {
                    continue;
                }
                return size;
            }
            return "100vw";
        }
        pf.ns = ("pf" + new Date().getTime()).substr(0, 9);
        pf.supSrcset = "srcset" in image;
        pf.supSizes = "sizes" in image;
        pf.supPicture = !!window.HTMLPictureElement;
        if (pf.supSrcset && pf.supPicture && !pf.supSizes) {
            (function(image2) {
                image.srcset = "data:,a";
                image2.src = "data:,a";
                pf.supSrcset = image.complete === image2.complete;
                pf.supPicture = pf.supSrcset && pf.supPicture;
            })(document.createElement("img"));
        }
        if (pf.supSrcset && !pf.supSizes) {
            (function() {
                var width2 = "data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==";
                var width1 = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                var img = document.createElement("img");
                var test = function() {
                    var width = img.width;
                    if (width === 2) {
                        pf.supSizes = true;
                    }
                    alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;
                    isSupportTestReady = true;
                    setTimeout(picturefill);
                };
                img.onload = test;
                img.onerror = test;
                img.setAttribute("sizes", "9px");
                img.srcset = width1 + " 1w," + width2 + " 9w";
                img.src = width1;
            })();
        } else {
            isSupportTestReady = true;
        }
        pf.selShort = "picture>img,img[srcset]";
        pf.sel = pf.selShort;
        pf.cfg = cfg;
        pf.DPR = (DPR || 1);
        pf.u = units;
        pf.types = types;
        pf.setSize = noop;
        pf.makeUrl = memoize(function(src) {
            anchor.href = src;
            return anchor.href;
        });
        pf.qsa = function(context, sel) {
            return ("querySelector" in context) ? context.querySelectorAll(sel) : [];
        };
        pf.matchesMedia = function() {
            if (window.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches) {
                pf.matchesMedia = function(media) {
                    return !media || (matchMedia(media).matches);
                };
            } else {
                pf.matchesMedia = pf.mMQ;
            }
            return pf.matchesMedia.apply(this, arguments);
        };
        pf.mMQ = function(media) {
            return media ? evalCSS(media) : true;
        };
        pf.calcLength = function(sourceSizeValue) {
            var value = evalCSS(sourceSizeValue, true) || false;
            if (value < 0) {
                value = false;
            }
            return value;
        };
        pf.supportsType = function(type) {
            return (type) ? types[type] : true;
        };
        pf.parseSize = memoize(function(sourceSizeStr) {
            var match = (sourceSizeStr || "").match(regSize);
            return {
                media: match && match[1],
                length: match && match[2]
            };
        });
        pf.parseSet = function(set) {
            if (!set.cands) {
                set.cands = parseSrcset(set.srcset, set);
            }
            return set.cands;
        };
        pf.getEmValue = function() {
            var body;
            if (!eminpx && (body = document.body)) {
                var div = document.createElement("div"),
                    originalHTMLCSS = docElem.style.cssText,
                    originalBodyCSS = body.style.cssText;
                div.style.cssText = baseStyle;
                docElem.style.cssText = fsCss;
                body.style.cssText = fsCss;
                body.appendChild(div);
                eminpx = div.offsetWidth;
                body.removeChild(div);
                eminpx = parseFloat(eminpx, 10);
                docElem.style.cssText = originalHTMLCSS;
                body.style.cssText = originalBodyCSS;
            }
            return eminpx || 16;
        };
        pf.calcListLength = function(sourceSizeListStr) {
            if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {
                var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));
                sizeLengthCache[sourceSizeListStr] = !winningLength ? units.width : winningLength;
            }
            return sizeLengthCache[sourceSizeListStr];
        };
        pf.setRes = function(set) {
            var candidates;
            if (set) {
                candidates = pf.parseSet(set);
                for (var i = 0, len = candidates.length; i < len; i++) {
                    setResolution(candidates[i], set.sizes);
                }
            }
            return candidates;
        };
        pf.setRes.res = setResolution;
        pf.applySetCandidate = function(candidates, img) {
            if (!candidates.length) {
                return;
            }
            var candidate, i, j, length, bestCandidate, curSrc, curCan, candidateSrc, abortCurSrc;
            var imageData = img[pf.ns];
            var dpr = pf.DPR;
            curSrc = imageData.curSrc || img[curSrcProp];
            curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set);
            if (curCan && curCan.set === candidates[0].set) {
                abortCurSrc = (supportAbort && !img.complete && curCan.res - 0.1 > dpr);
                if (!abortCurSrc) {
                    curCan.cached = true;
                    if (curCan.res >= dpr) {
                        bestCandidate = curCan;
                    }
                }
            }
            if (!bestCandidate) {
                candidates.sort(ascendingSort);
                length = candidates.length;
                bestCandidate = candidates[length - 1];
                for (i = 0; i < length; i++) {
                    candidate = candidates[i];
                    if (candidate.res >= dpr) {
                        j = i - 1;
                        if (candidates[j] && (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) && chooseLowRes(candidates[j].res, candidate.res, dpr, candidates[j].cached)) {
                            bestCandidate = candidates[j];
                        } else {
                            bestCandidate = candidate;
                        }
                        break;
                    }
                }
            }
            if (bestCandidate) {
                candidateSrc = pf.makeUrl(bestCandidate.url);
                imageData.curSrc = candidateSrc;
                imageData.curCan = bestCandidate;
                if (candidateSrc !== curSrc) {
                    pf.setSrc(img, bestCandidate);
                }
                pf.setSize(img);
            }
        };
        pf.setSrc = function(img, bestCandidate) {
            var origWidth;
            img.src = bestCandidate.url;
            if (bestCandidate.set.type === "image/svg+xml") {
                origWidth = img.style.width;
                img.style.width = (img.offsetWidth + 1) + "px";
                if (img.offsetWidth + 1) {
                    img.style.width = origWidth;
                }
            }
        };
        pf.getSet = function(img) {
            var i, set, supportsType;
            var match = false;
            var sets = img[pf.ns].sets;
            for (i = 0; i < sets.length && !match; i++) {
                set = sets[i];
                if (!set.srcset || !pf.matchesMedia(set.media) || !(supportsType = pf.supportsType(set.type))) {
                    continue;
                }
                if (supportsType === "pending") {
                    set = supportsType;
                }
                match = set;
                break;
            }
            return match;
        };
        pf.parseSets = function(element, parent, options) {
            var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;
            var hasPicture = parent && parent.nodeName.toUpperCase() === "PICTURE";
            var imageData = element[pf.ns];
            if (imageData.src === undefined || options.src) {
                imageData.src = getImgAttr.call(element, "src");
                if (imageData.src) {
                    setImgAttr.call(element, srcAttr, imageData.src);
                } else {
                    removeImgAttr.call(element, srcAttr);
                }
            }
            if (imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset) {
                srcsetAttribute = getImgAttr.call(element, "srcset");
                imageData.srcset = srcsetAttribute;
                srcsetParsed = true;
            }
            imageData.sets = [];
            if (hasPicture) {
                imageData.pic = true;
                getAllSourceElements(parent, imageData.sets);
            }
            if (imageData.srcset) {
                imageSet = {
                    srcset: imageData.srcset,
                    sizes: getImgAttr.call(element, "sizes")
                };
                imageData.sets.push(imageSet);
                isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || "");
                if (!isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x) {
                    imageSet.srcset += ", " + imageData.src;
                    imageSet.cands.push({
                        url: imageData.src,
                        d: 1,
                        set: imageSet
                    });
                }
            } else if (imageData.src) {
                imageData.sets.push({
                    srcset: imageData.src,
                    sizes: null
                });
            }
            imageData.curCan = null;
            imageData.curSrc = undefined;
            imageData.supported = !(hasPicture || (imageSet && !pf.supSrcset) || (isWDescripor && !pf.supSizes));
            if (srcsetParsed && pf.supSrcset && !imageData.supported) {
                if (srcsetAttribute) {
                    setImgAttr.call(element, srcsetAttr, srcsetAttribute);
                    element.srcset = "";
                } else {
                    removeImgAttr.call(element, srcsetAttr);
                }
            }
            if (imageData.supported && !imageData.srcset && ((!imageData.src && element.src) || element.src !== pf.makeUrl(imageData.src))) {
                if (imageData.src === null) {
                    element.removeAttribute("src");
                } else {
                    element.src = imageData.src;
                }
            }
            imageData.parsed = true;
        };
        pf.fillImg = function(element, options) {
            var imageData;
            var extreme = options.reselect || options.reevaluate;
            if (!element[pf.ns]) {
                element[pf.ns] = {};
            }
            imageData = element[pf.ns];
            if (!extreme && imageData.evaled === evalId) {
                return;
            }
            if (!imageData.parsed || options.reevaluate) {
                pf.parseSets(element, element.parentNode, options);
            }
            if (!imageData.supported) {
                applyBestCandidate(element);
            } else {
                imageData.evaled = evalId;
            }
        };
        pf.setupRun = function() {
            if (!alreadyRun || isVwDirty || (DPR !== window.devicePixelRatio)) {
                updateMetrics();
            }
        };
        if (pf.supPicture) {
            picturefill = noop;
            pf.fillImg = noop;
        } else {
            (function() {
                var isDomReady;
                var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;
                var run = function() {
                    var readyState = document.readyState || "";
                    timerId = setTimeout(run, readyState === "loading" ? 200 : 999);
                    if (document.body) {
                        pf.fillImgs();
                        isDomReady = isDomReady || regReady.test(readyState);
                        if (isDomReady) {
                            clearTimeout(timerId);
                        }
                    }
                };
                var timerId = setTimeout(run, document.body ? 9 : 99);
                var debounce = function(func, wait) {
                    var timeout, timestamp;
                    var later = function() {
                        var last = (new Date()) - timestamp;
                        if (last < wait) {
                            timeout = setTimeout(later, wait - last);
                        } else {
                            timeout = null;
                            func();
                        }
                    };
                    return function() {
                        timestamp = new Date();
                        if (!timeout) {
                            timeout = setTimeout(later, wait);
                        }
                    };
                };
                var lastClientWidth = docElem.clientHeight;
                var onResize = function() {
                    isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;
                    lastClientWidth = docElem.clientHeight;
                    if (isVwDirty) {
                        pf.fillImgs();
                    }
                };
                on(window, "resize", debounce(onResize, 99));
                on(document, "readystatechange", run);
            })();
        }
        pf.picturefill = picturefill;
        pf.fillImgs = picturefill;
        pf.teardownRun = noop;
        picturefill._ = pf;
        window.picturefillCFG = {
            pf: pf,
            push: function(args) {
                var name = args.shift();
                if (typeof pf[name] === "function") {
                    pf[name].apply(pf, args);
                } else {
                    cfg[name] = args[0];
                    if (alreadyRun) {
                        pf.fillImgs({
                            reselect: true
                        });
                    }
                }
            }
        };
        while (setOptions && setOptions.length) {
            window.picturefillCFG.push(setOptions.shift());
        }
        window.picturefill = picturefill;
        if (typeof module === "object" && typeof module.exports === "object") {
            module.exports = picturefill;
        } else if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return picturefill;
            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
        if (!pf.supPicture) {
            types["image/webp"] = detectTypeSupport("image/webp", "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==");
        }
    })(window, document);
}), (function(module, exports) {;
    (function($, window, document, undefined) {
        function Owl(element, options) {
            this.settings = null;
            this.options = $.extend({}, Owl.Defaults, options);
            this.$element = $(element);
            this._handlers = {};
            this._plugins = {};
            this._supress = {};
            this._current = null;
            this._speed = null;
            this._coordinates = [];
            this._breakpoint = null;
            this._width = null;
            this._items = [];
            this._clones = [];
            this._mergers = [];
            this._widths = [];
            this._invalidated = {};
            this._pipe = [];
            this._drag = {
                time: null,
                target: null,
                pointer: null,
                stage: {
                    start: null,
                    current: null
                },
                direction: null
            };
            this._states = {
                current: {},
                tags: {
                    'initializing': ['busy'],
                    'animating': ['busy'],
                    'dragging': ['interacting']
                }
            };
            $.each(['onResize', 'onThrottledResize'], $.proxy(function(i, handler) {
                this._handlers[handler] = $.proxy(this[handler], this);
            }, this));
            $.each(Owl.Plugins, $.proxy(function(key, plugin) {
                this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);
            }, this));
            $.each(Owl.Workers, $.proxy(function(priority, worker) {
                this._pipe.push({
                    'filter': worker.filter,
                    'run': $.proxy(worker.run, this)
                });
            }, this));
            this.setup();
            this.initialize();
        }
        Owl.Defaults = {
            items: 3,
            loop: false,
            center: false,
            rewind: false,
            checkVisibility: true,
            mouseDrag: true,
            touchDrag: true,
            pullDrag: true,
            freeDrag: false,
            margin: 0,
            stagePadding: 0,
            merge: false,
            mergeFit: true,
            autoWidth: false,
            startPosition: 0,
            rtl: false,
            smartSpeed: 250,
            fluidSpeed: false,
            dragEndSpeed: false,
            responsive: {},
            responsiveRefreshRate: 200,
            responsiveBaseElement: window,
            fallbackEasing: 'swing',
            slideTransition: '',
            info: false,
            nestedItemSelector: false,
            itemElement: 'div',
            stageElement: 'div',
            refreshClass: 'owl-refresh',
            loadedClass: 'owl-loaded',
            loadingClass: 'owl-loading',
            rtlClass: 'owl-rtl',
            responsiveClass: 'owl-responsive',
            dragClass: 'owl-drag',
            itemClass: 'owl-item',
            stageClass: 'owl-stage',
            stageOuterClass: 'owl-stage-outer',
            grabClass: 'owl-grab'
        };
        Owl.Width = {
            Default: 'default',
            Inner: 'inner',
            Outer: 'outer'
        };
        Owl.Type = {
            Event: 'event',
            State: 'state'
        };
        Owl.Plugins = {};
        Owl.Workers = [{
            filter: ['width', 'settings'],
            run: function() {
                this._width = this.$element.width();
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function(cache) {
                cache.current = this._items && this._items[this.relative(this._current)];
            }
        }, {
            filter: ['items', 'settings'],
            run: function() {
                this.$stage.children('.cloned').remove();
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function(cache) {
                var margin = this.settings.margin || '',
                    grid = !this.settings.autoWidth,
                    rtl = this.settings.rtl,
                    css = {
                        'width': 'auto',
                        'margin-left': rtl ? margin : '',
                        'margin-right': rtl ? '' : margin
                    };
                !grid && this.$stage.children().css(css);
                cache.css = css;
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function(cache) {
                var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
                    merge = null,
                    iterator = this._items.length,
                    grid = !this.settings.autoWidth,
                    widths = [];
                cache.items = {
                    merge: false,
                    width: width
                };
                while (iterator--) {
                    merge = this._mergers[iterator];
                    merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;
                    cache.items.merge = merge > 1 || cache.items.merge;
                    widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
                }
                this._widths = widths;
            }
        }, {
            filter: ['items', 'settings'],
            run: function() {
                var clones = [],
                    items = this._items,
                    settings = this.settings,
                    view = Math.max(settings.items * 2, 4),
                    size = Math.ceil(items.length / 2) * 2,
                    repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
                    append = '',
                    prepend = '';
                repeat /= 2;
                while (repeat > 0) {
                    clones.push(this.normalize(clones.length / 2, true));
                    append = append + items[clones[clones.length - 1]][0].outerHTML;
                    clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
                    prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
                    repeat -= 1;
                }
                this._clones = clones;
                $(append).addClass('cloned').appendTo(this.$stage);
                $(prepend).addClass('cloned').prependTo(this.$stage);
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function() {
                var rtl = this.settings.rtl ? 1 : -1,
                    size = this._clones.length + this._items.length,
                    iterator = -1,
                    previous = 0,
                    current = 0,
                    coordinates = [];
                while (++iterator < size) {
                    previous = coordinates[iterator - 1] || 0;
                    current = this._widths[this.relative(iterator)] + this.settings.margin;
                    coordinates.push(previous + current * rtl);
                }
                this._coordinates = coordinates;
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function() {
                var padding = this.settings.stagePadding,
                    coordinates = this._coordinates,
                    css = {
                        'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
                        'padding-left': padding || '',
                        'padding-right': padding || ''
                    };
                this.$stage.css(css);
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function(cache) {
                var iterator = this._coordinates.length,
                    grid = !this.settings.autoWidth,
                    items = this.$stage.children();
                if (grid && cache.items.merge) {
                    while (iterator--) {
                        cache.css.width = this._widths[this.relative(iterator)];
                        items.eq(iterator).css(cache.css);
                    }
                } else if (grid) {
                    cache.css.width = cache.items.width;
                    items.css(cache.css);
                }
            }
        }, {
            filter: ['items'],
            run: function() {
                this._coordinates.length < 1 && this.$stage.removeAttr('style');
            }
        }, {
            filter: ['width', 'items', 'settings'],
            run: function(cache) {
                cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
                cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
                this.reset(cache.current);
            }
        }, {
            filter: ['position'],
            run: function() {
                this.animate(this.coordinates(this._current));
            }
        }, {
            filter: ['width', 'position', 'items', 'settings'],
            run: function() {
                var rtl = this.settings.rtl ? 1 : -1,
                    padding = this.settings.stagePadding * 2,
                    begin = this.coordinates(this.current()) + padding,
                    end = begin + this.width() * rtl,
                    inner, outer, matches = [],
                    i, n;
                for (i = 0, n = this._coordinates.length; i < n; i++) {
                    inner = this._coordinates[i - 1] || 0;
                    outer = Math.abs(this._coordinates[i]) + padding * rtl;
                    if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end))) || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
                        matches.push(i);
                    }
                }
                this.$stage.children('.active').removeClass('active');
                this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');
                this.$stage.children('.center').removeClass('center');
                if (this.settings.center) {
                    this.$stage.children().eq(this.current()).addClass('center');
                }
            }
        }];
        Owl.prototype.initializeStage = function() {
            this.$stage = this.$element.find('.' + this.settings.stageClass);
            if (this.$stage.length) {
                return;
            }
            this.$element.addClass(this.options.loadingClass);
            this.$stage = $('<' + this.settings.stageElement + '>', {
                "class": this.settings.stageClass
            }).wrap($('<div/>', {
                "class": this.settings.stageOuterClass
            }));
            this.$element.append(this.$stage.parent());
        };
        Owl.prototype.initializeItems = function() {
            var $items = this.$element.find('.owl-item');
            if ($items.length) {
                this._items = $items.get().map(function(item) {
                    return $(item);
                });
                this._mergers = this._items.map(function() {
                    return 1;
                });
                this.refresh();
                return;
            }
            this.replace(this.$element.children().not(this.$stage.parent()));
            if (this.isVisible()) {
                this.refresh();
            } else {
                this.invalidate('width');
            }
            this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);
        };
        Owl.prototype.initialize = function() {
            this.enter('initializing');
            this.trigger('initialize');
            this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);
            if (this.settings.autoWidth && !this.is('pre-loading')) {
                var imgs, nestedSelector, width;
                imgs = this.$element.find('img');
                nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
                width = this.$element.children(nestedSelector).width();
                if (imgs.length && width <= 0) {
                    this.preloadAutoWidthImages(imgs);
                }
            }
            this.initializeStage();
            this.initializeItems();
            this.registerEventHandlers();
            this.leave('initializing');
            this.trigger('initialized');
        };
        Owl.prototype.isVisible = function() {
            return this.settings.checkVisibility ? this.$element.is(':visible') : true;
        };
        Owl.prototype.setup = function() {
            var viewport = this.viewport(),
                overwrites = this.options.responsive,
                match = -1,
                settings = null;
            if (!overwrites) {
                settings = $.extend({}, this.options);
            } else {
                $.each(overwrites, function(breakpoint) {
                    if (breakpoint <= viewport && breakpoint > match) {
                        match = Number(breakpoint);
                    }
                });
                settings = $.extend({}, this.options, overwrites[match]);
                if (typeof settings.stagePadding === 'function') {
                    settings.stagePadding = settings.stagePadding();
                }
                delete settings.responsive;
                if (settings.responsiveClass) {
                    this.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match));
                }
            }
            this.trigger('change', {
                property: {
                    name: 'settings',
                    value: settings
                }
            });
            this._breakpoint = match;
            this.settings = settings;
            this.invalidate('settings');
            this.trigger('changed', {
                property: {
                    name: 'settings',
                    value: this.settings
                }
            });
        };
        Owl.prototype.optionsLogic = function() {
            if (this.settings.autoWidth) {
                this.settings.stagePadding = false;
                this.settings.merge = false;
            }
        };
        Owl.prototype.prepare = function(item) {
            var event = this.trigger('prepare', {
                content: item
            });
            if (!event.data) {
                event.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item)
            }
            this.trigger('prepared', {
                content: event.data
            });
            return event.data;
        };
        Owl.prototype.update = function() {
            var i = 0,
                n = this._pipe.length,
                filter = $.proxy(function(p) {
                    return this[p]
                }, this._invalidated),
                cache = {};
            while (i < n) {
                if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
                    this._pipe[i].run(cache);
                }
                i++;
            }
            this._invalidated = {};
            !this.is('valid') && this.enter('valid');
        };
        Owl.prototype.width = function(dimension) {
            dimension = dimension || Owl.Width.Default;
            switch (dimension) {
                case Owl.Width.Inner:
                case Owl.Width.Outer:
                    return this._width;
                default:
                    return this._width - this.settings.stagePadding * 2 + this.settings.margin;
            }
        };
        Owl.prototype.refresh = function() {
            this.enter('refreshing');
            this.trigger('refresh');
            this.setup();
            this.optionsLogic();
            this.$element.addClass(this.options.refreshClass);
            this.update();
            this.$element.removeClass(this.options.refreshClass);
            this.leave('refreshing');
            this.trigger('refreshed');
        };
        Owl.prototype.onThrottledResize = function() {
            window.clearTimeout(this.resizeTimer);
            this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
        };
        Owl.prototype.onResize = function() {
            if (!this._items.length) {
                return false;
            }
            if (this._width === this.$element.width()) {
                return false;
            }
            if (!this.isVisible()) {
                return false;
            }
            this.enter('resizing');
            if (this.trigger('resize').isDefaultPrevented()) {
                this.leave('resizing');
                return false;
            }
            this.invalidate('width');
            this.refresh();
            this.leave('resizing');
            this.trigger('resized');
        };
        Owl.prototype.registerEventHandlers = function() {
            if ($.support.transition) {
                this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
            }
            if (this.settings.responsive !== false) {
                this.on(window, 'resize', this._handlers.onThrottledResize);
            }
            if (this.settings.mouseDrag) {
                this.$element.addClass(this.options.dragClass);
                this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
                this.$stage.on('dragstart.owl.core selectstart.owl.core', function() {
                    return false
                });
            }
            if (this.settings.touchDrag) {
                this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
                this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
            }
        };
        Owl.prototype.onDragStart = function(event) {
            var stage = null;
            if (event.which === 3) {
                return;
            }
            if ($.support.transform) {
                stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
                stage = {
                    x: stage[stage.length === 16 ? 12 : 4],
                    y: stage[stage.length === 16 ? 13 : 5]
                };
            } else {
                stage = this.$stage.position();
                stage = {
                    x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
                    y: stage.top
                };
            }
            if (this.is('animating')) {
                $.support.transform ? this.animate(stage.x) : this.$stage.stop()
                this.invalidate('position');
            }
            this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');
            this.speed(0);
            this._drag.time = new Date().getTime();
            this._drag.target = $(event.target);
            this._drag.stage.start = stage;
            this._drag.stage.current = stage;
            this._drag.pointer = this.pointer(event);
            $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));
            $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
                var delta = this.difference(this._drag.pointer, this.pointer(event));
                $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));
                if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
                    return;
                }
                event.preventDefault();
                this.enter('dragging');
                this.trigger('drag');
            }, this));
        };
        Owl.prototype.onDragMove = function(event) {
            var minimum = null,
                maximum = null,
                pull = null,
                delta = this.difference(this._drag.pointer, this.pointer(event)),
                stage = this.difference(this._drag.stage.start, delta);
            if (!this.is('dragging')) {
                return;
            }
            event.preventDefault();
            if (this.settings.loop) {
                minimum = this.coordinates(this.minimum());
                maximum = this.coordinates(this.maximum() + 1) - minimum;
                stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
            } else {
                minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
                maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
                pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
                stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
            }
            this._drag.stage.current = stage;
            this.animate(stage.x);
        };
        Owl.prototype.onDragEnd = function(event) {
            var delta = this.difference(this._drag.pointer, this.pointer(event)),
                stage = this._drag.stage.current,
                direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';
            $(document).off('.owl.core');
            this.$element.removeClass(this.options.grabClass);
            if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
                this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
                this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
                this.invalidate('position');
                this.update();
                this._drag.direction = direction;
                if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
                    this._drag.target.one('click.owl.core', function() {
                        return false;
                    });
                }
            }
            if (!this.is('dragging')) {
                return;
            }
            this.leave('dragging');
            this.trigger('dragged');
        };
        Owl.prototype.closest = function(coordinate, direction) {
            var position = -1,
                pull = 30,
                width = this.width(),
                coordinates = this.coordinates();
            if (!this.settings.freeDrag) {
                $.each(coordinates, $.proxy(function(index, value) {
                    if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
                        position = index;
                    } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
                        position = index + 1;
                    } else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
                        position = direction === 'left' ? index + 1 : index;
                    }
                    return position === -1;
                }, this));
            }
            if (!this.settings.loop) {
                if (this.op(coordinate, '>', coordinates[this.minimum()])) {
                    position = coordinate = this.minimum();
                } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
                    position = coordinate = this.maximum();
                }
            }
            return position;
        };
        Owl.prototype.animate = function(coordinate) {
            var animate = this.speed() > 0;
            this.is('animating') && this.onTransitionEnd();
            if (animate) {
                this.enter('animating');
                this.trigger('translate');
            }
            if ($.support.transform3d && $.support.transition) {
                this.$stage.css({
                    transform: 'translate3d(' + coordinate + 'px,0px,0px)',
                    transition: (this.speed() / 1000) + 's' + (this.settings.slideTransition ? ' ' + this.settings.slideTransition : '')
                });
            } else if (animate) {
                this.$stage.animate({
                    left: coordinate + 'px'
                }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
            } else {
                this.$stage.css({
                    left: coordinate + 'px'
                });
            }
        };
        Owl.prototype.is = function(state) {
            return this._states.current[state] && this._states.current[state] > 0;
        };
        Owl.prototype.current = function(position) {
            if (position === undefined) {
                return this._current;
            }
            if (this._items.length === 0) {
                return undefined;
            }
            position = this.normalize(position);
            if (this._current !== position) {
                var event = this.trigger('change', {
                    property: {
                        name: 'position',
                        value: position
                    }
                });
                if (event.data !== undefined) {
                    position = this.normalize(event.data);
                }
                this._current = position;
                this.invalidate('position');
                this.trigger('changed', {
                    property: {
                        name: 'position',
                        value: this._current
                    }
                });
            }
            return this._current;
        };
        Owl.prototype.invalidate = function(part) {
            if ($.type(part) === 'string') {
                this._invalidated[part] = true;
                this.is('valid') && this.leave('valid');
            }
            return $.map(this._invalidated, function(v, i) {
                return i
            });
        };
        Owl.prototype.reset = function(position) {
            position = this.normalize(position);
            if (position === undefined) {
                return;
            }
            this._speed = 0;
            this._current = position;
            this.suppress(['translate', 'translated']);
            this.animate(this.coordinates(position));
            this.release(['translate', 'translated']);
        };
        Owl.prototype.normalize = function(position, relative) {
            var n = this._items.length,
                m = relative ? 0 : this._clones.length;
            if (!this.isNumeric(position) || n < 1) {
                position = undefined;
            } else if (position < 0 || position >= n + m) {
                position = ((position - m / 2) % n + n) % n + m / 2;
            }
            return position;
        };
        Owl.prototype.relative = function(position) {
            position -= this._clones.length / 2;
            return this.normalize(position, true);
        };
        Owl.prototype.maximum = function(relative) {
            var settings = this.settings,
                maximum = this._coordinates.length,
                iterator, reciprocalItemsWidth, elementWidth;
            if (settings.loop) {
                maximum = this._clones.length / 2 + this._items.length - 1;
            } else if (settings.autoWidth || settings.merge) {
                iterator = this._items.length;
                if (iterator) {
                    reciprocalItemsWidth = this._items[--iterator].width();
                    elementWidth = this.$element.width();
                    while (iterator--) {
                        reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
                        if (reciprocalItemsWidth > elementWidth) {
                            break;
                        }
                    }
                }
                maximum = iterator + 1;
            } else if (settings.center) {
                maximum = this._items.length - 1;
            } else {
                maximum = this._items.length - settings.items;
            }
            if (relative) {
                maximum -= this._clones.length / 2;
            }
            return Math.max(maximum, 0);
        };
        Owl.prototype.minimum = function(relative) {
            return relative ? 0 : this._clones.length / 2;
        };
        Owl.prototype.items = function(position) {
            if (position === undefined) {
                return this._items.slice();
            }
            position = this.normalize(position, true);
            return this._items[position];
        };
        Owl.prototype.mergers = function(position) {
            if (position === undefined) {
                return this._mergers.slice();
            }
            position = this.normalize(position, true);
            return this._mergers[position];
        };
        Owl.prototype.clones = function(position) {
            var odd = this._clones.length / 2,
                even = odd + this._items.length,
                map = function(index) {
                    return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2
                };
            if (position === undefined) {
                return $.map(this._clones, function(v, i) {
                    return map(i)
                });
            }
            return $.map(this._clones, function(v, i) {
                return v === position ? map(i) : null
            });
        };
        Owl.prototype.speed = function(speed) {
            if (speed !== undefined) {
                this._speed = speed;
            }
            return this._speed;
        };
        Owl.prototype.coordinates = function(position) {
            var multiplier = 1,
                newPosition = position - 1,
                coordinate;
            if (position === undefined) {
                return $.map(this._coordinates, $.proxy(function(coordinate, index) {
                    return this.coordinates(index);
                }, this));
            }
            if (this.settings.center) {
                if (this.settings.rtl) {
                    multiplier = -1;
                    newPosition = position + 1;
                }
                coordinate = this._coordinates[position];
                coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
            } else {
                coordinate = this._coordinates[newPosition] || 0;
            }
            coordinate = Math.ceil(coordinate);
            return coordinate;
        };
        Owl.prototype.duration = function(from, to, factor) {
            if (factor === 0) {
                return 0;
            }
            return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
        };
        Owl.prototype.to = function(position, speed) {
            var current = this.current(),
                revert = null,
                distance = position - this.relative(current),
                direction = (distance > 0) - (distance < 0),
                items = this._items.length,
                minimum = this.minimum(),
                maximum = this.maximum();
            if (this.settings.loop) {
                if (!this.settings.rewind && Math.abs(distance) > items / 2) {
                    distance += direction * -1 * items;
                }
                position = current + distance;
                revert = ((position - minimum) % items + items) % items + minimum;
                if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
                    current = revert - distance;
                    position = revert;
                    this.reset(current);
                }
            } else if (this.settings.rewind) {
                maximum += 1;
                position = (position % maximum + maximum) % maximum;
            } else {
                position = Math.max(minimum, Math.min(maximum, position));
            }
            this.speed(this.duration(current, position, speed));
            this.current(position);
            if (this.isVisible()) {
                this.update();
            }
        };
        Owl.prototype.next = function(speed) {
            speed = speed || false;
            this.to(this.relative(this.current()) + 1, speed);
        };
        Owl.prototype.prev = function(speed) {
            speed = speed || false;
            this.to(this.relative(this.current()) - 1, speed);
        };
        Owl.prototype.onTransitionEnd = function(event) {
            if (event !== undefined) {
                event.stopPropagation();
                if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
                    return false;
                }
            }
            this.leave('animating');
            this.trigger('translated');
        };
        Owl.prototype.viewport = function() {
            var width;
            if (this.options.responsiveBaseElement !== window) {
                width = $(this.options.responsiveBaseElement).width();
            } else if (window.innerWidth) {
                width = window.innerWidth;
            } else if (document.documentElement && document.documentElement.clientWidth) {
                width = document.documentElement.clientWidth;
            } else {
                console.warn('Can not detect viewport width.');
            }
            return width;
        };
        Owl.prototype.replace = function(content) {
            this.$stage.empty();
            this._items = [];
            if (content) {
                content = (content instanceof jQuery) ? content : $(content);
            }
            if (this.settings.nestedItemSelector) {
                content = content.find('.' + this.settings.nestedItemSelector);
            }
            content.filter(function() {
                return this.nodeType === 1;
            }).each($.proxy(function(index, item) {
                item = this.prepare(item);
                this.$stage.append(item);
                this._items.push(item);
                this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
            }, this));
            this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);
            this.invalidate('items');
        };
        Owl.prototype.add = function(content, position) {
            var current = this.relative(this._current);
            position = position === undefined ? this._items.length : this.normalize(position, true);
            content = content instanceof jQuery ? content : $(content);
            this.trigger('add', {
                content: content,
                position: position
            });
            content = this.prepare(content);
            if (this._items.length === 0 || position === this._items.length) {
                this._items.length === 0 && this.$stage.append(content);
                this._items.length !== 0 && this._items[position - 1].after(content);
                this._items.push(content);
                this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
            } else {
                this._items[position].before(content);
                this._items.splice(position, 0, content);
                this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
            }
            this._items[current] && this.reset(this._items[current].index());
            this.invalidate('items');
            this.trigger('added', {
                content: content,
                position: position
            });
        };
        Owl.prototype.remove = function(position) {
            position = this.normalize(position, true);
            if (position === undefined) {
                return;
            }
            this.trigger('remove', {
                content: this._items[position],
                position: position
            });
            this._items[position].remove();
            this._items.splice(position, 1);
            this._mergers.splice(position, 1);
            this.invalidate('items');
            this.trigger('removed', {
                content: null,
                position: position
            });
        };
        Owl.prototype.preloadAutoWidthImages = function(images) {
            images.each($.proxy(function(i, element) {
                this.enter('pre-loading');
                element = $(element);
                $(new Image()).one('load', $.proxy(function(e) {
                    element.attr('src', e.target.src);
                    element.css('opacity', 1);
                    this.leave('pre-loading');
                    !this.is('pre-loading') && !this.is('initializing') && this.refresh();
                }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
            }, this));
        };
        Owl.prototype.destroy = function() {
            this.$element.off('.owl.core');
            this.$stage.off('.owl.core');
            $(document).off('.owl.core');
            if (this.settings.responsive !== false) {
                window.clearTimeout(this.resizeTimer);
                this.off(window, 'resize', this._handlers.onThrottledResize);
            }
            for (var i in this._plugins) {
                this._plugins[i].destroy();
            }
            this.$stage.children('.cloned').remove();
            this.$stage.unwrap();
            this.$stage.children().contents().unwrap();
            this.$stage.children().unwrap();
            this.$stage.remove();
            this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), '')).removeData('owl.carousel1');
        };
        Owl.prototype.op = function(a, o, b) {
            var rtl = this.settings.rtl;
            switch (o) {
                case '<':
                    return rtl ? a > b : a < b;
                case '>':
                    return rtl ? a < b : a > b;
                case '>=':
                    return rtl ? a <= b : a >= b;
                case '<=':
                    return rtl ? a >= b : a <= b;
                default:
                    break;
            }
        };
        Owl.prototype.on = function(element, event, listener, capture) {
            if (element.addEventListener) {
                element.addEventListener(event, listener, capture);
            } else if (element.attachEvent) {
                element.attachEvent('on' + event, listener);
            }
        };
        Owl.prototype.off = function(element, event, listener, capture) {
            if (element.removeEventListener) {
                element.removeEventListener(event, listener, capture);
            } else if (element.detachEvent) {
                element.detachEvent('on' + event, listener);
            }
        };
        Owl.prototype.trigger = function(name, data, namespace, state, enter) {
            var status = {
                    item: {
                        count: this._items.length,
                        index: this.current()
                    }
                },
                handler = $.camelCase($.grep(['on', name, namespace], function(v) {
                    return v
                }).join('-').toLowerCase()),
                event = $.Event([name, 'owl', namespace || 'carousel1'].join('.').toLowerCase(), $.extend({
                    relatedTarget: this
                }, status, data));
            if (!this._supress[name]) {
                $.each(this._plugins, function(name, plugin) {
                    if (plugin.onTrigger) {
                        plugin.onTrigger(event);
                    }
                });
                this.register({
                    type: Owl.Type.Event,
                    name: name
                });
                this.$element.trigger(event);
                if (this.settings && typeof this.settings[handler] === 'function') {
                    this.settings[handler].call(this, event);
                }
            }
            return event;
        };
        Owl.prototype.enter = function(name) {
            $.each([name].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                if (this._states.current[name] === undefined) {
                    this._states.current[name] = 0;
                }
                this._states.current[name]++;
            }, this));
        };
        Owl.prototype.leave = function(name) {
            $.each([name].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                this._states.current[name]--;
            }, this));
        };
        Owl.prototype.register = function(object) {
            if (object.type === Owl.Type.Event) {
                if (!$.event.special[object.name]) {
                    $.event.special[object.name] = {};
                }
                if (!$.event.special[object.name].owl) {
                    var _default = $.event.special[object.name]._default;
                    $.event.special[object.name]._default = function(e) {
                        if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
                            return _default.apply(this, arguments);
                        }
                        return e.namespace && e.namespace.indexOf('owl') > -1;
                    };
                    $.event.special[object.name].owl = true;
                }
            } else if (object.type === Owl.Type.State) {
                if (!this._states.tags[object.name]) {
                    this._states.tags[object.name] = object.tags;
                } else {
                    this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
                }
                this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
                    return $.inArray(tag, this._states.tags[object.name]) === i;
                }, this));
            }
        };
        Owl.prototype.suppress = function(events) {
            $.each(events, $.proxy(function(index, event) {
                this._supress[event] = true;
            }, this));
        };
        Owl.prototype.release = function(events) {
            $.each(events, $.proxy(function(index, event) {
                delete this._supress[event];
            }, this));
        };
        Owl.prototype.pointer = function(event) {
            var result = {
                x: null,
                y: null
            };
            event = event.originalEvent || event || window.event;
            event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;
            if (event.pageX) {
                result.x = event.pageX;
                result.y = event.pageY;
            } else {
                result.x = event.clientX;
                result.y = event.clientY;
            }
            return result;
        };
        Owl.prototype.isNumeric = function(number) {
            return !isNaN(parseFloat(number));
        };
        Owl.prototype.difference = function(first, second) {
            return {
                x: first.x - second.x,
                y: first.y - second.y
            };
        };
        $.fn.owlcarousel1 = function(option) {
            var args = Array.prototype.slice.call(arguments, 1);
            return this.each(function() {
                var $this = $(this),
                    data = $this.data('owl.carousel1');
                if (!data) {
                    data = new Owl(this, typeof option == 'object' && option);
                    $this.data('owl.carousel1', data);
                    $.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function(i, event) {
                        data.register({
                            type: Owl.Type.Event,
                            name: event
                        });
                        data.$element.on(event + '.owl.carousel1.core', $.proxy(function(e) {
                            if (e.namespace && e.relatedTarget !== this) {
                                this.suppress([event]);
                                data[event].apply(this, [].slice.call(arguments, 1));
                                this.release([event]);
                            }
                        }, data));
                    });
                }
                if (typeof option == 'string' && option.charAt(0) !== '_') {
                    data[option].apply(data, args);
                }
            });
        };
        $.fn.owlcarousel1.Constructor = Owl;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var AutoRefresh = function(carousel1) {
            this._core = carousel1;
            this._interval = null;
            this._visible = null;
            this._handlers = {
                'initialized.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.autoRefresh) {
                        this.watch();
                    }
                }, this)
            };
            this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);
            this._core.$element.on(this._handlers);
        };
        AutoRefresh.Defaults = {
            autoRefresh: true,
            autoRefreshInterval: 500
        };
        AutoRefresh.prototype.watch = function() {
            if (this._interval) {
                return;
            }
            this._visible = this._core.isVisible();
            this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
        };
        AutoRefresh.prototype.refresh = function() {
            if (this._core.isVisible() === this._visible) {
                return;
            }
            this._visible = !this._visible;
            this._core.$element.toggleClass('owl-hidden', !this._visible);
            this._visible && (this._core.invalidate('width') && this._core.refresh());
        };
        AutoRefresh.prototype.destroy = function() {
            var handler, property;
            window.clearInterval(this._interval);
            for (handler in this._handlers) {
                this._core.$element.off(handler, this._handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.AutoRefresh = AutoRefresh;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var Lazy = function(carousel1) {
            this._core = carousel1;
            this._loaded = [];
            this._handlers = {
                'initialized.owl.carousel1 change.owl.carousel1 resized.owl.carousel1': $.proxy(function(e) {
                    if (!e.namespace) {
                        return;
                    }
                    if (!this._core.settings || !this._core.settings.lazyLoad) {
                        return;
                    }
                    if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
                        var settings = this._core.settings,
                            n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
                            i = ((settings.center && n * -1) || 0),
                            position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
                            clones = this._core.clones().length,
                            load = $.proxy(function(i, v) {
                                this.load(v)
                            }, this);
                        if (settings.lazyLoadEager > 0) {
                            n += settings.lazyLoadEager;
                            if (settings.loop) {
                                position -= settings.lazyLoadEager;
                                n++;
                            }
                        }
                        while (i++ < n) {
                            this.load(clones / 2 + this._core.relative(position));
                            clones && $.each(this._core.clones(this._core.relative(position)), load);
                            position++;
                        }
                    }
                }, this)
            };
            this._core.options = $.extend({}, Lazy.Defaults, this._core.options);
            this._core.$element.on(this._handlers);
        };
        Lazy.Defaults = {
            lazyLoad: false,
            lazyLoadEager: 0
        };
        Lazy.prototype.load = function(position) {
            var $item = this._core.$stage.children().eq(position),
                $elements = $item && $item.find('.owl-lazy');
            if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
                return;
            }
            $elements.each($.proxy(function(index, element) {
                var $element = $(element),
                    image, url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');
                this._core.trigger('load', {
                    element: $element,
                    url: url
                }, 'lazy');
                if ($element.is('img')) {
                    $element.one('load.owl.lazy', $.proxy(function() {
                        $element.css('opacity', 1);
                        this._core.trigger('loaded', {
                            element: $element,
                            url: url
                        }, 'lazy');
                    }, this)).attr('src', url);
                } else if ($element.is('source')) {
                    $element.one('load.owl.lazy', $.proxy(function() {
                        this._core.trigger('loaded', {
                            element: $element,
                            url: url
                        }, 'lazy');
                    }, this)).attr('srcset', url);
                } else {
                    image = new Image();
                    image.onload = $.proxy(function() {
                        $element.css({
                            'background-image': 'url("' + url + '")',
                            'opacity': '1'
                        });
                        this._core.trigger('loaded', {
                            element: $element,
                            url: url
                        }, 'lazy');
                    }, this);
                    image.src = url;
                }
            }, this));
            this._loaded.push($item.get(0));
        };
        Lazy.prototype.destroy = function() {
            var handler, property;
            for (handler in this.handlers) {
                this._core.$element.off(handler, this.handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.Lazy = Lazy;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var AutoHeight = function(carousel1) {
            this._core = carousel1;
            this._previousHeight = null;
            this._handlers = {
                'initialized.owl.carousel1 refreshed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.autoHeight) {
                        this.update();
                    }
                }, this),
                'changed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {
                        this.update();
                    }
                }, this),
                'loaded.owl.lazy': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
                        this.update();
                    }
                }, this)
            };
            this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);
            this._core.$element.on(this._handlers);
            this._intervalId = null;
            var refThis = this;
            $(window).on('load', function() {
                if (refThis._core.settings.autoHeight) {
                    refThis.update();
                }
            });
            $(window).resize(function() {
                if (refThis._core.settings.autoHeight) {
                    if (refThis._intervalId != null) {
                        clearTimeout(refThis._intervalId);
                    }
                    refThis._intervalId = setTimeout(function() {
                        refThis.update();
                    }, 250);
                }
            });
        };
        AutoHeight.Defaults = {
            autoHeight: false,
            autoHeightClass: 'owl-height'
        };
        AutoHeight.prototype.update = function() {
            var start = this._core._current,
                end = start + this._core.settings.items,
                lazyLoadEnabled = this._core.settings.lazyLoad,
                visible = this._core.$stage.children().toArray().slice(start, end),
                heights = [],
                maxheight = 0;
            $.each(visible, function(index, item) {
                heights.push($(item).height());
            });
            maxheight = Math.max.apply(null, heights);
            if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
                maxheight = this._previousHeight;
            }
            this._previousHeight = maxheight;
            this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);
        };
        AutoHeight.prototype.destroy = function() {
            var handler, property;
            for (handler in this._handlers) {
                this._core.$element.off(handler, this._handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] !== 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.AutoHeight = AutoHeight;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var Video = function(carousel1) {
            this._core = carousel1;
            this._videos = {};
            this._playing = null;
            this._handlers = {
                'initialized.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace) {
                        this._core.register({
                            type: 'state',
                            name: 'playing',
                            tags: ['interacting']
                        });
                    }
                }, this),
                'resize.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
                        e.preventDefault();
                    }
                }, this),
                'refreshed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.is('resizing')) {
                        this._core.$stage.find('.cloned .owl-video-frame').remove();
                    }
                }, this),
                'changed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && e.property.name === 'position' && this._playing) {
                        this.stop();
                    }
                }, this),
                'prepared.owl.carousel1': $.proxy(function(e) {
                    if (!e.namespace) {
                        return;
                    }
                    var $element = $(e.content).find('.owl-video');
                    if ($element.length) {
                        $element.css('display', 'none');
                        this.fetch($element, $(e.content));
                    }
                }, this)
            };
            this._core.options = $.extend({}, Video.Defaults, this._core.options);
            this._core.$element.on(this._handlers);
            this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
                this.play(e);
            }, this));
        };
        Video.Defaults = {
            video: false,
            videoHeight: false,
            videoWidth: false
        };
        Video.prototype.fetch = function(target, item) {
            var type = (function() {
                    if (target.attr('data-vimeo-id')) {
                        return 'vimeo';
                    } else if (target.attr('data-vzaar-id')) {
                        return 'vzaar'
                    } else {
                        return 'youtube';
                    }
                })(),
                id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
                width = target.attr('data-width') || this._core.settings.videoWidth,
                height = target.attr('data-height') || this._core.settings.videoHeight,
                url = target.attr('href');
            if (url) {
                id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);
                if (id[3].indexOf('youtu') > -1) {
                    type = 'youtube';
                } else if (id[3].indexOf('vimeo') > -1) {
                    type = 'vimeo';
                } else if (id[3].indexOf('vzaar') > -1) {
                    type = 'vzaar';
                } else {
                    throw new Error('Video URL not supported.');
                }
                id = id[6];
            } else {
                throw new Error('Missing video URL.');
            }
            this._videos[url] = {
                type: type,
                id: id,
                width: width,
                height: height
            };
            item.attr('data-video', url);
            this.thumbnail(target, this._videos[url]);
        };
        Video.prototype.thumbnail = function(target, video) {
            var tnLink, icon, path, dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
                customTn = target.find('img'),
                srcType = 'src',
                lazyClass = '',
                settings = this._core.settings,
                create = function(path) {
                    icon = '<div class="owl-video-play-icon"></div>';
                    if (settings.lazyLoad) {
                        tnLink = $('<div/>', {
                            "class": 'owl-video-tn ' + lazyClass,
                            "srcType": path
                        });
                    } else {
                        tnLink = $('<div/>', {
                            "class": "owl-video-tn",
                            "style": 'opacity:1;background-image:url(' + path + ')'
                        });
                    }
                    target.after(tnLink);
                    target.after(icon);
                };
            target.wrap($('<div/>', {
                "class": "owl-video-wrapper",
                "style": dimensions
            }));
            if (this._core.settings.lazyLoad) {
                srcType = 'data-src';
                lazyClass = 'owl-lazy';
            }
            if (customTn.length) {
                create(customTn.attr(srcType));
                customTn.remove();
                return false;
            }
            if (video.type === 'youtube') {
                path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
                create(path);
            } else if (video.type === 'vimeo') {
                $.ajax({
                    type: 'GET',
                    url: '//vimeo.com/api/v2/video/' + video.id + '.json',
                    jsonp: 'callback',
                    dataType: 'jsonp',
                    success: function(data) {
                        path = data[0].thumbnail_large;
                        create(path);
                    }
                });
            } else if (video.type === 'vzaar') {
                $.ajax({
                    type: 'GET',
                    url: '//vzaar.com/api/videos/' + video.id + '.json',
                    jsonp: 'callback',
                    dataType: 'jsonp',
                    success: function(data) {
                        path = data.framegrab_url;
                        create(path);
                    }
                });
            }
        };
        Video.prototype.stop = function() {
            this._core.trigger('stop', null, 'video');
            this._playing.find('.owl-video-frame').remove();
            this._playing.removeClass('owl-video-playing');
            this._playing = null;
            this._core.leave('playing');
            this._core.trigger('stopped', null, 'video');
        };
        Video.prototype.play = function(event) {
            var target = $(event.target),
                item = target.closest('.' + this._core.settings.itemClass),
                video = this._videos[item.attr('data-video')],
                width = video.width || '100%',
                height = video.height || this._core.$stage.height(),
                html, iframe;
            if (this._playing) {
                return;
            }
            this._core.enter('playing');
            this._core.trigger('play', null, 'video');
            item = this._core.items(this._core.relative(item.index()));
            this._core.reset(item.index());
            html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
            html.attr('height', height);
            html.attr('width', width);
            if (video.type === 'youtube') {
                html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);
            } else if (video.type === 'vimeo') {
                html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');
            } else if (video.type === 'vzaar') {
                html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');
            }
            iframe = $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find('.owl-video'));
            this._playing = item.addClass('owl-video-playing');
        };
        Video.prototype.isInFullScreen = function() {
            var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
            return element && $(element).parent().hasClass('owl-video-frame');
        };
        Video.prototype.destroy = function() {
            var handler, property;
            this._core.$element.off('click.owl.video');
            for (handler in this._handlers) {
                this._core.$element.off(handler, this._handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.Video = Video;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var Animate = function(scope) {
            this.core = scope;
            this.core.options = $.extend({}, Animate.Defaults, this.core.options);
            this.swapping = true;
            this.previous = undefined;
            this.next = undefined;
            this.handlers = {
                'change.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && e.property.name == 'position') {
                        this.previous = this.core.current();
                        this.next = e.property.value;
                    }
                }, this),
                'drag.owl.carousel1 dragged.owl.carousel1 translated.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace) {
                        this.swapping = e.type == 'translated';
                    }
                }, this),
                'translate.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
                        this.swap();
                    }
                }, this)
            };
            this.core.$element.on(this.handlers);
        };
        Animate.Defaults = {
            animateOut: false,
            animateIn: false
        };
        Animate.prototype.swap = function() {
            if (this.core.settings.items !== 1) {
                return;
            }
            if (!$.support.animation || !$.support.transition) {
                return;
            }
            this.core.speed(0);
            var left, clear = $.proxy(this.clear, this),
                previous = this.core.$stage.children().eq(this.previous),
                next = this.core.$stage.children().eq(this.next),
                incoming = this.core.settings.animateIn,
                outgoing = this.core.settings.animateOut;
            if (this.core.current() === this.previous) {
                return;
            }
            if (outgoing) {
                left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
                previous.one($.support.animation.end, clear).css({
                    'left': left + 'px'
                }).addClass('animated owl-animated-out').addClass(outgoing);
            }
            if (incoming) {
                next.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);
            }
        };
        Animate.prototype.clear = function(e) {
            $(e.target).css({
                'left': ''
            }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);
            this.core.onTransitionEnd();
        };
        Animate.prototype.destroy = function() {
            var handler, property;
            for (handler in this.handlers) {
                this.core.$element.off(handler, this.handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.Animate = Animate;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var Autoplay = function(carousel1) {
            this._core = carousel1;
            this._call = null;
            this._time = 0;
            this._timeout = 0;
            this._paused = true;
            this._handlers = {
                'changed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && e.property.name === 'settings') {
                        if (this._core.settings.autoplay) {
                            this.play();
                        } else {
                            this.stop();
                        }
                    } else if (e.namespace && e.property.name === 'position' && this._paused) {
                        this._time = 0;
                    }
                }, this),
                'initialized.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.autoplay) {
                        this.play();
                    }
                }, this),
                'play.owl.autoplay': $.proxy(function(e, t, s) {
                    if (e.namespace) {
                        this.play(t, s);
                    }
                }, this),
                'stop.owl.autoplay': $.proxy(function(e) {
                    if (e.namespace) {
                        this.stop();
                    }
                }, this),
                'mouseover.owl.autoplay': $.proxy(function() {
                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                        this.pause();
                    }
                }, this),
                'mouseleave.owl.autoplay': $.proxy(function() {
                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                        this.play();
                    }
                }, this),
                'touchstart.owl.core': $.proxy(function() {
                    if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                        this.pause();
                    }
                }, this),
                'touchend.owl.core': $.proxy(function() {
                    if (this._core.settings.autoplayHoverPause) {
                        this.play();
                    }
                }, this)
            };
            this._core.$element.on(this._handlers);
            this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
        };
        Autoplay.Defaults = {
            autoplay: false,
            autoplayTimeout: 5000,
            autoplayHoverPause: false,
            autoplaySpeed: false
        };
        Autoplay.prototype._next = function(speed) {
            this._call = window.setTimeout($.proxy(this._next, this, speed), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read());
            if (this._core.is('interacting') || document.hidden) {
                return;
            }
            this._core.next(speed || this._core.settings.autoplaySpeed);
        }
        Autoplay.prototype.read = function() {
            return new Date().getTime() - this._time;
        };
        Autoplay.prototype.play = function(timeout, speed) {
            var elapsed;
            if (!this._core.is('rotating')) {
                this._core.enter('rotating');
            }
            timeout = timeout || this._core.settings.autoplayTimeout;
            elapsed = Math.min(this._time % (this._timeout || timeout), timeout);
            if (this._paused) {
                this._time = this.read();
                this._paused = false;
            } else {
                window.clearTimeout(this._call);
            }
            this._time += this.read() % timeout - elapsed;
            this._timeout = timeout;
            this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
        };
        Autoplay.prototype.stop = function() {
            if (this._core.is('rotating')) {
                this._time = 0;
                this._paused = true;
                window.clearTimeout(this._call);
                this._core.leave('rotating');
            }
        };
        Autoplay.prototype.pause = function() {
            if (this._core.is('rotating') && !this._paused) {
                this._time = this.read();
                this._paused = true;
                window.clearTimeout(this._call);
            }
        };
        Autoplay.prototype.destroy = function() {
            var handler, property;
            this.stop();
            for (handler in this._handlers) {
                this._core.$element.off(handler, this._handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.autoplay = Autoplay;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        'use strict';
        var Navigation = function(carousel1) {
            this._core = carousel1;
            this._initialized = false;
            this._pages = [];
            this._controls = {};
            this._templates = [];
            this.$element = this._core.$element;
            this._overrides = {
                next: this._core.next,
                prev: this._core.prev,
                to: this._core.to
            };
            this._handlers = {
                'prepared.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.dotsData) {
                        this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
                            $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
                    }
                }, this),
                'added.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.dotsData) {
                        this._templates.splice(e.position, 0, this._templates.pop());
                    }
                }, this),
                'remove.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.dotsData) {
                        this._templates.splice(e.position, 1);
                    }
                }, this),
                'changed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && e.property.name == 'position') {
                        this.draw();
                    }
                }, this),
                'initialized.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && !this._initialized) {
                        this._core.trigger('initialize', null, 'navigation');
                        this.initialize();
                        this.update();
                        this.draw();
                        this._initialized = true;
                        this._core.trigger('initialized', null, 'navigation');
                    }
                }, this),
                'refreshed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._initialized) {
                        this._core.trigger('refresh', null, 'navigation');
                        this.update();
                        this.draw();
                        this._core.trigger('refreshed', null, 'navigation');
                    }
                }, this)
            };
            this._core.options = $.extend({}, Navigation.Defaults, this._core.options);
            this.$element.on(this._handlers);
        };
        Navigation.Defaults = {
            nav: false,
            navText: ['<span aria-label="' + 'Previous' + '">&#x2039;</span>', '<span aria-label="' + 'Next' + '">&#x203a;</span>'],
            navSpeed: false,
            navElement: 'button type="button" role="presentation"',
            navContainer: false,
            navContainerClass: 'owl-nav',
            navClass: ['owl-prev', 'owl-next'],
            slideBy: 1,
            dotClass: 'owl-dot',
            dotsClass: 'owl-dots',
            dots: true,
            dotsEach: false,
            dotsData: false,
            dotsSpeed: false,
            dotsContainer: false
        };
        Navigation.prototype.initialize = function() {
            var override, settings = this._core.settings;
            this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');
            this._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function(e) {
                this.prev(settings.navSpeed);
            }, this));
            this._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function(e) {
                this.next(settings.navSpeed);
            }, this));
            if (!settings.dotsData) {
                this._templates = [$('<button role="button">').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];
            }
            this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');
            this._controls.$absolute.on('click', 'button', $.proxy(function(e) {
                var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();
                e.preventDefault();
                this.to(index, settings.dotsSpeed);
            }, this));
            for (override in this._overrides) {
                this._core[override] = $.proxy(this[override], this);
            }
        };
        Navigation.prototype.destroy = function() {
            var handler, control, property, override, settings;
            settings = this._core.settings;
            for (handler in this._handlers) {
                this.$element.off(handler, this._handlers[handler]);
            }
            for (control in this._controls) {
                if (control === '$relative' && settings.navContainer) {
                    this._controls[control].html('');
                } else {
                    this._controls[control].remove();
                }
            }
            for (override in this.overides) {
                this._core[override] = this._overrides[override];
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        Navigation.prototype.update = function() {
            var i, j, k, lower = this._core.clones().length / 2,
                upper = lower + this._core.items().length,
                maximum = this._core.maximum(true),
                settings = this._core.settings,
                size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;
            if (settings.slideBy !== 'page') {
                settings.slideBy = Math.min(settings.slideBy, settings.items);
            }
            if (settings.dots || settings.slideBy == 'page') {
                this._pages = [];
                for (i = lower, j = 0, k = 0; i < upper; i++) {
                    if (j >= size || j === 0) {
                        this._pages.push({
                            start: Math.min(maximum, i - lower),
                            end: i - lower + size - 1
                        });
                        if (Math.min(maximum, i - lower) === maximum) {
                            break;
                        }
                        j = 0, ++k;
                    }
                    j += this._core.mergers(this._core.relative(i));
                }
            }
        };
        Navigation.prototype.draw = function() {
            var difference, settings = this._core.settings,
                disabled = this._core.items().length <= settings.items,
                index = this._core.relative(this._core.current()),
                loop = settings.loop || settings.rewind;
            this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);
            if (settings.nav) {
                this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
                this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
            }
            this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);
            if (settings.dots) {
                difference = this._pages.length - this._controls.$absolute.children().length;
                if (settings.dotsData && difference !== 0) {
                    this._controls.$absolute.html(this._templates.join(''));
                } else if (difference > 0) {
                    this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
                } else if (difference < 0) {
                    this._controls.$absolute.children().slice(difference).remove();
                }
                this._controls.$absolute.find('.active').removeClass('active');
                this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
            }
        };
        Navigation.prototype.onTrigger = function(event) {
            var settings = this._core.settings;
            event.page = {
                index: $.inArray(this.current(), this._pages),
                count: this._pages.length,
                size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
            };
        };
        Navigation.prototype.current = function() {
            var current = this._core.relative(this._core.current());
            return $.grep(this._pages, $.proxy(function(page, index) {
                return page.start <= current && page.end >= current;
            }, this)).pop();
        };
        Navigation.prototype.getPosition = function(successor) {
            var position, length, settings = this._core.settings;
            if (settings.slideBy == 'page') {
                position = $.inArray(this.current(), this._pages);
                length = this._pages.length;
                successor ? ++position : --position;
                position = this._pages[((position % length) + length) % length].start;
            } else {
                position = this._core.relative(this._core.current());
                length = this._core.items().length;
                successor ? position += settings.slideBy : position -= settings.slideBy;
            }
            return position;
        };
        Navigation.prototype.next = function(speed) {
            $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
        };
        Navigation.prototype.prev = function(speed) {
            $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
        };
        Navigation.prototype.to = function(position, speed, standard) {
            var length;
            if (!standard && this._pages.length) {
                length = this._pages.length;
                $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
            } else {
                $.proxy(this._overrides.to, this._core)(position, speed);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.Navigation = Navigation;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        'use strict';
        var Hash = function(carousel1) {
            this._core = carousel1;
            this._hashes = {};
            this.$element = this._core.$element;
            this._handlers = {
                'initialized.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && this._core.settings.startPosition === 'URLHash') {
                        $(window).trigger('hashchange.owl.navigation');
                    }
                }, this),
                'prepared.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace) {
                        var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');
                        if (!hash) {
                            return;
                        }
                        this._hashes[hash] = e.content;
                    }
                }, this),
                'changed.owl.carousel1': $.proxy(function(e) {
                    if (e.namespace && e.property.name === 'position') {
                        var current = this._core.items(this._core.relative(this._core.current())),
                            hash = $.map(this._hashes, function(item, hash) {
                                return item === current ? hash : null;
                            }).join();
                        if (!hash || window.location.hash.slice(1) === hash) {
                            return;
                        }
                        window.location.hash = hash;
                    }
                }, this)
            };
            this._core.options = $.extend({}, Hash.Defaults, this._core.options);
            this.$element.on(this._handlers);
            $(window).on('hashchange.owl.navigation', $.proxy(function(e) {
                var hash = window.location.hash.substring(1),
                    items = this._core.$stage.children(),
                    position = this._hashes[hash] && items.index(this._hashes[hash]);
                if (position === undefined || position === this._core.current()) {
                    return;
                }
                this._core.to(this._core.relative(position), false, true);
            }, this));
        };
        Hash.Defaults = {
            URLhashListener: false
        };
        Hash.prototype.destroy = function() {
            var handler, property;
            $(window).off('hashchange.owl.navigation');
            for (handler in this._handlers) {
                this._core.$element.off(handler, this._handlers[handler]);
            }
            for (property in Object.getOwnPropertyNames(this)) {
                typeof this[property] != 'function' && (this[property] = null);
            }
        };
        $.fn.owlcarousel1.Constructor.Plugins.Hash = Hash;
    })(window.Zepto || window.jQuery, window, document);;
    (function($, window, document, undefined) {
        var style = $('<support>').get(0).style,
            prefixes = 'Webkit Moz O ms'.split(' '),
            events = {
                transition: {
                    end: {
                        WebkitTransition: 'webkitTransitionEnd',
                        MozTransition: 'transitionend',
                        OTransition: 'oTransitionEnd',
                        transition: 'transitionend'
                    }
                },
                animation: {
                    end: {
                        WebkitAnimation: 'webkitAnimationEnd',
                        MozAnimation: 'animationend',
                        OAnimation: 'oAnimationEnd',
                        animation: 'animationend'
                    }
                }
            },
            tests = {
                csstransforms: function() {
                    return !!test('transform');
                },
                csstransforms3d: function() {
                    return !!test('perspective');
                },
                csstransitions: function() {
                    return !!test('transition');
                },
                cssanimations: function() {
                    return !!test('animation');
                }
            };

        function test(property, prefixed) {
            var result = false,
                upper = property.charAt(0).toUpperCase() + property.slice(1);
            $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
                if (style[property] !== undefined) {
                    result = prefixed ? property : true;
                    return false;
                }
            });
            return result;
        }

        function prefixed(property) {
            return test(property, true);
        }
        if (tests.csstransitions()) {
            $.support.transition = new String(prefixed('transition'))
            $.support.transition.end = events.transition.end[$.support.transition];
        }
        if (tests.cssanimations()) {
            $.support.animation = new String(prefixed('animation'))
            $.support.animation.end = events.animation.end[$.support.animation];
        }
        if (tests.csstransforms()) {
            $.support.transform = new String(prefixed('transform'));
            $.support.transform3d = tests.csstransforms3d();
        }
    })(window.Zepto || window.jQuery, window, document);
}), (function(module, exports) {
    'use strict';
    var s_account = window.dwReportSuiteID || undefined;

    function keyValueArray(str) {
        var x;
        var k;
        var v;
        var output = {};
        if (str.length > 0) {
            var kvp = str.split('&');
            for (var i = kvp.length - 1; i >= 0; i--) {
                if (kvp[i].length) {
                    x = kvp[i].split('=');
                    k = x[0];
                    v = '';
                    if (x.length > 1) {
                        v = x[1];
                    }
                    output[k] = v;
                }
            }
        }
        return output;
    }

    function getParamsFromURL(url) {
        var output = {};
        if (url.length > 0) {
            var arr = url.split('?');
            var search = '';
            var searchHash = '';
            var postHash = false;
            if (arr.length > 1) {
                var arrHash = arr[1].split('#');
                search = arrHash[0];
                if (arrHash.length > 1) {
                    postHash = true;
                    searchHash = arrHash[1];
                }
            }
            if (search.length) {
                output = keyValueArray(search);
            }
            if (postHash) {
                if (searchHash.length) {
                    var output2 = keyValueArray(searchHash);
                    for (var prop in output2) {
                        output[prop] = output2[prop];
                    }
                }
            }
        }
        return output;
    }

    function categoryFilters(url) {
        var obj = getParamsFromURL(url);
        if (obj.pmin !== undefined && obj.pmax !== undefined) {
            $(document).trigger('omniture.trackCategoryPrice', ['pmin=' + obj.pmin + '&' + 'pmax=' + obj.pmax]);
        }
        for (var prop in obj) {
            if (prop.indexOf('prefn') === 0) {
                var val = obj[prop];
                var index = prop.replace('prefn', '');
                var refineValue = obj['prefv' + index];
                if (refineValue !== undefined) {
                    refineValue = String(refineValue).replace(new RegExp('%7c', 'ig'), '|');
                    if (val === 'refinementColor') {
                        $(document).trigger('omniture.trackCategoryColor', [refineValue]);
                    } else if (val === 'size') {
                        $(document).trigger('omniture.trackCategorySize', [refineValue]);
                    } else if (val === 'refinementCollection') {
                        $(document).trigger('omniture.refinementCollection', [refineValue]);
                    }
                }
            } else if (prop === 'srule') {
                $(document).trigger('omniture.trackCategorySortBy', [obj.srule]);
            }
        }
    }

    function trackCategoryColor(colorID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop9,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop9 = colorID;
            a.eVar9 = 'Color';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategoryPrice(priceID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop10,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop10 = priceID;
            a.eVar9 = 'Price';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategorySize(sizeID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop12,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop12 = sizeID;
            a.eVar9 = 'Size';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategoryCollection(collectionID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop11,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop11 = collectionID;
            a.eVar9 = 'Collection';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategoryGender(genderID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop13,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop13 = genderID;
            a.eVar9 = 'Gender';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategoryStyle(styleID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop18,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop18 = styleID;
            a.eVar9 = 'Style';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackCategorySortBy(sortByID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            a.linkTrackVars = 'prop19,eVar9,events';
            a.linkTrackEvents = 'event3';
            a.events = 'event3';
            a.prop19 = sortByID;
            a.eVar9 = 'Sort By';
            a.tl(true, 'o', 'Category Refinement');
        }
    }

    function trackPDPColor(productID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            var pid = productID !== null ? ';' + String(productID).replace(new RegExp('_', 'g'), '-') : ';n/a';
            a.linkTrackVars = 'products,events';
            a.events = 'prodView,event1';
            a.products = pid;
            a.tl(true, 'o', 'Product Refinement');
        }
    }

    function trackAddNewCart(price, quantity, productID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            var productString = ';' + String(productID).replace(new RegExp('_', 'g'), '-') + ';' + quantity + ';' + price;
            a.linkTrackVars = 'eVar8,products,events';
            a.linkTrackEvents = 'scOpen,scAdd';
            a.events = 'scOpen,scAdd';
            a.products = productString;
            a.eVar8 = String(productID).replace(new RegExp('_', 'g'), '-');
            a.tl(true, 'o', 'Add to Cart');
        }
    }

    function trackAddExistingCart(price, quantity, productID) {
        if (s_account !== undefined && s_account.length > 0 && typeof s_gi == 'function') {
            var a = s_gi(s_account);
            var productString = ';' + String(productID).replace(new RegExp('_', 'g'), '-') + ';' + quantity + ';' + price;
            a.linkTrackVars = 'eVar8,products,events';
            a.linkTrackEvents = 'scAdd';
            a.events = 'scAdd';
            a.products = productString;
            a.tl(true, 'o', 'Add to Cart');
        }
    }

    function initialize() {
        $(document).on('omniture.categoryFilters', function(event, url) {
            categoryFilters(url);
        });
        $(document).on('omniture.trackPDPColor', function(event, productID) {
            trackPDPColor(productID);
        });
        $(document).on('omniture.trackCategorySortBy', function(event, sortByID) {
            trackCategorySortBy(sortByID);
        });
        $(document).on('omniture.trackCategoryPrice', function(event, priceID) {
            trackCategoryPrice(priceID);
        });
        $(document).on('omniture.trackCategoryColor', function(event, colorID) {
            trackCategoryColor(colorID);
        });
        $(document).on('omniture.trackCategorySize', function(event, sizeID) {
            trackCategorySize(sizeID);
        });
        $(document).on('omniture.trackCategoryCollection', function(event, collectionID) {
            trackCategoryCollection(collectionID);
        });
        $(document).on('omniture.trackCategoryStyle', function(event, styleID) {
            trackCategoryStyle(styleID);
        });
        $(document).on('omniture.trackCategoryGender', function(event, genderID) {
            trackCategoryGender(genderID);
        });
        $(document).on('omniture.trackAddNewCart', function(event, price, quantity, productID) {
            trackAddNewCart(price, quantity, productID);
        });
        $(document).on('omniture.trackAddExistingCart', function(event, price, quantity, productID) {
            trackAddExistingCart(price, quantity, productID);
        });
    }
    initialize();
    module.exports = {
        initialize: initialize
    };
}), , , , , , , , , , , , , , , , , , , , , , , , , , (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /*!tether 1.4.6*/
    (function(root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof exports === "object") {
            module.exports = factory();
        } else {
            root.Tether = factory();
        }
    })(this, function() {
        "use strict";
        var _createClass = (function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        })();

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        var TetherBase = undefined;
        if (typeof TetherBase === "undefined") {
            TetherBase = {
                modules: []
            };
        }
        var zeroElement = null;

        function getActualBoundingClientRect(node) {
            var boundingRect = node.getBoundingClientRect();
            var rect = {};
            for (var k in boundingRect) {
                rect[k] = boundingRect[k];
            }
            if (node.ownerDocument !== document) {
                var _frameElement = node.ownerDocument.defaultView.frameElement;
                if (_frameElement) {
                    var frameRect = getActualBoundingClientRect(_frameElement);
                    rect.top += frameRect.top;
                    rect.bottom += frameRect.top;
                    rect.left += frameRect.left;
                    rect.right += frameRect.left;
                }
            }
            return rect;
        }

        function getScrollParents(el) {
            var computedStyle = getComputedStyle(el) || {};
            var position = computedStyle.position;
            var parents = [];
            if (position === "fixed") {
                return [el];
            }
            var parent = el;
            while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {
                var style = undefined;
                try {
                    style = getComputedStyle(parent);
                } catch (err) {}
                if (typeof style === "undefined" || style === null) {
                    parents.push(parent);
                    return parents;
                }
                var _style = style;
                var overflow = _style.overflow;
                var overflowX = _style.overflowX;
                var overflowY = _style.overflowY;
                if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
                    if (position !== "absolute" || ["relative", "absolute", "fixed"].indexOf(style.position) >= 0) {
                        parents.push(parent);
                    }
                }
            }
            parents.push(el.ownerDocument.body);
            if (el.ownerDocument !== document) {
                parents.push(el.ownerDocument.defaultView);
            }
            return parents;
        }
        var uniqueId = (function() {
            var id = 0;
            return function() {
                return ++id;
            };
        })();
        var zeroPosCache = {};
        var getOrigin = function getOrigin() {
            var node = zeroElement;
            if (!node || !document.body.contains(node)) {
                node = document.createElement("div");
                node.setAttribute("data-tether-id", uniqueId());
                extend(node.style, {
                    top: 0,
                    left: 0,
                    position: "absolute"
                });
                document.body.appendChild(node);
                zeroElement = node;
            }
            var id = node.getAttribute("data-tether-id");
            if (typeof zeroPosCache[id] === "undefined") {
                zeroPosCache[id] = getActualBoundingClientRect(node);
                defer(function() {
                    delete zeroPosCache[id];
                });
            }
            return zeroPosCache[id];
        };

        function removeUtilElements() {
            if (zeroElement) {
                document.body.removeChild(zeroElement);
            }
            zeroElement = null;
        }

        function getBounds(el) {
            var doc = undefined;
            if (el === document) {
                doc = document;
                el = document.documentElement;
            } else {
                doc = el.ownerDocument;
            }
            var docEl = doc.documentElement;
            var box = getActualBoundingClientRect(el);
            var origin = getOrigin();
            box.top -= origin.top;
            box.left -= origin.left;
            if (typeof box.width === "undefined") {
                box.width = document.body.scrollWidth - box.left - box.right;
            }
            if (typeof box.height === "undefined") {
                box.height = document.body.scrollHeight - box.top - box.bottom;
            }
            box.top = box.top - docEl.clientTop;
            box.left = box.left - docEl.clientLeft;
            box.right = doc.body.clientWidth - box.width - box.left;
            box.bottom = doc.body.clientHeight - box.height - box.top;
            return box;
        }

        function getOffsetParent(el) {
            return el.offsetParent || document.documentElement;
        }
        var _scrollBarSize = null;

        function getScrollBarSize() {
            if (_scrollBarSize) {
                return _scrollBarSize;
            }
            var inner = document.createElement("div");
            inner.style.width = "100%";
            inner.style.height = "200px";
            var outer = document.createElement("div");
            extend(outer.style, {
                position: "absolute",
                top: 0,
                left: 0,
                pointerEvents: "none",
                visibility: "hidden",
                width: "200px",
                height: "150px",
                overflow: "hidden"
            });
            outer.appendChild(inner);
            document.body.appendChild(outer);
            var widthContained = inner.offsetWidth;
            outer.style.overflow = "scroll";
            var widthScroll = inner.offsetWidth;
            if (widthContained === widthScroll) {
                widthScroll = outer.clientWidth;
            }
            document.body.removeChild(outer);
            var width = widthContained - widthScroll;
            _scrollBarSize = {
                width: width,
                height: width
            };
            return _scrollBarSize;
        }

        function extend() {
            var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            var args = [];
            Array.prototype.push.apply(args, arguments);
            args.slice(1).forEach(function(obj) {
                if (obj) {
                    for (var key in obj) {
                        if ({}.hasOwnProperty.call(obj, key)) {
                            out[key] = obj[key];
                        }
                    }
                }
            });
            return out;
        }

        function removeClass(el, name) {
            if (typeof el.classList !== "undefined") {
                name.split(" ").forEach(function(cls) {
                    if (cls.trim()) {
                        el.classList.remove(cls);
                    }
                });
            } else {
                var regex = new RegExp("(^| )" + name.split(" ").join("|") + "( |$)", "gi");
                var className = getClassName(el).replace(regex, " ");
                setClassName(el, className);
            }
        }

        function addClass(el, name) {
            if (typeof el.classList !== "undefined") {
                name.split(" ").forEach(function(cls) {
                    if (cls.trim()) {
                        el.classList.add(cls);
                    }
                });
            } else {
                removeClass(el, name);
                var cls = getClassName(el) + (" " + name);
                setClassName(el, cls);
            }
        }

        function hasClass(el, name) {
            if (typeof el.classList !== "undefined") {
                return el.classList.contains(name);
            }
            var className = getClassName(el);
            return new RegExp("(^| )" + name + "( |$)", "gi").test(className);
        }

        function getClassName(el) {
            if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {
                return el.className.baseVal;
            }
            return el.className;
        }

        function setClassName(el, className) {
            el.setAttribute("class", className);
        }

        function updateClasses(el, add, all) {
            all.forEach(function(cls) {
                if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
                    removeClass(el, cls);
                }
            });
            add.forEach(function(cls) {
                if (!hasClass(el, cls)) {
                    addClass(el, cls);
                }
            });
        }
        var deferred = [];
        var defer = function defer(fn) {
            deferred.push(fn);
        };
        var flush = function flush() {
            var fn = undefined;
            while ((fn = deferred.pop())) {
                fn();
            }
        };
        var Evented = (function() {
            function Evented() {
                _classCallCheck(this, Evented);
            }
            _createClass(Evented, [{
                key: "on",
                value: function on(event, handler, ctx) {
                    var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
                    if (typeof this.bindings === "undefined") {
                        this.bindings = {};
                    }
                    if (typeof this.bindings[event] === "undefined") {
                        this.bindings[event] = [];
                    }
                    this.bindings[event].push({
                        handler: handler,
                        ctx: ctx,
                        once: once
                    });
                }
            }, {
                key: "once",
                value: function once(event, handler, ctx) {
                    this.on(event, handler, ctx, true);
                }
            }, {
                key: "off",
                value: function off(event, handler) {
                    if (typeof this.bindings === "undefined" || typeof this.bindings[event] === "undefined") {
                        return;
                    }
                    if (typeof handler === "undefined") {
                        delete this.bindings[event];
                    } else {
                        var i = 0;
                        while (i < this.bindings[event].length) {
                            if (this.bindings[event][i].handler === handler) {
                                this.bindings[event].splice(i, 1);
                            } else {
                                ++i;
                            }
                        }
                    }
                }
            }, {
                key: "trigger",
                value: function trigger(event) {
                    if (typeof this.bindings !== "undefined" && this.bindings[event]) {
                        var i = 0;
                        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            args[_key - 1] = arguments[_key];
                        }
                        while (i < this.bindings[event].length) {
                            var _bindings$event$i = this.bindings[event][i];
                            var handler = _bindings$event$i.handler;
                            var ctx = _bindings$event$i.ctx;
                            var once = _bindings$event$i.once;
                            var context = ctx;
                            if (typeof context === "undefined") {
                                context = this;
                            }
                            handler.apply(context, args);
                            if (once) {
                                this.bindings[event].splice(i, 1);
                            } else {
                                ++i;
                            }
                        }
                    }
                }
            }]);
            return Evented;
        })();
        TetherBase.Utils = {
            getActualBoundingClientRect: getActualBoundingClientRect,
            getScrollParents: getScrollParents,
            getBounds: getBounds,
            getOffsetParent: getOffsetParent,
            extend: extend,
            addClass: addClass,
            removeClass: removeClass,
            hasClass: hasClass,
            updateClasses: updateClasses,
            defer: defer,
            flush: flush,
            uniqueId: uniqueId,
            Evented: Evented,
            getScrollBarSize: getScrollBarSize,
            removeUtilElements: removeUtilElements
        };
        ("use strict");
        var _slicedToArray = (function() {
            function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                    }
                } catch (err) {
                    _d = true;
                    _e = err;
                } finally {
                    try {
                        if (!_n && _i["return"]) _i["return"]();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) {
                    return arr;
                } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            };
        })();
        var _createClass = (function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        })();
        var _get = function get(_x6, _x7, _x8) {
            var _again = true;
            _function: while (_again) {
                var object = _x6,
                    property = _x7,
                    receiver = _x8;
                _again = false;
                if (object === null) object = Function.prototype;
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    } else {
                        _x6 = parent;
                        _x7 = property;
                        _x8 = receiver;
                        _again = true;
                        desc = parent = undefined;
                        continue _function;
                    }
                } else if ("value" in desc) {
                    return desc.value;
                } else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                }
            }
        };

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " +
                    typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
        }
        if (typeof TetherBase === "undefined") {
            throw new Error("You must include the utils.js file before tether.js");
        }
        var _TetherBase$Utils = TetherBase.Utils;
        var getScrollParents = _TetherBase$Utils.getScrollParents;
        var getBounds = _TetherBase$Utils.getBounds;
        var getOffsetParent = _TetherBase$Utils.getOffsetParent;
        var extend = _TetherBase$Utils.extend;
        var addClass = _TetherBase$Utils.addClass;
        var removeClass = _TetherBase$Utils.removeClass;
        var updateClasses = _TetherBase$Utils.updateClasses;
        var defer = _TetherBase$Utils.defer;
        var flush = _TetherBase$Utils.flush;
        var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
        var removeUtilElements = _TetherBase$Utils.removeUtilElements;

        function within(a, b) {
            var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
            return a + diff >= b && b >= a - diff;
        }
        var transformKey = (function() {
            if (typeof document === "undefined") {
                return "";
            }
            var el = document.createElement("div");
            var transforms = ["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"];
            for (var i = 0; i < transforms.length; ++i) {
                var key = transforms[i];
                if (el.style[key] !== undefined) {
                    return key;
                }
            }
        })();
        var tethers = [];
        var position = function position() {
            tethers.forEach(function(tether) {
                tether.position(false);
            });
            flush();
        };

        function now() {
            if (typeof performance === "object" && typeof performance.now === "function") {
                return performance.now();
            }
            return +new Date();
        }
        (function() {
            var lastCall = null;
            var lastDuration = null;
            var pendingTimeout = null;
            var tick = function tick() {
                if (typeof lastDuration !== "undefined" && lastDuration > 16) {
                    lastDuration = Math.min(lastDuration - 16, 250);
                    pendingTimeout = setTimeout(tick, 250);
                    return;
                }
                if (typeof lastCall !== "undefined" && now() - lastCall < 10) {
                    return;
                }
                if (pendingTimeout != null) {
                    clearTimeout(pendingTimeout);
                    pendingTimeout = null;
                }
                lastCall = now();
                position();
                lastDuration = now() - lastCall;
            };
            if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
                ["resize", "scroll", "touchmove"].forEach(function(event) {
                    window.addEventListener(event, tick);
                });
            }
        })();
        var MIRROR_LR = {
            center: "center",
            left: "right",
            right: "left"
        };
        var MIRROR_TB = {
            middle: "middle",
            top: "bottom",
            bottom: "top"
        };
        var OFFSET_MAP = {
            top: 0,
            left: 0,
            middle: "50%",
            center: "50%",
            bottom: "100%",
            right: "100%"
        };
        var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
            var left = attachment.left;
            var top = attachment.top;
            if (left === "auto") {
                left = MIRROR_LR[relativeToAttachment.left];
            }
            if (top === "auto") {
                top = MIRROR_TB[relativeToAttachment.top];
            }
            return {
                left: left,
                top: top
            };
        };
        var attachmentToOffset = function attachmentToOffset(attachment) {
            var left = attachment.left;
            var top = attachment.top;
            if (typeof OFFSET_MAP[attachment.left] !== "undefined") {
                left = OFFSET_MAP[attachment.left];
            }
            if (typeof OFFSET_MAP[attachment.top] !== "undefined") {
                top = OFFSET_MAP[attachment.top];
            }
            return {
                left: left,
                top: top
            };
        };

        function addOffset() {
            var out = {
                top: 0,
                left: 0
            };
            for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
                offsets[_key] = arguments[_key];
            }
            offsets.forEach(function(_ref) {
                var top = _ref.top;
                var left = _ref.left;
                if (typeof top === "string") {
                    top = parseFloat(top, 10);
                }
                if (typeof left === "string") {
                    left = parseFloat(left, 10);
                }
                out.top += top;
                out.left += left;
            });
            return out;
        }

        function offsetToPx(offset, size) {
            if (typeof offset.left === "string" && offset.left.indexOf("%") !== -1) {
                offset.left = (parseFloat(offset.left, 10) / 100) * size.width;
            }
            if (typeof offset.top === "string" && offset.top.indexOf("%") !== -1) {
                offset.top = (parseFloat(offset.top, 10) / 100) * size.height;
            }
            return offset;
        }
        var parseOffset = function parseOffset(value) {
            var _value$split = value.split(" ");
            var _value$split2 = _slicedToArray(_value$split, 2);
            var top = _value$split2[0];
            var left = _value$split2[1];
            return {
                top: top,
                left: left
            };
        };
        var parseAttachment = parseOffset;
        var TetherClass = (function(_Evented) {
            _inherits(TetherClass, _Evented);

            function TetherClass(options) {
                var _this = this;
                _classCallCheck(this, TetherClass);
                _get(Object.getPrototypeOf(TetherClass.prototype), "constructor", this).call(this);
                this.position = this.position.bind(this);
                tethers.push(this);
                this.history = [];
                this.setOptions(options, false);
                TetherBase.modules.forEach(function(module) {
                    if (typeof module.initialize !== "undefined") {
                        module.initialize.call(_this);
                    }
                });
                this.position();
            }
            _createClass(TetherClass, [{
                key: "getClass",
                value: function getClass() {
                    var key = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                    var classes = this.options.classes;
                    if (typeof classes !== "undefined" && classes[key]) {
                        return this.options.classes[key];
                    } else if (this.options.classPrefix) {
                        return this.options.classPrefix + "-" + key;
                    } else {
                        return key;
                    }
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    var _this2 = this;
                    var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
                    var defaults = {
                        offset: "0 0",
                        targetOffset: "0 0",
                        targetAttachment: "auto auto",
                        classPrefix: "tether"
                    };
                    this.options = extend(defaults, options);
                    var _options = this.options;
                    var element = _options.element;
                    var target = _options.target;
                    var targetModifier = _options.targetModifier;
                    this.element = element;
                    this.target = target;
                    this.targetModifier = targetModifier;
                    if (this.target === "viewport") {
                        this.target = document.body;
                        this.targetModifier = "visible";
                    } else if (this.target === "scroll-handle") {
                        this.target = document.body;
                        this.targetModifier = "scroll-handle";
                    }
                    ["element", "target"].forEach(function(key) {
                        if (typeof _this2[key] === "undefined") {
                            throw new Error("Tether Error: Both element and target must be defined");
                        }
                        if (typeof _this2[key].jquery !== "undefined") {
                            _this2[key] = _this2[key][0];
                        } else if (typeof _this2[key] === "string") {
                            _this2[key] = document.querySelector(_this2[key]);
                        }
                    });
                    addClass(this.element, this.getClass("element"));
                    if (!(this.options.addTargetClasses === false)) {
                        addClass(this.target, this.getClass("target"));
                    }
                    if (!this.options.attachment) {
                        throw new Error("Tether Error: You must provide an attachment");
                    }
                    this.targetAttachment = parseAttachment(this.options.targetAttachment);
                    this.attachment = parseAttachment(this.options.attachment);
                    this.offset = parseOffset(this.options.offset);
                    this.targetOffset = parseOffset(this.options.targetOffset);
                    if (typeof this.scrollParents !== "undefined") {
                        this.disable();
                    }
                    if (this.targetModifier === "scroll-handle") {
                        this.scrollParents = [this.target];
                    } else {
                        this.scrollParents = getScrollParents(this.target);
                    }
                    if (!(this.options.enabled === false)) {
                        this.enable(pos);
                    }
                }
            }, {
                key: "getTargetBounds",
                value: function getTargetBounds() {
                    if (typeof this.targetModifier !== "undefined") {
                        if (this.targetModifier === "visible") {
                            if (this.target === document.body) {
                                return {
                                    top: pageYOffset,
                                    left: pageXOffset,
                                    height: innerHeight,
                                    width: innerWidth
                                };
                            } else {
                                var bounds = getBounds(this.target);
                                var out = {
                                    height: bounds.height,
                                    width: bounds.width,
                                    top: bounds.top,
                                    left: bounds.left
                                };
                                out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
                                out.height = Math.min(out.height, bounds.height -
                                    (bounds.top + bounds.height - (pageYOffset + innerHeight)));
                                out.height = Math.min(innerHeight, out.height);
                                out.height -= 2;
                                out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
                                out.width = Math.min(out.width, bounds.width -
                                    (bounds.left + bounds.width - (pageXOffset + innerWidth)));
                                out.width = Math.min(innerWidth, out.width);
                                out.width -= 2;
                                if (out.top < pageYOffset) {
                                    out.top = pageYOffset;
                                }
                                if (out.left < pageXOffset) {
                                    out.left = pageXOffset;
                                }
                                return out;
                            }
                        } else if (this.targetModifier === "scroll-handle") {
                            var bounds = undefined;
                            var target = this.target;
                            if (target === document.body) {
                                target = document.documentElement;
                                bounds = {
                                    left: pageXOffset,
                                    top: pageYOffset,
                                    height: innerHeight,
                                    width: innerWidth
                                };
                            } else {
                                bounds = getBounds(target);
                            }
                            var style = getComputedStyle(target);
                            var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf("scroll") >= 0 || this.target !== document.body;
                            var scrollBottom = 0;
                            if (hasBottomScroll) {
                                scrollBottom = 15;
                            }
                            var height = bounds.height -
                                parseFloat(style.borderTopWidth) -
                                parseFloat(style.borderBottomWidth) -
                                scrollBottom;
                            var out = {
                                width: 15,
                                height: height * 0.975 * (height / target.scrollHeight),
                                left: bounds.left +
                                    bounds.width -
                                    parseFloat(style.borderLeftWidth) -
                                    15
                            };
                            var fitAdj = 0;
                            if (height < 408 && this.target === document.body) {
                                fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
                            }
                            if (this.target !== document.body) {
                                out.height = Math.max(out.height, 24);
                            }
                            var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
                            out.top = scrollPercentage * (height - out.height - fitAdj) +
                                bounds.top +
                                parseFloat(style.borderTopWidth);
                            if (this.target === document.body) {
                                out.height = Math.max(out.height, 24);
                            }
                            return out;
                        }
                    } else {
                        return getBounds(this.target);
                    }
                }
            }, {
                key: "clearCache",
                value: function clearCache() {
                    this._cache = {};
                }
            }, {
                key: "cache",
                value: function cache(k, getter) {
                    if (typeof this._cache === "undefined") {
                        this._cache = {};
                    }
                    if (typeof this._cache[k] === "undefined") {
                        this._cache[k] = getter.call(this);
                    }
                    return this._cache[k];
                }
            }, {
                key: "enable",
                value: function enable() {
                    var _this3 = this;
                    var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
                    if (!(this.options.addTargetClasses === false)) {
                        addClass(this.target, this.getClass("enabled"));
                    }
                    addClass(this.element, this.getClass("enabled"));
                    this.enabled = true;
                    this.scrollParents.forEach(function(parent) {
                        if (parent !== _this3.target.ownerDocument) {
                            parent.addEventListener("scroll", _this3.position);
                        }
                    });
                    if (pos) {
                        this.position();
                    }
                }
            }, {
                key: "disable",
                value: function disable() {
                    var _this4 = this;
                    removeClass(this.target, this.getClass("enabled"));
                    removeClass(this.element, this.getClass("enabled"));
                    this.enabled = false;
                    if (typeof this.scrollParents !== "undefined") {
                        this.scrollParents.forEach(function(parent) {
                            parent.removeEventListener("scroll", _this4.position);
                        });
                    }
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    var _this5 = this;
                    this.disable();
                    tethers.forEach(function(tether, i) {
                        if (tether === _this5) {
                            tethers.splice(i, 1);
                        }
                    });
                    if (tethers.length === 0) {
                        removeUtilElements();
                    }
                }
            }, {
                key: "updateAttachClasses",
                value: function updateAttachClasses(elementAttach, targetAttach) {
                    var _this6 = this;
                    elementAttach = elementAttach || this.attachment;
                    targetAttach = targetAttach || this.targetAttachment;
                    var sides = ["left", "top", "bottom", "right", "middle", "center"];
                    if (typeof this._addAttachClasses !== "undefined" && this._addAttachClasses.length) {
                        this._addAttachClasses.splice(0, this._addAttachClasses.length);
                    }
                    if (typeof this._addAttachClasses === "undefined") {
                        this._addAttachClasses = [];
                    }
                    var add = this._addAttachClasses;
                    if (elementAttach.top) {
                        add.push(this.getClass("element-attached") + "-" + elementAttach.top);
                    }
                    if (elementAttach.left) {
                        add.push(this.getClass("element-attached") + "-" + elementAttach.left);
                    }
                    if (targetAttach.top) {
                        add.push(this.getClass("target-attached") + "-" + targetAttach.top);
                    }
                    if (targetAttach.left) {
                        add.push(this.getClass("target-attached") + "-" + targetAttach.left);
                    }
                    var all = [];
                    sides.forEach(function(side) {
                        all.push(_this6.getClass("element-attached") + "-" + side);
                        all.push(_this6.getClass("target-attached") + "-" + side);
                    });
                    defer(function() {
                        if (!(typeof _this6._addAttachClasses !== "undefined")) {
                            return;
                        }
                        updateClasses(_this6.element, _this6._addAttachClasses, all);
                        if (!(_this6.options.addTargetClasses === false)) {
                            updateClasses(_this6.target, _this6._addAttachClasses, all);
                        }
                        delete _this6._addAttachClasses;
                    });
                }
            }, {
                key: "position",
                value: function position() {
                    var _this7 = this;
                    var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
                    if (!this.enabled) {
                        return;
                    }
                    this.clearCache();
                    var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
                    this.updateAttachClasses(this.attachment, targetAttachment);
                    var elementPos = this.cache("element-bounds", function() {
                        return getBounds(_this7.element);
                    });
                    var width = elementPos.width;
                    var height = elementPos.height;
                    if (width === 0 && height === 0 && typeof this.lastSize !== "undefined") {
                        var _lastSize = this.lastSize;
                        width = _lastSize.width;
                        height = _lastSize.height;
                    } else {
                        this.lastSize = {
                            width: width,
                            height: height
                        };
                    }
                    var targetPos = this.cache("target-bounds", function() {
                        return _this7.getTargetBounds();
                    });
                    var targetSize = targetPos;
                    var offset = offsetToPx(attachmentToOffset(this.attachment), {
                        width: width,
                        height: height
                    });
                    var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
                    var manualOffset = offsetToPx(this.offset, {
                        width: width,
                        height: height
                    });
                    var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
                    offset = addOffset(offset, manualOffset);
                    targetOffset = addOffset(targetOffset, manualTargetOffset);
                    var left = targetPos.left + targetOffset.left - offset.left;
                    var top = targetPos.top + targetOffset.top - offset.top;
                    for (var i = 0; i < TetherBase.modules.length; ++i) {
                        var _module2 = TetherBase.modules[i];
                        var ret = _module2.position.call(this, {
                            left: left,
                            top: top,
                            targetAttachment: targetAttachment,
                            targetPos: targetPos,
                            elementPos: elementPos,
                            offset: offset,
                            targetOffset: targetOffset,
                            manualOffset: manualOffset,
                            manualTargetOffset: manualTargetOffset,
                            scrollbarSize: scrollbarSize,
                            attachment: this.attachment
                        });
                        if (ret === false) {
                            return false;
                        } else if (typeof ret === "undefined" || typeof ret !== "object") {
                            continue;
                        } else {
                            top = ret.top;
                            left = ret.left;
                        }
                    }
                    var next = {
                        page: {
                            top: top,
                            left: left
                        },
                        viewport: {
                            top: top - pageYOffset,
                            bottom: pageYOffset - top - height + innerHeight,
                            left: left - pageXOffset,
                            right: pageXOffset - left - width + innerWidth
                        }
                    };
                    var doc = this.target.ownerDocument;
                    var win = doc.defaultView;
                    var scrollbarSize = undefined;
                    if (win.innerHeight > doc.documentElement.clientHeight) {
                        scrollbarSize = this.cache("scrollbar-size", getScrollBarSize);
                        next.viewport.bottom -= scrollbarSize.height;
                    }
                    if (win.innerWidth > doc.documentElement.clientWidth) {
                        scrollbarSize = this.cache("scrollbar-size", getScrollBarSize);
                        next.viewport.right -= scrollbarSize.width;
                    }
                    if (["", "static"].indexOf(doc.body.style.position) === -1 || ["", "static"].indexOf(doc.body.parentElement.style.position) === -1) {
                        next.page.bottom = doc.body.scrollHeight - top - height;
                        next.page.right = doc.body.scrollWidth - left - width;
                    }
                    if (typeof this.options.optimizations !== "undefined" && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== "undefined")) {
                        (function() {
                            var offsetParent = _this7.cache("target-offsetparent", function() {
                                return getOffsetParent(_this7.target);
                            });
                            var offsetPosition = _this7.cache("target-offsetparent-bounds", function() {
                                return getBounds(offsetParent);
                            });
                            var offsetParentStyle = getComputedStyle(offsetParent);
                            var offsetParentSize = offsetPosition;
                            var offsetBorder = {};
                            ["Top", "Left", "Bottom", "Right"].forEach(function(side) {
                                offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle["border" + side + "Width"]);
                            });
                            offsetPosition.right = doc.body.scrollWidth -
                                offsetPosition.left -
                                offsetParentSize.width +
                                offsetBorder.right;
                            offsetPosition.bottom = doc.body.scrollHeight -
                                offsetPosition.top -
                                offsetParentSize.height +
                                offsetBorder.bottom;
                            if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
                                if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
                                    var scrollTop = offsetParent.scrollTop;
                                    var scrollLeft = offsetParent.scrollLeft;
                                    next.offset = {
                                        top: next.page.top -
                                            offsetPosition.top +
                                            scrollTop -
                                            offsetBorder.top,
                                        left: next.page.left -
                                            offsetPosition.left +
                                            scrollLeft -
                                            offsetBorder.left
                                    };
                                }
                            }
                        })();
                    }
                    this.move(next);
                    this.history.unshift(next);
                    if (this.history.length > 3) {
                        this.history.pop();
                    }
                    if (flushChanges) {
                        flush();
                    }
                    return true;
                }
            }, {
                key: "move",
                value: function move(pos) {
                    var _this8 = this;
                    if (!(typeof this.element.parentNode !== "undefined")) {
                        return;
                    }
                    var same = {};
                    for (var type in pos) {
                        same[type] = {};
                        for (var key in pos[type]) {
                            var found = false;
                            for (var i = 0; i < this.history.length; ++i) {
                                var point = this.history[i];
                                if (typeof point[type] !== "undefined" && !within(point[type][key], pos[type][key])) {
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                same[type][key] = true;
                            }
                        }
                    }
                    var css = {
                        top: "",
                        left: "",
                        right: "",
                        bottom: ""
                    };
                    var transcribe = function transcribe(_same, _pos) {
                        var hasOptimizations = typeof _this8.options.optimizations !== "undefined";
                        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;
                        if (gpu !== false) {
                            var yPos = undefined,
                                xPos = undefined;
                            if (_same.top) {
                                css.top = 0;
                                yPos = _pos.top;
                            } else {
                                css.bottom = 0;
                                yPos = -_pos.bottom;
                            }
                            if (_same.left) {
                                css.left = 0;
                                xPos = _pos.left;
                            } else {
                                css.right = 0;
                                xPos = -_pos.right;
                            }
                            if (typeof window.devicePixelRatio === "number" && devicePixelRatio % 1 === 0) {
                                xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;
                                yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;
                            }
                            css[transformKey] = "translateX(" + xPos + "px) translateY(" + yPos + "px)";
                            if (transformKey !== "msTransform") {
                                css[transformKey] += " translateZ(0)";
                            }
                        } else {
                            if (_same.top) {
                                css.top = _pos.top + "px";
                            } else {
                                css.bottom = _pos.bottom + "px";
                            }
                            if (_same.left) {
                                css.left = _pos.left + "px";
                            } else {
                                css.right = _pos.right + "px";
                            }
                        }
                    };
                    var moved = false;
                    if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
                        css.position = "absolute";
                        transcribe(same.page, pos.page);
                    } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
                        css.position = "fixed";
                        transcribe(same.viewport, pos.viewport);
                    } else if (typeof same.offset !== "undefined" && same.offset.top && same.offset.left) {
                        (function() {
                            css.position = "absolute";
                            var offsetParent = _this8.cache("target-offsetparent", function() {
                                return getOffsetParent(_this8.target);
                            });
                            if (getOffsetParent(_this8.element) !== offsetParent) {
                                defer(function() {
                                    _this8.element.parentNode.removeChild(_this8.element);
                                    offsetParent.appendChild(_this8.element);
                                });
                            }
                            transcribe(same.offset, pos.offset);
                            moved = true;
                        })();
                    } else {
                        css.position = "absolute";
                        transcribe({
                            top: true,
                            left: true
                        }, pos.page);
                    }
                    if (!moved) {
                        if (this.options.bodyElement) {
                            if (this.element.parentNode !== this.options.bodyElement) {
                                this.options.bodyElement.appendChild(this.element);
                            }
                        } else {
                            var isFullscreenElement = function isFullscreenElement(e) {
                                var d = e.ownerDocument;
                                var fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;
                                return fe === e;
                            };
                            var offsetParentIsBody = true;
                            var currentNode = this.element.parentNode;
                            while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== "BODY" && !isFullscreenElement(currentNode)) {
                                if (getComputedStyle(currentNode).position !== "static") {
                                    offsetParentIsBody = false;
                                    break;
                                }
                                currentNode = currentNode.parentNode;
                            }
                            if (!offsetParentIsBody) {
                                this.element.parentNode.removeChild(this.element);
                                this.element.ownerDocument.body.appendChild(this.element);
                            }
                        }
                    }
                    var writeCSS = {};
                    var write = false;
                    for (var key in css) {
                        var val = css[key];
                        var elVal = this.element.style[key];
                        if (elVal !== val) {
                            write = true;
                            writeCSS[key] = val;
                        }
                    }
                    if (write) {
                        defer(function() {
                            extend(_this8.element.style, writeCSS);
                            _this8.trigger("repositioned");
                        });
                    }
                }
            }]);
            return TetherClass;
        })(Evented);
        TetherClass.modules = [];
        TetherBase.position = position;
        var Tether = extend(TetherClass, TetherBase);
        ("use strict");
        var _slicedToArray = (function() {
            function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                    }
                } catch (err) {
                    _d = true;
                    _e = err;
                } finally {
                    try {
                        if (!_n && _i["return"]) _i["return"]();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) {
                    return arr;
                } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            };
        })();
        var _TetherBase$Utils = TetherBase.Utils;
        var getBounds = _TetherBase$Utils.getBounds;
        var extend = _TetherBase$Utils.extend;
        var updateClasses = _TetherBase$Utils.updateClasses;
        var defer = _TetherBase$Utils.defer;
        var BOUNDS_FORMAT = ["left", "top", "right", "bottom"];

        function getBoundingRect(tether, to) {
            if (to === "scrollParent") {
                to = tether.scrollParents[0];
            } else if (to === "window") {
                to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
            }
            if (to === document) {
                to = to.documentElement;
            }
            if (typeof to.nodeType !== "undefined") {
                (function() {
                    var node = to;
                    var size = getBounds(to);
                    var pos = size;
                    var style = getComputedStyle(to);
                    to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];
                    if (node.ownerDocument !== document) {
                        var win = node.ownerDocument.defaultView;
                        to[0] += win.pageXOffset;
                        to[1] += win.pageYOffset;
                        to[2] += win.pageXOffset;
                        to[3] += win.pageYOffset;
                    }
                    BOUNDS_FORMAT.forEach(function(side, i) {
                        side = side[0].toUpperCase() + side.substr(1);
                        if (side === "Top" || side === "Left") {
                            to[i] += parseFloat(style["border" + side + "Width"]);
                        } else {
                            to[i] -= parseFloat(style["border" + side + "Width"]);
                        }
                    });
                })();
            }
            return to;
        }
        TetherBase.modules.push({
            position: function position(_ref) {
                var _this = this;
                var top = _ref.top;
                var left = _ref.left;
                var targetAttachment = _ref.targetAttachment;
                if (!this.options.constraints) {
                    return true;
                }
                var _cache = this.cache("element-bounds", function() {
                    return getBounds(_this.element);
                });
                var height = _cache.height;
                var width = _cache.width;
                if (width === 0 && height === 0 && typeof this.lastSize !== "undefined") {
                    var _lastSize = this.lastSize;
                    width = _lastSize.width;
                    height = _lastSize.height;
                }
                var targetSize = this.cache("target-bounds", function() {
                    return _this.getTargetBounds();
                });
                var targetHeight = targetSize.height;
                var targetWidth = targetSize.width;
                var allClasses = [this.getClass("pinned"), this.getClass("out-of-bounds")];
                this.options.constraints.forEach(function(constraint) {
                    var outOfBoundsClass = constraint.outOfBoundsClass;
                    var pinnedClass = constraint.pinnedClass;
                    if (outOfBoundsClass) {
                        allClasses.push(outOfBoundsClass);
                    }
                    if (pinnedClass) {
                        allClasses.push(pinnedClass);
                    }
                });
                allClasses.forEach(function(cls) {
                    ["left", "top", "right", "bottom"].forEach(function(side) {
                        allClasses.push(cls + "-" + side);
                    });
                });
                var addClasses = [];
                var tAttachment = extend({}, targetAttachment);
                var eAttachment = extend({}, this.attachment);
                this.options.constraints.forEach(function(constraint) {
                    var to = constraint.to;
                    var attachment = constraint.attachment;
                    var pin = constraint.pin;
                    if (typeof attachment === "undefined") {
                        attachment = "";
                    }
                    var changeAttachX = undefined,
                        changeAttachY = undefined;
                    if (attachment.indexOf(" ") >= 0) {
                        var _attachment$split = attachment.split(" ");
                        var _attachment$split2 = _slicedToArray(_attachment$split, 2);
                        changeAttachY = _attachment$split2[0];
                        changeAttachX = _attachment$split2[1];
                    } else {
                        changeAttachX = changeAttachY = attachment;
                    }
                    var bounds = getBoundingRect(_this, to);
                    if (changeAttachY === "target" || changeAttachY === "both") {
                        if (top < bounds[1] && tAttachment.top === "top") {
                            top += targetHeight;
                            tAttachment.top = "bottom";
                        }
                        if (top + height > bounds[3] && tAttachment.top === "bottom") {
                            top -= targetHeight;
                            tAttachment.top = "top";
                        }
                    }
                    if (changeAttachY === "together") {
                        if (tAttachment.top === "top") {
                            if (eAttachment.top === "bottom" && top < bounds[1]) {
                                top += targetHeight;
                                tAttachment.top = "bottom";
                                top += height;
                                eAttachment.top = "top";
                            } else if (eAttachment.top === "top" && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {
                                top -= height - targetHeight;
                                tAttachment.top = "bottom";
                                eAttachment.top = "bottom";
                            }
                        }
                        if (tAttachment.top === "bottom") {
                            if (eAttachment.top === "top" && top + height > bounds[3]) {
                                top -= targetHeight;
                                tAttachment.top = "top";
                                top -= height;
                                eAttachment.top = "bottom";
                            } else if (eAttachment.top === "bottom" && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {
                                top += height - targetHeight;
                                tAttachment.top = "top";
                                eAttachment.top = "top";
                            }
                        }
                        if (tAttachment.top === "middle") {
                            if (top + height > bounds[3] && eAttachment.top === "top") {
                                top -= height;
                                eAttachment.top = "bottom";
                            } else if (top < bounds[1] && eAttachment.top === "bottom") {
                                top += height;
                                eAttachment.top = "top";
                            }
                        }
                    }
                    if (changeAttachX === "target" || changeAttachX === "both") {
                        if (left < bounds[0] && tAttachment.left === "left") {
                            left += targetWidth;
                            tAttachment.left = "right";
                        }
                        if (left + width > bounds[2] && tAttachment.left === "right") {
                            left -= targetWidth;
                            tAttachment.left = "left";
                        }
                    }
                    if (changeAttachX === "together") {
                        if (left < bounds[0] && tAttachment.left === "left") {
                            if (eAttachment.left === "right") {
                                left += targetWidth;
                                tAttachment.left = "right";
                                left += width;
                                eAttachment.left = "left";
                            } else if (eAttachment.left === "left") {
                                left += targetWidth;
                                tAttachment.left = "right";
                                left -= width;
                                eAttachment.left = "right";
                            }
                        } else if (left + width > bounds[2] && tAttachment.left === "right") {
                            if (eAttachment.left === "left") {
                                left -= targetWidth;
                                tAttachment.left = "left";
                                left -= width;
                                eAttachment.left = "right";
                            } else if (eAttachment.left === "right") {
                                left -= targetWidth;
                                tAttachment.left = "left";
                                left += width;
                                eAttachment.left = "left";
                            }
                        } else if (tAttachment.left === "center") {
                            if (left + width > bounds[2] && eAttachment.left === "left") {
                                left -= width;
                                eAttachment.left = "right";
                            } else if (left < bounds[0] && eAttachment.left === "right") {
                                left += width;
                                eAttachment.left = "left";
                            }
                        }
                    }
                    if (changeAttachY === "element" || changeAttachY === "both") {
                        if (top < bounds[1] && eAttachment.top === "bottom") {
                            top += height;
                            eAttachment.top = "top";
                        }
                        if (top + height > bounds[3] && eAttachment.top === "top") {
                            top -= height;
                            eAttachment.top = "bottom";
                        }
                    }
                    if (changeAttachX === "element" || changeAttachX === "both") {
                        if (left < bounds[0]) {
                            if (eAttachment.left === "right") {
                                left += width;
                                eAttachment.left = "left";
                            } else if (eAttachment.left === "center") {
                                left += width / 2;
                                eAttachment.left = "left";
                            }
                        }
                        if (left + width > bounds[2]) {
                            if (eAttachment.left === "left") {
                                left -= width;
                                eAttachment.left = "right";
                            } else if (eAttachment.left === "center") {
                                left -= width / 2;
                                eAttachment.left = "right";
                            }
                        }
                    }
                    if (typeof pin === "string") {
                        pin = pin.split(",").map(function(p) {
                            return p.trim();
                        });
                    } else if (pin === true) {
                        pin = ["top", "left", "right", "bottom"];
                    }
                    pin = pin || [];
                    var pinned = [];
                    var oob = [];
                    if (top < bounds[1]) {
                        if (pin.indexOf("top") >= 0) {
                            top = bounds[1];
                            pinned.push("top");
                        } else {
                            oob.push("top");
                        }
                    }
                    if (top + height > bounds[3]) {
                        if (pin.indexOf("bottom") >= 0) {
                            top = bounds[3] - height;
                            pinned.push("bottom");
                        } else {
                            oob.push("bottom");
                        }
                    }
                    if (left < bounds[0]) {
                        if (pin.indexOf("left") >= 0) {
                            left = bounds[0];
                            pinned.push("left");
                        } else {
                            oob.push("left");
                        }
                    }
                    if (left + width > bounds[2]) {
                        if (pin.indexOf("right") >= 0) {
                            left = bounds[2] - width;
                            pinned.push("right");
                        } else {
                            oob.push("right");
                        }
                    }
                    if (pinned.length) {
                        (function() {
                            var pinnedClass = undefined;
                            if (typeof _this.options.pinnedClass !== "undefined") {
                                pinnedClass = _this.options.pinnedClass;
                            } else {
                                pinnedClass = _this.getClass("pinned");
                            }
                            addClasses.push(pinnedClass);
                            pinned.forEach(function(side) {
                                addClasses.push(pinnedClass + "-" + side);
                            });
                        })();
                    }
                    if (oob.length) {
                        (function() {
                            var oobClass = undefined;
                            if (typeof _this.options.outOfBoundsClass !== "undefined") {
                                oobClass = _this.options.outOfBoundsClass;
                            } else {
                                oobClass = _this.getClass("out-of-bounds");
                            }
                            addClasses.push(oobClass);
                            oob.forEach(function(side) {
                                addClasses.push(oobClass + "-" + side);
                            });
                        })();
                    }
                    if (pinned.indexOf("left") >= 0 || pinned.indexOf("right") >= 0) {
                        eAttachment.left = tAttachment.left = false;
                    }
                    if (pinned.indexOf("top") >= 0 || pinned.indexOf("bottom") >= 0) {
                        eAttachment.top = tAttachment.top = false;
                    }
                    if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
                        _this.updateAttachClasses(eAttachment, tAttachment);
                        _this.trigger("update", {
                            attachment: eAttachment,
                            targetAttachment: tAttachment
                        });
                    }
                });
                defer(function() {
                    if (!(_this.options.addTargetClasses === false)) {
                        updateClasses(_this.target, addClasses, allClasses);
                    }
                    updateClasses(_this.element, addClasses, allClasses);
                });
                return {
                    top: top,
                    left: left
                };
            }
        });
        ("use strict");
        var _TetherBase$Utils = TetherBase.Utils;
        var getBounds = _TetherBase$Utils.getBounds;
        var updateClasses = _TetherBase$Utils.updateClasses;
        var defer = _TetherBase$Utils.defer;
        TetherBase.modules.push({
            position: function position(_ref) {
                var _this = this;
                var top = _ref.top;
                var left = _ref.left;
                var _cache = this.cache("element-bounds", function() {
                    return getBounds(_this.element);
                });
                var height = _cache.height;
                var width = _cache.width;
                var targetPos = this.getTargetBounds();
                var bottom = top + height;
                var right = left + width;
                var abutted = [];
                if (top <= targetPos.bottom && bottom >= targetPos.top) {
                    ["left", "right"].forEach(function(side) {
                        var targetPosSide = targetPos[side];
                        if (targetPosSide === left || targetPosSide === right) {
                            abutted.push(side);
                        }
                    });
                }
                if (left <= targetPos.right && right >= targetPos.left) {
                    ["top", "bottom"].forEach(function(side) {
                        var targetPosSide = targetPos[side];
                        if (targetPosSide === top || targetPosSide === bottom) {
                            abutted.push(side);
                        }
                    });
                }
                var allClasses = [];
                var addClasses = [];
                var sides = ["left", "top", "right", "bottom"];
                allClasses.push(this.getClass("abutted"));
                sides.forEach(function(side) {
                    allClasses.push(_this.getClass("abutted") + "-" + side);
                });
                if (abutted.length) {
                    addClasses.push(this.getClass("abutted"));
                }
                abutted.forEach(function(side) {
                    addClasses.push(_this.getClass("abutted") + "-" + side);
                });
                defer(function() {
                    if (!(_this.options.addTargetClasses === false)) {
                        updateClasses(_this.target, addClasses, allClasses);
                    }
                    updateClasses(_this.element, addClasses, allClasses);
                });
                return true;
            }
        });
        ("use strict");
        var _slicedToArray = (function() {
            function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                    }
                } catch (err) {
                    _d = true;
                    _e = err;
                } finally {
                    try {
                        if (!_n && _i["return"]) _i["return"]();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) {
                    return arr;
                } else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            };
        })();
        TetherBase.modules.push({
            position: function position(_ref) {
                var top = _ref.top;
                var left = _ref.left;
                if (!this.options.shift) {
                    return;
                }
                var shift = this.options.shift;
                if (typeof this.options.shift === "function") {
                    shift = this.options.shift.call(this, {
                        top: top,
                        left: left
                    });
                }
                var shiftTop = undefined,
                    shiftLeft = undefined;
                if (typeof shift === "string") {
                    shift = shift.split(" ");
                    shift[1] = shift[1] || shift[0];
                    var _shift = shift;
                    var _shift2 = _slicedToArray(_shift, 2);
                    shiftTop = _shift2[0];
                    shiftLeft = _shift2[1];
                    shiftTop = parseFloat(shiftTop, 10);
                    shiftLeft = parseFloat(shiftLeft, 10);
                } else {
                    shiftTop = shift.top;
                    shiftLeft = shift.left;
                }
                top += shiftTop;
                left += shiftLeft;
                return {
                    top: top,
                    left: left
                };
            }
        });
        return Tether;
    });
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var viewport = __webpack_require__(78);
    module.exports = function() {
        var bootstrap4 = {
            xs: $('<div class="hidden-sm-up"></div>'),
            sm: $('<div class="hidden-xs-down hidden-md-up"></div>'),
            md: $('<div class="hidden-sm-down hidden-lg-up"></div>'),
            lg: $('<div class="hidden-md-down hidden-xl-up"></div>'),
            xl: $('<div class="hidden-lg-down"></div>')
        };
        viewport.use('Bootstrap4', bootstrap4);
        return viewport;
    };
}), (function(module, exports) {
    'use strict';
    /*!
     * Responsive Bootstrap Toolkit
     * Author: Maciej Gurban
     * License: MIT
     * Version: 2.6.3 (2016-06-21)
     * Origin: https://github.com/maciej-gurban/responsive-bootstrap-toolkit
     */
    var ResponsiveBootstrapToolkit = function($) {
        var internal = {
            detectionDivs: {
                bootstrap: {
                    'xs': $('<div class="device-xs visible-xs visible-xs-block"></div>'),
                    'sm': $('<div class="device-sm visible-sm visible-sm-block"></div>'),
                    'md': $('<div class="device-md visible-md visible-md-block"></div>'),
                    'lg': $('<div class="device-lg visible-lg visible-lg-block"></div>')
                },
                foundation: {
                    'small': $('<div class="device-xs show-for-small-only"></div>'),
                    'medium': $('<div class="device-sm show-for-medium-only"></div>'),
                    'large': $('<div class="device-md show-for-large-only"></div>'),
                    'xlarge': $('<div class="device-lg show-for-xlarge-only"></div>')
                }
            },
            applyDetectionDivs: function applyDetectionDivs() {
                $(document).ready(function() {
                    $.each(self.breakpoints, function(alias) {
                        self.breakpoints[alias].appendTo('.responsive-bootstrap-toolkit');
                    });
                });
            },
            isAnExpression: function isAnExpression(str) {
                return str.charAt(0) == '<' || str.charAt(0) == '>';
            },
            splitExpression: function splitExpression(str) {
                var operator = str.charAt(0);
                var orEqual = str.charAt(1) == '=' ? true : false;
                var index = 1 + (orEqual ? 1 : 0);
                var breakpointName = str.slice(index);
                return {
                    operator: operator,
                    orEqual: orEqual,
                    breakpointName: breakpointName
                };
            },
            isAnyActive: function isAnyActive(breakpoints) {
                var found = false;
                $.each(breakpoints, function(index, alias) {
                    if (self.breakpoints[alias].is(':visible')) {
                        found = true;
                        return false;
                    }
                });
                return found;
            },
            isMatchingExpression: function isMatchingExpression(str) {
                var expression = internal.splitExpression(str);
                var breakpointList = Object.keys(self.breakpoints);
                var pos = breakpointList.indexOf(expression.breakpointName);
                if (pos !== -1) {
                    var start = 0;
                    var end = 0;
                    if (expression.operator == '<') {
                        start = 0;
                        end = expression.orEqual ? ++pos : pos;
                    }
                    if (expression.operator == '>') {
                        start = expression.orEqual ? pos : ++pos;
                        end = undefined;
                    }
                    var acceptedBreakpoints = breakpointList.slice(start, end);
                    return internal.isAnyActive(acceptedBreakpoints);
                }
            }
        };
        var self = {
            interval: 300,
            framework: null,
            breakpoints: null,
            is: function is(str) {
                if (internal.isAnExpression(str)) {
                    return internal.isMatchingExpression(str);
                }
                return self.breakpoints[str] && self.breakpoints[str].is(':visible');
            },
            use: function use(frameworkName, breakpoints) {
                self.framework = frameworkName.toLowerCase();
                if (self.framework === 'bootstrap' || self.framework === 'foundation') {
                    self.breakpoints = internal.detectionDivs[self.framework];
                } else {
                    self.breakpoints = breakpoints;
                }
                internal.applyDetectionDivs();
            },
            current: function current() {
                var name = 'unrecognized';
                $.each(self.breakpoints, function(alias) {
                    if (self.is(alias)) {
                        name = alias;
                    }
                });
                return name;
            },
            changed: function changed(fn, ms) {
                var timer;
                return function() {
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        fn();
                    }, ms || self.interval);
                };
            }
        };
        $(document).ready(function() {
            $('<div class="responsive-bootstrap-toolkit"></div>').appendTo('body');
        });
        if (self.framework === null) {
            self.use('bootstrap');
        }
        return self;
    }(jQuery);
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = ResponsiveBootstrapToolkit;
    }
}), (function(module, exports, __webpack_require__) {
    (function(global) {
        'use strict';
        var Headroom = __webpack_require__(80);
        var mobileNav = __webpack_require__(81);
        var desktopNav = __webpack_require__(82);
        var isMobileNavActive;
        var $hamburger = $('.navbar-toggler');
        var headroomOffset = 500;
        var $header = $('#site__header');
        var $page = $('.page');

        function initializeNav() {
            if ($hamburger.is(':visible')) {
                mobileNav.init();
                isMobileNavActive = true;
            } else {
                desktopNav.init();
                isMobileNavActive = false;
            }
        }

        function initHeadroom() {
            if ($page.data('action') !== 'Search-Show') {
                $page.css('padding-top', $header.outerHeight());
                var headroom = new Headroom($header[0], {
                    offset: headroomOffset,
                    onUnpin: function() {
                        $('body').trigger('nav.unpinned', this);
                        $header.css('top', -$header.outerHeight());
                    },
                    onPin: function() {
                        $('body').trigger('nav.pinned', this);
                        $header.css('top', 0);
                        $page.css('padding-top', $header.outerHeight());
                    }
                });
                $('#site__header').data('headroom', headroom);
                headroom.init();
            }
        }

        function watchBreakpoint() {
            $(window).resize(global.viewport.changed(function() {
                if (global.viewport.is('>=lg') && isMobileNavActive) {
                    mobileNav.deinit();
                    desktopNav.init();
                    isMobileNavActive = false;
                } else if (global.viewport.is('<lg') && !isMobileNavActive) {
                    desktopNav.deinit();
                    mobileNav.init();
                    isMobileNavActive = true;
                }
                if ($page.data('action') !== 'Search-Show') {
                    $page.css('padding-top', $header.outerHeight());
                }
            }, 200));
        }
        module.exports = function() {
            initializeNav();
            initHeadroom();
            watchBreakpoint();
        };
    }.call(exports, (function() {
        return this;
    }())))
}), (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
     * headroom.js v0.9.4 - Give your page some headroom. Hide your header until you need it
     * Copyright (c) 2017 Nick Williams - http://wicky.nillia.ms/headroom.js
     * License: MIT
     */
    (function(root, factory) {
        'use strict';
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof exports === 'object') {
            module.exports = factory();
        } else {
            root.Headroom = factory();
        }
    }(this, function() {
        'use strict';
        var features = {
            bind: !!(function() {}.bind),
            classList: 'classList' in document.documentElement,
            rAF: !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)
        };
        window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;

        function Debouncer(callback) {
            this.callback = callback;
            this.ticking = false;
        }
        Debouncer.prototype = {
            constructor: Debouncer,
            update: function() {
                this.callback && this.callback();
                this.ticking = false;
            },
            requestTick: function() {
                if (!this.ticking) {
                    requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));
                    this.ticking = true;
                }
            },
            handleEvent: function() {
                this.requestTick();
            }
        };

        function isDOMElement(obj) {
            return obj && typeof window !== 'undefined' && (obj === window || obj.nodeType);
        }

        function extend(object) {
            if (arguments.length <= 0) {
                throw new Error('Missing arguments in extend function');
            }
            var result = object || {},
                key, i;
            for (i = 1; i < arguments.length; i++) {
                var replacement = arguments[i] || {};
                for (key in replacement) {
                    if (typeof result[key] === 'object' && !isDOMElement(result[key])) {
                        result[key] = extend(result[key], replacement[key]);
                    } else {
                        result[key] = result[key] || replacement[key];
                    }
                }
            }
            return result;
        }

        function normalizeTolerance(t) {
            return t === Object(t) ? t : {
                down: t,
                up: t
            };
        }

        function Headroom(elem, options) {
            options = extend(options, Headroom.options);
            this.lastKnownScrollY = 0;
            this.elem = elem;
            this.tolerance = normalizeTolerance(options.tolerance);
            this.classes = options.classes;
            this.offset = options.offset;
            this.scroller = options.scroller;
            this.initialised = false;
            this.onPin = options.onPin;
            this.onUnpin = options.onUnpin;
            this.onTop = options.onTop;
            this.onNotTop = options.onNotTop;
            this.onBottom = options.onBottom;
            this.onNotBottom = options.onNotBottom;
        }
        Headroom.prototype = {
            constructor: Headroom,
            init: function() {
                if (!Headroom.cutsTheMustard) {
                    return;
                }
                this.debouncer = new Debouncer(this.update.bind(this));
                this.elem.classList.add(this.classes.initial);
                setTimeout(this.attachEvent.bind(this), 100);
                return this;
            },
            destroy: function() {
                var classes = this.classes;
                this.initialised = false;
                for (var key in classes) {
                    if (classes.hasOwnProperty(key)) {
                        this.elem.classList.remove(classes[key]);
                    }
                }
                this.scroller.removeEventListener('scroll', this.debouncer, false);
            },
            attachEvent: function() {
                if (!this.initialised) {
                    this.lastKnownScrollY = this.getScrollY();
                    this.initialised = true;
                    this.scroller.addEventListener('scroll', this.debouncer, false);
                    this.debouncer.handleEvent();
                }
            },
            unpin: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {
                    classList.add(classes.unpinned);
                    classList.remove(classes.pinned);
                    this.onUnpin && this.onUnpin.call(this);
                }
            },
            pin: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (classList.contains(classes.unpinned)) {
                    classList.remove(classes.unpinned);
                    classList.add(classes.pinned);
                    this.onPin && this.onPin.call(this);
                }
            },
            top: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (!classList.contains(classes.top)) {
                    classList.add(classes.top);
                    classList.remove(classes.notTop);
                    this.onTop && this.onTop.call(this);
                }
            },
            notTop: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (!classList.contains(classes.notTop)) {
                    classList.add(classes.notTop);
                    classList.remove(classes.top);
                    this.onNotTop && this.onNotTop.call(this);
                }
            },
            bottom: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (!classList.contains(classes.bottom)) {
                    classList.add(classes.bottom);
                    classList.remove(classes.notBottom);
                    this.onBottom && this.onBottom.call(this);
                }
            },
            notBottom: function() {
                var classList = this.elem.classList,
                    classes = this.classes;
                if (!classList.contains(classes.notBottom)) {
                    classList.add(classes.notBottom);
                    classList.remove(classes.bottom);
                    this.onNotBottom && this.onNotBottom.call(this);
                }
            },
            getScrollY: function() {
                return (this.scroller.pageYOffset !== undefined) ? this.scroller.pageYOffset : (this.scroller.scrollTop !== undefined) ? this.scroller.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop;
            },
            getViewportHeight: function() {
                return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            },
            getElementPhysicalHeight: function(elm) {
                return Math.max(elm.offsetHeight, elm.clientHeight);
            },
            getScrollerPhysicalHeight: function() {
                return (this.scroller === window || this.scroller === document.body) ? this.getViewportHeight() : this.getElementPhysicalHeight(this.scroller);
            },
            getDocumentHeight: function() {
                var body = document.body,
                    documentElement = document.documentElement;
                return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
            },
            getElementHeight: function(elm) {
                return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
            },
            getScrollerHeight: function() {
                return (this.scroller === window || this.scroller === document.body) ? this.getDocumentHeight() : this.getElementHeight(this.scroller);
            },
            isOutOfBounds: function(currentScrollY) {
                var pastTop = currentScrollY < 0,
                    pastBottom = currentScrollY + this.getScrollerPhysicalHeight() > this.getScrollerHeight();
                return pastTop || pastBottom;
            },
            toleranceExceeded: function(currentScrollY, direction) {
                return Math.abs(currentScrollY - this.lastKnownScrollY) >= this.tolerance[direction];
            },
            shouldUnpin: function(currentScrollY, toleranceExceeded) {
                var scrollingDown = currentScrollY > this.lastKnownScrollY,
                    pastOffset = currentScrollY >= this.offset;
                return scrollingDown && pastOffset && toleranceExceeded;
            },
            shouldPin: function(currentScrollY, toleranceExceeded) {
                var scrollingUp = currentScrollY < this.lastKnownScrollY,
                    pastOffset = currentScrollY <= this.offset;
                return (scrollingUp && toleranceExceeded) || pastOffset;
            },
            update: function() {
                var currentScrollY = this.getScrollY(),
                    scrollDirection = currentScrollY > this.lastKnownScrollY ? 'down' : 'up',
                    toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);
                if (this.isOutOfBounds(currentScrollY)) {
                    return;
                }
                if (currentScrollY <= this.offset) {
                    this.top();
                } else {
                    this.notTop();
                }
                if (currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {
                    this.bottom();
                } else {
                    this.notBottom();
                }
                if (this.shouldUnpin(currentScrollY, toleranceExceeded)) {
                    this.unpin();
                } else if (this.shouldPin(currentScrollY, toleranceExceeded)) {
                    this.pin();
                }
                this.lastKnownScrollY = currentScrollY;
            }
        };
        Headroom.options = {
            tolerance: {
                up: 0,
                down: 0
            },
            offset: 0,
            scroller: window,
            classes: {
                pinned: 'headroom--pinned',
                unpinned: 'headroom--unpinned',
                top: 'headroom--top',
                notTop: 'headroom--not-top',
                bottom: 'headroom--bottom',
                notBottom: 'headroom--not-bottom',
                initial: 'headroom'
            }
        };
        Headroom.cutsTheMustard = typeof features !== 'undefined' && features.rAF && features.bind && features.classList;
        return Headroom;
    }));
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var initStatus = {
        carousel1: false,
        swipe: false
    };
    var ns = '.nav.mobile';
    var $htmlPage = $('html');
    var $hamburger = $('.navbar-toggler');
    var $siteNav = $('.site-nav');
    var $siteNavListWrapper = $('.site-nav__list__wrapper');
    var $close = $siteNav.find('.site-nav__close__link');
    var $back = $siteNav.find('.site-nav__back__link');
    var $breadcrumb = $siteNav.find('.site-nav__breadcrumb');
    var $catList = $siteNav.find('.site-nav__list, .site-nav__list-top');
    var $topList = $siteNav.find('.site-nav__list-top');
    var $catListSwipe = $catList.find('.secondary-anchor, .tertiary-anchor');
    var carousel1 = __webpack_require__(29);
    var $carousel1 = $('.site-nav__carousel1');

    function initcarousel1() {
        if (initStatus.carousel1 === false) {
            if ($carousel1.length) {
                $carousel1.each(function() {
                    var options = {
                        mouseDrag: true,
                        nav: false,
                        dots: false,
                        items: 5,
                        autoWidth: true
                    };
                    carousel1.init($(this), options);
                });
            }
            initStatus.carousel1 = true;
        } else {
            $carousel1.show();
        }
    }

    function shiftRight() {
        var shiftValue = parseInt($topList[0].style.left, 10) - 100;
        $topList.css('left', shiftValue.toString() + '%');
        $siteNavListWrapper.scrollTop(0);
        $back.show();
    }

    function shiftLeft() {
        var currentValue = parseInt($topList[0].style.left, 10);
        var shiftValue = Math.min(currentValue + 100, 0);
        $topList.css('left', shiftValue.toString() + '%');
        $siteNavListWrapper.scrollTop(0);
        if (shiftValue === 0) {
            $back.hide();
        }
    }

    function addToBreadcrumb($target) {
        var $newBreadcrumbElement = $('<a>', {
            href: '#',
            class: 'site-nav__breadcrumb__item',
            text: $target.text()
        });
        $breadcrumb.append($newBreadcrumbElement);
    }

    function removeFromBreadcrumb() {
        $breadcrumb.children('.site-nav__breadcrumb__item').last().remove();
    }

    function showChildMenu($target) {
        $target.parents('.site-nav__list__item').siblings('.site-nav__list__item').children('.site-nav__flyout').find('.site-nav__list').hide();
        $target.parents('.site-nav__list__item').siblings('.site-nav__list__item').find('.site-nav__list').hide();
        $target.parent('.site-nav__list__item').find('.site-nav__list, .site-nav__flyout .site-nav__list').show();
    }

    function handleCategoryClick(e) {
        e.stopPropagation();
        var $link = $(e.currentTarget);
        var $target = $(e.target);
        var clickedOnName = $target.hasClass('site-nav__list__name');
        var isTopLevelLink = $link.hasClass('primary-anchor');
        var wasSwiped = false;
        var lastSwipe = $link.data('last-swipe');
        if (lastSwipe !== undefined) {
            if ((new Date()).getTime() - lastSwipe < 200) {
                wasSwiped = true;
            }
        }
        if (wasSwiped === true) {
            e.preventDefault();
        } else if (isTopLevelLink === true) {
            if ($link.data('children')) {
                e.preventDefault();
                shiftRight();
                showChildMenu($link);
                addToBreadcrumb($link);
            }
        } else {
            if (clickedOnName === true) {} else if ($link.data('children')) {
                e.preventDefault();
                shiftRight();
                showChildMenu($link);
                addToBreadcrumb($link);
            }
        }
    }

    function handleBackClick(e) {
        e.preventDefault();
        shiftLeft();
        removeFromBreadcrumb();
    }

    function handleBackSwipe() {
        shiftLeft();
        removeFromBreadcrumb();
    }

    function initializeSwipeEvents() {
        if (initStatus.swipe === false) {
            $catListSwipe.swipe({
                swipeRight: function(event, direction, distance, duration, fingerCount, fingerData) {
                    $(this).data('last-swipe', (new Date()).getTime());
                    handleBackSwipe();
                },
                threshold: 50,
                excludedElements: '.noSwipe',
                allowPageScroll: 'auto'
            });
            initStatus.swipe = true;
        } else {
            $catListSwipe.swipe('enable');
        }
    }

    function initializeEvents() {
        $hamburger.off(ns).on('click' + ns, function(e) {
            e.preventDefault();
            $siteNav.addClass('js-active');
            $htmlPage.addClass('js-menu-active');
        });
        $close.off(ns).on('click' + ns, function(e) {
            e.preventDefault();
            $siteNav.removeClass('js-active');
            $htmlPage.removeClass('js-menu-active');
        });
        $catList.off(ns).on('click' + ns, 'a.site-nav__list__link', handleCategoryClick);
        $back.off(ns).on('click' + ns, handleBackClick);
        $breadcrumb.off(ns).on('click' + ns, handleBackClick);
    }

    function initialize() {
        $topList.css('left', '0%');
        initializeEvents();
        initializeSwipeEvents();
        initcarousel1();
    }

    function deinitialize() {
        $topList.css('left', 'auto');
        $catList.off(ns);
        $hamburger.off(ns);
        $close.off(ns);
        $back.off(ns);
        $catList.removeAttr('style');
        $siteNav.find('.site-nav__list, .site-nav__flyout').removeAttr('style');
        if (initStatus.swipe === true) {
            $catListSwipe.swipe('disable');
        }
        $breadcrumb.empty();
        $carousel1.hide();
        $back.hide();
    }
    module.exports = {
        init: initialize,
        deinit: deinitialize
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var initStatus = {
        carousel1: false
    };
    var ns = '.nav.desktop';
    var $siteNav = $('.site-nav');
    var $siteLogo = $('.header-logo');
    var $topList = $siteNav.find('.site-nav__list-top');
    var $topCats = $topList.find('.site-nav__list-top__item');
    var $secondaryList = $topCats.children('.site-nav__flyout').children('.site-nav__list-secondary');
    var $secondaryCats = $secondaryList.children('.site-nav__list__item');
    var utils = __webpack_require__(10);
    var carousel1 = __webpack_require__(29);
    var $carousel1 = $('.explore-carousel1');

    function initcarousel1() {
        if (initStatus.carousel1 === false) {
            if ($carousel1.length) {
                $carousel1.each(function() {
                    var options = {
                        items: 6,
                        mouseDrag: true,
                        nav: true,
                        dots: false,
                        margin: 0,
                        stagePadding: 0,
                        loop: false,
                        slideBy: 6,
                        navText: [utils.generateSvgString('chevron-left', 'explore-carousel1__arrow'), utils.generateSvgString('chevron-right', 'explore-carousel1__arrow')]
                    };
                    carousel1.init($(this), options);
                });
            }
            initStatus.carousel1 = true;
        } else {
            $carousel1.show();
        }
    }

    function closeFlyout(e) {
        if (e === undefined) {
            $('.site-nav__flyout').hide();
        } else if ($carousel1.find(e.target).length === 0) {
            $('.site-nav__flyout').hide();
        }
    }

    function openFlyout(e, menuItem) {
        var $target = e ? $(e.target).parents('.site-nav__list__item') : menuItem;
        var $flyout = $target.children('.site-nav__flyout');
        closeFlyout();
        if ($flyout.length) {
            $flyout.show();
            $('body').trigger('nav.flyoutopen');
        }
    }

    function setupFirstPanels() {
        $topCats.each(function() {
            var $scope = $(this);
            var $secondaryAnchors = $scope.find('.secondary-anchor');
            var categoryid = $secondaryAnchors.removeClass('hovered').first().addClass('hovered').data('categoryid');
            if (categoryid !== undefined) {
                var menuFlyoutID = '#menuflyout-' + categoryid;
                var $flyoutPanel = $scope.find('.site-nav__flyout');
                var $flyoutShown = $flyoutPanel.find(menuFlyoutID).show();
                if ($flyoutShown.length > 0) {
                    $flyoutPanel.find('.kop-menuflyout').not($flyoutShown).hide();
                }
            }
            $scope.find('.site-nav__list-secondary .site-nav__list__item').first().find('.site-nav__list-tertiary').show();
        });
    }

    function closePanel($target) {
        $target.siblings('.site-nav__list__item').children('.site-nav__list').hide();
    }

    function openPanel(e) {
        var $target = $(e.target);
        $target.parents('.site-nav__list-secondary').find('.secondary-anchor').not($target).removeClass('hovered');
        $target.addClass('hovered');
        var menuFlyoutID = '#menuflyout-' + $target.data('categoryid');
        var $flyoutPanel = $target.parents('.site-nav__flyout');
        var $flyoutShown = $flyoutPanel.find(menuFlyoutID).show();
        if ($flyoutShown.length > 0) {
            $flyoutPanel.find('.kop-menuflyout').not($flyoutShown).hide();
        }
        if (!$target.hasClass('site-nav__list__item')) {
            $target = $target.parents('.site-nav__list__item');
        }
        var $panel = $target.children('.site-nav__list');
        closePanel($target);
        if ($panel.length) {
            $panel.show();
        }
    }

    function handleDownKey($menuItem) {
        if ($menuItem.hasClass('site-nav__list-top__item') && $menuItem.children('.site-nav__flyout').length) {
            openFlyout(null, $menuItem);
            $menuItem.children('.site-nav__flyout').find('.site-nav__list__link').first().focus();
        } else if ($menuItem.next().length) {
            $menuItem.next().find('.site-nav__list__link').first().focus();
        }
    }

    function handleUpKey($menuItem) {
        if (!$menuItem.hasClass('site-nav__list-top__item') && $menuItem.prev().length) {
            $menuItem.prev().find('.site-nav__list__link').first().focus();
        } else if ($menuItem.parents('.site-nav__flyout:visible')) {
            closeFlyout();
            $menuItem.parents('.site-nav__list-top__item').children('.site-nav__list__link').first().focus();
        }
    }

    function handleLeftKey($menuItem) {
        if ($menuItem.hasClass('site-nav__list-top__item') && $menuItem.prev().length) {
            $menuItem.prev().children('.site-nav__list__link').focus();
        } else if ($menuItem.parent('.site-nav__list-secondary').length) {
            $menuItem.parent('.site-nav__list-secondary').siblings('.site-nav__list__link').first().focus();
        }
    }

    function handleRightKey($menuItem) {
        if ($menuItem.hasClass('site-nav__list-top__item') && $menuItem.next().length) {
            $menuItem.next().children('.site-nav__list__link').focus();
        } else if ($menuItem.children('.site-nav__list').length) {
            $menuItem.children('.site-nav__list').find('.site-nav__list__link').first().focus();
        }
    }

    function resetFocus() {
        $siteLogo.find('a').focus();
    }

    function handleKeyEvent(e) {
        var key = e.which;
        var supportedKeyCodes = [37, 38, 39, 40, 27];
        var $menuItem = $(this).parent();
        if (supportedKeyCodes.indexOf(key) >= 0) {
            e.preventDefault();
        }
        switch (key) {
            case 40:
                handleDownKey($menuItem);
                break;
            case 39:
                handleRightKey($menuItem);
                break;
            case 38:
                handleUpKey($menuItem);
                break;
            case 37:
                handleLeftKey($menuItem);
                break;
            case 27:
                closeFlyout();
                resetFocus();
                break;
            default:
                break;
        }
    }

    function initializeEvents() {
        $topCats.off(ns).on('mouseenter' + ns, openFlyout);
        $siteNav.off(ns).on('mouseleave' + ns, closeFlyout);
        $secondaryCats.off(ns).on('mouseenter' + ns, openPanel);
        $secondaryCats.on('focus' + ns, '.site-nav__list__link', openPanel);
        $siteNav.on('keydown' + ns, 'a', handleKeyEvent);
    }

    function initialize() {
        initializeEvents();
        setupFirstPanels();
        initcarousel1();
    }

    function deinitialize() {
        $topCats.off(ns);
        $siteNav.off(ns);
        $secondaryCats.off(ns);
        $siteNav.find('.site-nav__list, .site-nav__flyout').removeAttr('style');
        $carousel1.hide();
    }
    module.exports = {
        init: initialize,
        deinit: deinitialize
    };
}), (function(module, exports) {
    (function(global) {
        'use strict';
        var DATA_LAYER_CLICK = 'data-layer-info';
        var DATA_SET_LOCAL_STORAGE = 'data-set-local-storage';

        function trackPageViewPort() {
            var viewportMapping = {
                xs: 'mobile',
                sm: 'mobile',
                md: 'tablet',
                lg: 'tablet',
                xl: 'desktop'
            };
            $(document).ready(function() {
                window.pageData.navigation.viewport = viewportMapping[global.viewport.current()];
            });
            $(window).resize(global.viewport.changed(function() {
                window.pageData.navigation.viewport = viewportMapping[global.viewport.current()];
            }, 200));
        }

        function safeJSONParse(string) {
            try {
                return JSON.parse(string);
            } catch (e) {
                return null;
            }
        }

        function findPageDataLayerClickInfo(target, attribute) {
            let element = target.nodeType === Node.TEXT_NODE ? target.parentNode : target;
            while (element && element.nodeType === Node.ELEMENT_NODE) {
                if (element.hasAttribute(attribute)) {
                    return safeJSONParse(element.getAttribute(attribute));
                }
                element = element.parentNode;
            }
            return null;
        }

        function handleClick(e) {
            let eventInfo = findPageDataLayerClickInfo(e.target, DATA_LAYER_CLICK);
            if (eventInfo !== null) {
                if (eventInfo.type === 'event') {
                    window.pageData[eventInfo.type].push(eventInfo.interaction);
                } else {
                    window.pageData[eventInfo.type] = eventInfo.interaction;
                }
            }
        }

        function setLocalStorageItem(e) {
            let eventInfo = findPageDataLayerClickInfo(e.target, DATA_SET_LOCAL_STORAGE);
            if (eventInfo !== null) {
                localStorage.setItem('pageData', JSON.stringify([eventInfo]));
            }
        }

        function getLocalStorageItem() {
            if ('pageData' in localStorage) {
                var parsedData = safeJSONParse(localStorage.pageData);
                parsedData.forEach(function(item) {
                    if (item.name === 'event') {
                        window.pageData[item.name].push(item.interaction);
                    } else {
                        var existingObject = window.pageData[item.name] || {};
                        var localStorageObject = item.interaction;
                        if (typeof localStorageObject === 'object') {
                            Object.keys(localStorageObject).forEach(function(key) {
                                existingObject[key] = localStorageObject[key];
                            });
                        }
                        window.pageData[item.name] = existingObject;
                    }
                });
                localStorage.removeItem('pageData');
            }
        }

        function init() {
            if ($('[data-signal-enabled]').data('signalEnabled')) {
                $(document).click(handleClick);
                $(document).click(setLocalStorageItem);
                getLocalStorageItem();
                trackPageViewPort();
            }
        }
        module.exports = function() {
            init();
        };
    }.call(exports, (function() {
        return this;
    }())))
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var utils = __webpack_require__(10);
    var $geoModal = $('#modal-geoip-cookies');

    function getLocaleModal() {
        return $('#locale-modal');
    }

    function createCookie() {
        utils.createCookie('pumacookies', '1', 365);
    }

    function suppressFutureModals() {
        $.get($geoModal.data('action'));
    }

    function handleLocaleModalRedirect(e) {
        e.preventDefault();
        var url = $(e.target).data('action');
        $.get({
            url: url,
            success: function() {
                window.location = e.target.href;
            }
        });
    }

    function initializeNotifications() {
        $('body').append($geoModal.detach());
        if (!$geoModal.length) {
            return;
        }
        $geoModal.modal();
        $geoModal.on('click', '.notification__dismiss', function() {
            if ($geoModal.find('.notification__message').length > 1) {
                $(this).parents('.notification__message').remove();
            } else {
                $geoModal.modal('hide');
            }
        });
        $geoModal.on('hide.bs.modal', function() {
            createCookie();
            suppressFutureModals();
        });
    }

    function openLocaleModal(e) {
        e.preventDefault();
        if (getLocaleModal().length) {
            getLocaleModal().modal();
        } else {
            var url = this.href;
            var localeScript = this.getAttribute('data-script');
            var translatedLanguage = this.getAttribute('data-translated-language');
            var hasTranslatedLanguage = translatedLanguage && translatedLanguage.length && translatedLanguage !== 'null';
            if (hasTranslatedLanguage) {
                url = utils.appendParamToURL(url, 'l', translatedLanguage);
            }
            $('body').spinner().start();
            $.ajax({
                url: url,
                method: 'GET',
                beforeSend: function(xhr) {
                    if (hasTranslatedLanguage) {
                        xhr.setRequestHeader('X-Language', translatedLanguage);
                    }
                },
                success: function(response) {
                    $('body').append(response);
                    getLocaleModal().modal('show');
                    $.getScript(localeScript);
                    $.spinner().stop();
                },
                error: function() {
                    $.spinner().stop();
                }
            });
        }
    }

    function initializeLocaleModal() {
        $('#site__header .country-selector__link').on('click', openLocaleModal);
        $('#modal-geoip-cookies .localeselector--open').on('click', openLocaleModal);
        $('#modal-geoip-cookies .notification__btn--continue').on('click', handleLocaleModalRedirect);
        $.when(function() {
            const dfd = new jQuery.Deferred();
            if (typeof webComponentsEventBus !== 'undefined') {
                dfd.resolve(webComponentsEventBus);
            } else {
                window.addEventListener('webComponentsEventBusReady', function() {
                    dfd.resolve(webComponentsEventBus);
                });
            }
            return dfd;
        }).then(function() {
            webComponentsEventBus.addEventListener('changeLocale', function(event) {
                const dataObject = document.getElementById('locale-selector-trigger');
                openLocaleModal.call(dataObject, event);
            });
        });
    }
    module.exports = function() {
        initializeNotifications();
        initializeLocaleModal();
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var debounce = __webpack_require__(86);
    var request;
    var endpoint = $('.search-btn').data('url');
    var minChars = !isNaN($('.search-btn').data('min-characters')) ? $('.search-btn').data('min-characters') : 3;
    var maxSearch = !isNaN($('.search-btn').data('max-search-terms')) ? $('.search-btn').data('max-search-terms') : 3;
    var maxCategories = !isNaN($('.search-btn').data('max-categories')) ? $('.search-btn').data('max-categories') : 3;
    var searchDebounceDelay = 300;
    __webpack_require__(98);

    function tearDownSuggestions() {
        if (request !== undefined) {
            request.abort();
        }
        $('.search__results__section').addClass('visually-hidden');
        $('.search__results__section ul').empty();
        $('.search__results').addClass('visually-hidden');
    }

    function getSearchSuggestions(containerClass, $scope) {
        if ($scope.val().length >= minChars) {
            request = $.ajax({
                context: $scope[0],
                url: endpoint + $scope.val(),
                method: 'GET',
                success: function(response) {
                    processResponse(response, containerClass);
                    $('.search__results__list a').click(function(e) {
                        localStorage.setItem('pageData', JSON.stringify([{
                            name: 'onsiteSearch',
                            interaction: {
                                clickedResult: e.currentTarget.innerText,
                                searchTerm: $('.search__input').val(),
                                autoCompleteTerm: $(this).attr('data-autoCompleteTerm'),
                                autoCompleteType: $(this).attr('data-autoCompleteType')
                            }
                        }]));
                    });
                },
                error: function() {
                    window.console.warn('Something went wrong with Header Search..!');
                }
            });
        } else {
            tearDownSuggestions();
        }
    }

    function processResponse(response, containerClass) {
        var autosuggestHelpers = __webpack_require__(99);
        var $sectionCategories = $('.' + containerClass + ' .search__results__section--categories');
        var $sectionDidYouMean = $('.' + containerClass + ' .search__results__section--didYouMean');
        $sectionCategories.addClass('visually-hidden');
        $sectionDidYouMean.addClass('visually-hidden');
        $('.' + containerClass + ' .search__results').addClass('visually-hidden');
        $('.' + containerClass + ' .search__results__section ul').empty();
        var keywordSuggestions = [];
        var categorySuggestions = [];
        if ((typeof(response) === 'object')) {
            keywordSuggestions = response.didYouMean;
            categorySuggestions = response.categories;
            var searchPhrase = response.searchPhrase;
            if (Object.prototype.hasOwnProperty.call(response, 'response') && Object.prototype.hasOwnProperty.call(response.response, 'suggestions')) {
                var searchResultsEndpoint = $('.search-btn').attr('href');
                searchPhrase = response.response.q;
                keywordSuggestions = autosuggestHelpers.getBRKeywordSuggestions(response.response, searchResultsEndpoint, maxSearch);
                categorySuggestions = autosuggestHelpers.getBRCategorySuggestions(response.response, searchResultsEndpoint, maxCategories);
            }
            if (categorySuggestions && categorySuggestions.length) {
                $.each(categorySuggestions, function(i, cat) {
                    $sectionCategories.find('ul').append('<li><a data-autoCompleteTerm="' + cat.text +
                        '" data-autoCompleteType="categories" href="' + cat.url + '">' + cat.text + '</a></li>');
                });
                $sectionCategories.removeClass('visually-hidden');
            }
            if (keywordSuggestions && keywordSuggestions.length) {
                $.each(keywordSuggestions, function(i, cat) {
                    $sectionDidYouMean.find('ul').append('<li><a data-autoCompleteTerm="' + cat.text +
                        '" data-autoCompleteType="didYouMean" href="' + cat.url + '">' + cat.text + '</a></li>');
                });
                $sectionDidYouMean.unhighlight();
                $sectionDidYouMean.highlight(searchPhrase);
                $sectionDidYouMean.removeClass('visually-hidden');
            }
        }
        if ((categorySuggestions && categorySuggestions.length) || (keywordSuggestions && keywordSuggestions.length)) {
            $('.' + containerClass + ' .search__results').removeClass('visually-hidden');
            $('.' + containerClass + ' .search__link__barcode').hide();
        }
    }

    function setupDesktopSearch() {
        var $searchInput = $('#search__input-desktop');
        if (!$searchInput.length) {
            return;
        }
        var positionSearchDropDown = function() {
            var searchBoxPosition = $('.header-search').offset();
            var headerHeight = $('.site__header__top').height();
            $('.search__overlay--desktop .search__results').css('left', searchBoxPosition.left).css('top', headerHeight);
        };
        var debounceSuggestions = debounce(function() {
            getSearchSuggestions('search__overlay--desktop', $searchInput);
        }, searchDebounceDelay);
        $searchInput.on('keyup click', function() {
            positionSearchDropDown();
            debounceSuggestions();
            $(document).off('click.closeDesktopSearch').on('click.closeDesktopSearch', function(event) {
                if ($(event.target).parents('.search__overlay--desktop, .search__input__container').length === 0) {
                    tearDownSuggestions();
                    $(this).unbind(event);
                }
            });
            if ($(this).val().length === 0) {
                $('.header-search .search__input__icon-reset').addClass('visually-hidden');
            } else {
                $('.header-search .search__input__icon-reset').removeClass('visually-hidden');
            }
        });
        $('.header-search .search__input__icon-reset').on('click', function() {
            tearDownSuggestions();
            $(this).addClass('visually-hidden');
        });
        $('body').on('nav.flyoutopen nav.unpinned', function() {
            if ($searchInput.val()) {
                tearDownSuggestions();
            }
        });
        $('body').on('nav.pinned', function() {
            if ($searchInput.val()) {
                getSearchSuggestions('search__overlay--desktop', $searchInput);
            }
        });
        $(window).resize(function() {
            positionSearchDropDown();
        });
    }

    function setupMobileSearch() {
        var $searchModalMobile = $('#search__modal--mobile');
        var $searchInput = $('#search__input-mobile');
        var $activeInputFields = $('input, select, textarea').not($searchInput);
        if (!$searchInput.length || !$searchModalMobile.length) {
            return;
        }
        $('body').append($searchModalMobile.detach());
        $searchModalMobile.find('.modal-fs__close').eq(0).on('click', function() {
            $searchModalMobile.hide();
            $searchModalMobile.css('opacity', 0);
            $activeInputFields.prop('disabled', false);
            tearDownSuggestions();
            $searchInput.val('');
        });
        $('#site__header .search-btn').on('click', function(e) {
            e.preventDefault();
            $searchModalMobile.show();
            $searchModalMobile.css('opacity', 1);
            $activeInputFields.prop('disabled', true);
            $searchInput.focus();
        });
        var debounceSuggestions = debounce(function() {
            getSearchSuggestions('search__modal--mobile', $searchInput);
        }, searchDebounceDelay);
        $searchInput.on('keyup click', function() {
            debounceSuggestions();
            if ($(this).val().length === 0) {
                $('.search__modal--mobile .search__input__icon-reset').addClass('visually-hidden');
                $('.modal-body .search__link__barcode').show();
            } else {
                $('.search__modal--mobile .search__input__icon-reset').removeClass('visually-hidden');
                $('.modal-body .search__link__barcode').hide();
            }
        });
        $('.search__modal--mobile .search__input__icon-reset').on('click', function() {
            tearDownSuggestions();
            $(this).addClass('visually-hidden');
            $('.modal-body .search__link__barcode').show();
        });
    }
    module.exports = function() {
        setupMobileSearch();
        setupDesktopSearch();
    };
}), (function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(87),
        now = __webpack_require__(88),
        toNumber = __webpack_require__(91);
    var FUNC_ERROR_TEXT = 'Expected a function';
    var nativeMax = Math.max,
        nativeMin = Math.min;

    function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
        if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;
            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }

        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }

        function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;
            return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
            timerId = undefined;
            if (trailing && lastArgs) {
                return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
        }

        function cancel() {
            if (timerId !== undefined) {
                clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
            return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
                if (timerId === undefined) {
                    return leadingEdge(lastCallTime);
                }
                if (maxing) {
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined) {
                timerId = setTimeout(timerExpired, wait);
            }
            return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
    }
    module.exports = debounce;
}), (function(module, exports) {
    function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
    }
    module.exports = isObject;
}), (function(module, exports, __webpack_require__) {
    var root = __webpack_require__(89);
    var now = function() {
        return root.Date.now();
    };
    module.exports = now;
}), (function(module, exports, __webpack_require__) {
    var freeGlobal = __webpack_require__(90);
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function('return this')();
    module.exports = root;
}), (function(module, exports) {
    (function(global) {
        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
        module.exports = freeGlobal;
    }.call(exports, (function() {
        return this;
    }())))
}), (function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(87),
        isSymbol = __webpack_require__(92);
    var NAN = 0 / 0;
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;

    function toNumber(value) {
        if (typeof value == 'number') {
            return value;
        }
        if (isSymbol(value)) {
            return NAN;
        }
        if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
        }
        if (typeof value != 'string') {
            return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
    }
    module.exports = toNumber;
}), (function(module, exports, __webpack_require__) {
    var baseGetTag = __webpack_require__(93),
        isObjectLike = __webpack_require__(97);
    var symbolTag = '[object Symbol]';

    function isSymbol(value) {
        return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }
    module.exports = isSymbol;
}), (function(module, exports, __webpack_require__) {
    var Symbol = __webpack_require__(94),
        getRawTag = __webpack_require__(95),
        objectToString = __webpack_require__(96);
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return (symToStringTag && symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
}), (function(module, exports, __webpack_require__) {
    var root = __webpack_require__(89);
    var Symbol = root.Symbol;
    module.exports = Symbol;
}), (function(module, exports, __webpack_require__) {
    var Symbol = __webpack_require__(94);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];
        try {
            value[symToStringTag] = undefined;
            var unmasked = true;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag] = tag;
            } else {
                delete value[symToStringTag];
            }
        }
        return result;
    }
    module.exports = getRawTag;
}), (function(module, exports) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;

    function objectToString(value) {
        return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
}), (function(module, exports) {
    function isObjectLike(value) {
        return value != null && typeof value == 'object';
    }
    module.exports = isObjectLike;
}), (function(module, exports) {
    jQuery.extend({
        highlight: function(node, re, nodeName, className) {
            if (node.nodeType === 3) {
                var match = node.data.match(re);
                if (match) {
                    var highlight = document.createElement(nodeName || 'span');
                    highlight.className = className || 'highlight';
                    var wordNode = node.splitText(match.index);
                    wordNode.splitText(match[0].length);
                    var wordClone = wordNode.cloneNode(true);
                    highlight.appendChild(wordClone);
                    wordNode.parentNode.replaceChild(highlight, wordNode);
                    return 1;
                }
            } else if ((node.nodeType === 1 && node.childNodes) && !/(script|style)/i.test(node.tagName) && !(node.tagName === nodeName.toUpperCase() && node.className === className)) {
                for (var i = 0; i < node.childNodes.length; i++) {
                    i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
                }
            }
            return 0;
        }
    });
    jQuery.fn.unhighlight = function(options) {
        var settings = {
            className: 'highlight',
            element: 'span'
        };
        jQuery.extend(settings, options);
        return this.find(settings.element + "." + settings.className).each(function() {
            var parent = this.parentNode;
            parent.replaceChild(this.firstChild, this);
            parent.normalize();
        }).end();
    };
    jQuery.fn.highlight = function(words, options) {
        var settings = {
            className: 'highlight',
            element: 'span',
            caseSensitive: false,
            wordsOnly: false
        };
        jQuery.extend(settings, options);
        if (words.constructor === String) {
            words = [words];
        }
        words = jQuery.grep(words, function(word, i) {
            return word != '';
        });
        words = jQuery.map(words, function(word, i) {
            return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        });
        if (words.length == 0) {
            return this;
        };
        var flag = settings.caseSensitive ? "" : "i";
        var pattern = "(" + words.join("|") + ")";
        if (settings.wordsOnly) {
            pattern = "\\b" + pattern + "\\b";
        }
        var re = new RegExp(pattern, flag);
        return this.each(function() {
            jQuery.highlight(this, re, settings.element, settings.className);
        });
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';

    function getBRKeywordSuggestions(response, endpoint, maxItems) {
        const utils = __webpack_require__(10);
        const searchTerms = response.suggestions.slice(0, maxItems);
        const keywordSuggestions = searchTerms.map(function(term) {
            const query = term.q;
            const displayQuery = term.dq;
            const url = utils.appendParamToURL(endpoint, 'q', query);
            return {
                url: url,
                text: displayQuery
            };
        });
        return keywordSuggestions;
    }

    function getBRCategorySuggestions(response, endpoint, maxItems) {
        const utils = __webpack_require__(10);
        const searchTerms = response.suggestions;
        let categories = [];
        if (searchTerms[0] && searchTerms[0].filters) {
            categories = searchTerms[0].filters;
        }
        const categorySuggestions = categories.slice(0, maxItems).map(function(category) {
            const categoryID = getCategoryIDFromString(category.value);
            const categoriesBreadcrumb = getCategoryBreadcrumbFromString(category.name);
            const url = utils.appendParamToURL(endpoint, 'cgid', categoryID);
            return {
                url: url,
                text: categoriesBreadcrumb
            };
        });
        return categorySuggestions;
    }

    function getCategoryIDFromString(catString) {
        const splitedCategories = catString.split('/');
        const lastCategory = splitedCategories[splitedCategories.length - 1];
        const catID = lastCategory.split(',')[0];
        return catID;
    }

    function getCategoryBreadcrumbFromString(catString) {
        const splitedCategories = catString.split('/').filter(function(cat) {
            return cat !== '';
        });
        const catBreadcrumb = splitedCategories.map(function(cat) {
            if (cat.indexOf(',') > -1) {
                return cat.split(',')[1];
            }
            return cat;
        }).join(' > ');
        return catBreadcrumb;
    }
    module.exports = {
        getBRKeywordSuggestions: getBRKeywordSuggestions,
        getBRCategorySuggestions: getBRCategorySuggestions
    };
}), (function(module, exports) {
    'use strict';
    var closeMiniCart = function() {
        $('.mini-cart .mini-cart-overlay').removeClass('show');
        $('.mini-cart .cart-main').remove();
        $('body').removeClass('has-mini-cart');
        $('[data-minicart-modal]').remove();
    };
    module.exports = function() {
        $('.mini-cart').on('count:update', function(event, count) {
            if (count && $.isNumeric(count.quantityTotal)) {
                $('.mini-cart .minicart-quantity').text(count.quantityTotal);
            }
        });
        $('.mini-cart').on('click', 'div.mini-cart-link', function(e) {
            e.preventDefault();
            var url = $('.mini-cart').data('action-url');
            var count = parseInt($('.mini-cart .minicart-quantity').text(), 10);
            if (count !== 0 && $('.mini-cart .mini-cart-overlay.show').length === 0) {
                $('.mini-cart .mini-cart-overlay').addClass('show');
                $('.mini-cart .mini-cart-overlay').spinner().start();
                $.get(url, function(data) {
                    $('.mini-cart .cart-mini').remove();
                    $('.mini-cart .mini-cart-overlay').append(data);
                    $.spinner().stop();
                    window.pageData.event.push({
                        type: 'cart',
                        name: 'minicart view'
                    });
                    window.pageData.cart = {};
                    window.pageData.cart = ($('[data-layer-cart]').data('layerCart'));
                    $('body').addClass('has-mini-cart');
                });
            }
            $(document).on('click', function(event) {
                if ($(event.target).parents('.mini-cart').length === 0 && $(event.target).parents('.modal').length === 0 && !$(event.target).hasClass('modal') && !$(event.target).hasClass('modal-backdrop')) {
                    closeMiniCart();
                    $(this).unbind(event);
                }
            });
        });
        $('.mini-cart').on('click', '.mini-cart__close__link', function(e) {
            e.preventDefault();
            closeMiniCart();
        });
        $('.mini-cart').on('show.bs.modal', function(e) {
            $(e.target).attr('data-minicart-modal', true).appendTo('body');
        });
    };
}), (function(module, exports) {
    'use strict';

    function closeFooterAccordionsMobile() {
        if ($(window).width() >= 768) {
            $('footer .footer-item .panel .panel-collapse').addClass('show');
            $('footer .footer-item .panel .panel-collapse').attr('id', 'desktop_no_action');
        } else {
            $('footer .footer-item .panel .accordion-toggle').addClass('collapsed');
        }
    }
    module.exports = function() {
        $('.back-to-top').click(function() {
            $('html, body').animate({
                scrollTop: 0
            }, 500);
        });
        $(function() {
            closeFooterAccordionsMobile();
        });
    };
}), (function(module, exports) {
    'use strict';
    module.exports = function() {
        var sizes = ['xs', 'sm', 'md', 'lg', 'xl'];
        sizes.forEach(function(size) {
            var selector = '.collapsible-' + size + ' .title, .collapsible-' + size + '>.card-header';
            $('body').on('click', selector, function(e) {
                e.preventDefault();
                $(this).parents('.collapsible-' + size).toggleClass('active');
            });
        });
    };
}), (function(module, exports, __webpack_require__) {
    var carousel1 = __webpack_require__(29);
    var utils = __webpack_require__(10);
    var presets = {
        default: {
            items: 4,
            mouseDrag: true,
            nav: false,
            dots: false,
            margin: 20,
            stagePadding: 60,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2,
                    margin: 50,
                    stagePadding: 50,
                    nav: true
                },
                768: {
                    items: 3,
                    margin: 70,
                    stagePadding: 70,
                    nav: true
                },
                992: {
                    items: 4,
                    margin: 20,
                    stagePadding: 100,
                    nav: true
                }
            }
        },
        orderConfirmation: {
            margin: 20,
            stagePadding: 60,
            nav: true,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2
                },
                768: {
                    items: 2,
                    margin: 40,
                    stagePadding: 40,
                    nav: true
                },
                992: {
                    items: 3,
                    margin: 20,
                    stagePadding: 100,
                    nav: true
                }
            }
        },
        orderHistorycarousel1: {
            mouseDrag: true,
            nav: true,
            dots: false,
            margin: 0,
            stagePadding: 50,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2,
                    margin: 50,
                    stagePadding: 50,
                    nav: true
                },
                768: {
                    items: 3,
                    margin: 30,
                    stagePadding: 70,
                    nav: true
                },
                992: {
                    items: 3,
                    margin: 20,
                    stagePadding: 90,
                    nav: true
                }
            }
        },
        addToBagModal: {
            items: 1,
            mouseDrag: true,
            nav: true,
            dots: false,
            margin: 20,
            stagePadding: 0,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 1
                },
                421: {
                    items: 2
                },
                601: {
                    items: 3
                },
                721: {
                    items: 4
                },
                861: {
                    items: 5
                },
                981: {
                    items: 5
                }
            }
        },
        cartRecommendationscarousel1: {
            items: 4,
            mouseDrag: true,
            nav: false,
            dots: false,
            margin: 20,
            stagePadding: 60,
            navText: [utils.generateSvgString('chevron-left-large-thin', 'product-carousel1__arrow'), utils.generateSvgString('chevron-right-large-thin', 'product-carousel1__arrow')],
            responsive: {
                0: {
                    items: 2,
                    margin: 50,
                    stagePadding: 50,
                    nav: true
                },
                768: {
                    items: 3,
                    margin: 70,
                    stagePadding: 70,
                    nav: true
                },
                992: {
                    items: 4,
                    margin: 20,
                    stagePadding: 100,
                    nav: true
                }
            }
        }
    };

    function initializecarousel1s() {
        $('.product-carousel1').each(function() {
            var preset = $(this).data('preset');
            if ($(this).parents('#addToBagOverlay').length) {
                preset = 'addToBagModal';
            }
            carousel1.init($(this), presets[preset]);
        });
    }
    $(document).on('carousel1.reinit', initializecarousel1s);
    module.exports = function() {
        initializecarousel1s();
    };
}), (function(module, exports, __webpack_require__) {
    var modal = __webpack_require__(15);
    module.exports = function() {
        var controllerUrl = $('#emailsignup-form').attr('action');
        $("[id='emailsignup-form']").submit(function(e) {
            e.preventDefault();
            $(this).find('.emailsignup-form__feedback').hide();
            var emailRegex = new RegExp('[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}');
            var emailInput = $(this).find('input[name="email"]').val();
            if (emailInput.length === 0 || !emailRegex.test(emailInput)) {
                $(this).find('.emailsignup-form__feedback').show();
                return false;
            }
            $.ajax({
                url: controllerUrl,
                type: 'POST',
                data: $(this).serialize(),
                success: function(html) {
                    modal.create('emailSignupModal', html, true);
                    modal.show();
                },
                error: function() {
                    window.console.log('Email signup failure');
                }
            });
            return false;
        });
    };
}), (function(module, exports) {
    'use strict';
    if (window.isEnableOnlineChat !== undefined && window.isEnableOnlineChat == true) {
        window.liveChatSettings = {
            brandCode: 'PUMUS',
            buttonId: '5730a000000LA7k',
            chatUrl: 'https://use.secure.force.com/ArticleSearch/apex/PUMABrandChat',
            deploymentId: '5720a000000L8VD',
            deploymentScript: 'https://c.la3-c1-phx.salesforceliveagent.com/content/g/js/44.0/deployment.js',
            endChat: {
                callback: null
            },
            inChat: {
                callback: null
            },
            initUrl: 'https://d.la3-c1-phx.salesforceliveagent.com/chat',
            orgId: '00Dj0000000Jdpt',
            preChat: {
                callback: null
            }
        };
    }
}), (function(module, exports) {
    'use strict';
    if (window.isEnableOnlineChat !== undefined && window.isEnableOnlineChat == true) {
        window.liveChatSettings = {
            brandCode: 'PUMA',
            buttonId: '5730a000000LA7k',
            chatUrl: 'http://stage-use.cs19.force.com/ArticleSearch/apex/PUMABrandChat',
            deploymentId: '5720a000000L8VD',
            deploymentScript: 'https://c.la4-c1cs-phx.salesforceliveagent.com/content/g/js/44.0/deployment.js',
            endChat: {
                callback: null
            },
            inChat: {
                callback: null
            },
            initUrl: 'https://d.la4-c1cs-phx.salesforceliveagent.com/chat',
            orgId: '00D29000000EWAZ',
            preChat: {
                callback: null
            }
        };
    }
}), (function(module, exports) {
    if (window.isEnableOnlineChat !== undefined && window.isEnableOnlineChat == true && (window.kioskJSConfig === undefined || window.kioskJSConfig.removeLiveChatElements !== true)) {
        ! function(t) {
            var e = arguments.callee;
            if (!window.liveChatSettings) throw new Error("Couldn't find LiveChat settings. Please make sure livechat-config.js is loaded before livechat.js");
            if (!window.liveChatClientSettings) throw new Error("Couldn't find LiveChat Client settings. Please make sure livechat-config-client.js is loaded before livechat.js");
            if (!window.jQuery) {
                if (!liveChatClientSettings.jQuery) throw new Error("jQuery is not loaded, and liveChatClientSettings.jQuery is not defined. Please set liveChatClientSettings.jQuery to a relative or absolute URL which points to the jQuery file you wish to load.");
                if (!e.jQueryLoading) {
                    var i = document.createElement("script");
                    i.type = "text/javascript", i.src = liveChatClientSettings.jQuery, document.getElementsByTagName("head")[0].appendChild(i), e.jQueryLoading = !0
                }
                return setTimeout(e, 10)
            }
            if (e.jQueryLoading) {
                t = jQuery.noConflict();
                e.jQueryLoading = !1
            }

            function n(t, e) {
                return e = (e || "").split("-")[0], ("object" == typeof t ? t[e || v] : t).toString() || ""
            }
            t.fn.scrollTo = function(e, i, n) {
                i || (i = 600), "function" != typeof n && (n = function() {}), t(this).stop().animate({
                    scrollTop: e
                }, i, n)
            }, t.fn.animateOnce = function(e, i, n) {
                e += " animated";
                var a = t(this);
                a.data("animate-once") && a.off("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend").removeClass(a.data("animate-once")).stop(), a.data("animate-once", e), "function" == typeof i && (n = i, i = !1), !i || "number" != typeof i && /[0-9.]+m?s/i.test(i) || (i += "s");
                var l = a.css("animation-duration");
                return "0s" === l && (l = ""), a.show(), i && a.css({
                    animationDuration: i
                }), a.addClass(e).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function(t) {
                    a.removeClass(e).off("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend"), a.data("animate-once", !1), i && a.css({
                        animationDuration: l
                    }), "function" == typeof n && n.call(this)
                }), a
            };
            var a = t(window),
                l = t(document),
                o = t("body"),
                s = t("head"),
                r = navigator.userAgent,
                d = /iPad|iPhone|iPod/i.test(r) && !window.MSStream,
                c = /iPhone|iPod|(?=.*\bAndroid\b)(?=.*\bMobile\b)|(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)|IEMobile|BB10|NokiaN9/i.test(r),
                h = !c && /iPad|Android|\bTablet\b|\b(KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b|(?=.*\bWindows\b)(?=.*\bARM\b)/i.test(r),
                v = liveChatClientSettings.language = (t("#livechat-language").val() || "").split("-")[0] || liveChatClientSettings.language || (document.location.search.match(/[?&]lang=(\w+)/i) || "")[1] || ((document.documentElement || document).lang || "").split("-")[0] || (navigator.language || "").split("-")[0] || (navigator.userLanguage || "").split("-")[0] || "en",
                u = n(liveChatSettings.chatUrl),
                g = n(liveChatSettings.buttonId),
                C = 0 !== t(".livechat-prechat").length ? "pre-chat" : -1 !== document.location.href.indexOf(u) ? "in-chat" : "client";
            if ("pre-chat" !== C && "in-chat" !== C || (0 === s.find("meta[name=viewport]").length && s.append('<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />'), liveChatClientSettings.favIcon && s.append('<link rel="icon" type="' + liveChatClientSettings.favIcon.type + '" href="' + liveChatClientSettings.favIcon.url + '">'), c && o.addClass("is-mobile"), h && o.addClass("is-tablet"), l.on("click", ".livechat-close-btn", function() {
                    window.close()
                })), "in-chat" === C) {
                var m, f = liveChatClientSettings.inChat,
                    p = f.messages;

                function b() {
                    var e = a.height(),
                        i = e - t(".livechat-client-input").outerHeight(!0) - t(".liveAgentChatWaiting").outerHeight(!0) - 5,
                        n = t(".livechat-inchat-container").css("max-height"),
                        l = t("#liveAgentClientChat").find(".row"),
                        o = t("#liveAgentChatLog");
                    n = n && "none" !== n ? parseFloat(n) : e, l.each(function() {
                        var e = t(this);
                        e.hasClass("liveAgentChatWrap") || (i -= e.outerHeight(!0))
                    }), o.css({
                        height: Math.min(i, n)
                    })
                }
                liveChatClientSettings.title && (document.title = n(liveChatClientSettings.title)), d && t(".liveAgentSaveButton").hide(), o.addClass("livechat-inchat livechat-lang-" + v), t(".liveAgentSendButton").addClass("livechat-send-btn btn"), t(".livechat-text").html(n(f.headline)), t("#liveAgentChatInput").attr("autocomplete", "off"), f.loadingText && t(".livechat-loading-text").html(n(f.loadingText)), f.subText ? t(".livechat-subtext").html(n(f.subText)) : t(".livechat-subtext").hide(), f.buttonText && (f.buttonText.endChat && (m = n(f.buttonText.endChat)) && t(".liveAgentEndButton").each(function() {
                    t(this).attr("title", m).html(m)
                }), f.buttonText.saveChat && (m = n(f.buttonText.saveChat)) && t(".liveAgentSaveButton").each(function() {
                    t(this).attr("title", m).html(m)
                }), f.buttonText.sendMessage && (m = n(f.buttonText.sendMessage)) && t(".liveAgentSendButton").each(function() {
                    t(this).attr("title", m).html(m)
                })), a.on("resize", b), liveagent.addEventListener(liveagent.chasitor.Events.CHAT_ESTABLISHED, function() {
                    b(), t(".livechat-loading-modal").hide(), t(".liveAgentEndButton").removeAttr("onclick").on("click", function(t) {
                        t.preventDefault();
                        try {
                            SfdcApp.LiveAgent.Chasitor.endChat()
                        } catch (t) {}
                    }), window.focus()
                }), liveagent.addEventListener(liveagent.chasitor.Events.CHAT_REQUEST_FAILED, function() {
                    var e = t("#liveAgentMessageContainer"),
                        i = e.find(".btn-primary");
                    if (0 === i.length) return setTimeout(arguments.callee, 100);
                    t(".livechat-loading-text").html(e.find("div > p").html()), t(".livechat-loading-image").hide(), i.on("click", function() {
                        window.close()
                    })
                });
                var S = function() {
                    t(".livechat-inchat-buttons").append('<div class="livechat-close-btn"></div>'), "function" == typeof liveChatSettings.endChat.callback && liveChatSettings.endChat.callback(), "function" == typeof liveChatClientSettings.endChat.callback && liveChatClientSettings.endChat.callback()
                };
                liveagent.addEventListener(liveagent.chasitor.Events.AGENT_CHAT_ENDED, S), liveagent.addEventListener(liveagent.chasitor.Events.CHASITOR_CHAT_ENDED, S), (p.animate || p.customClasses || p.callback) && (liveagent.addEventListener(liveagent.chasitor.Events.AGENT_CHAT_MESSAGE, function() {
                        var e = t(".operator").not("[id]").last();
                        p.customClasses && e.addClass(p.customClasses), p.animate && e.animateOnce(p.animationClass, p.animationTime), "function" == typeof p.callback && p.callback.apply(this, arguments)
                    }), liveagent.addEventListener(liveagent.chasitor.Events.CHASITOR_CHAT_MESSAGE, function() {
                        var e = t(".client").not("[id]").last();
                        p.customClasses && e.addClass(p.customClasses), p.animate && e.animateOnce(p.animationClass, p.animationTime), "function" == typeof p.callback && p.callback.apply(this, arguments)
                    })),
                    function() {
                        var e, i = liveagent.chasitor.Events,
                            n = function() {
                                var e = t("#liveAgentMessageContainer button");
                                0 !== e.length && e.addClass("btn btn-primary")
                            };
                        for (e in i) liveagent.addEventListener(i[e], n)
                    }(), liveChatSettings.inChat && "function" == typeof liveChatSettings.inChat.callback && liveChatSettings.inChat.callback(), liveChatClientSettings.inChat && "function" == typeof liveChatClientSettings.inChat.callback && liveChatClientSettings.inChat.callback(), t(function() {
                        setTimeout(function() {
                            window.scrollTo(0, 1)
                        }, 0)
                    })
            } else if ("pre-chat" === C) {
                liveChatClientSettings.title && (document.title = n(liveChatClientSettings.title));
                var w = t("#livechat-prechat-form"),
                    E = t("#livechat-session-id").val() || !1;
                if (E && !/^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$/i.test(E) && (E = !1), w.attr("action", u + "?lang=" + v + "#deployment_id=" + liveChatSettings.deploymentId + "&org_id=" + liveChatSettings.orgId + "&button_id=" + g + (E ? "&session_id=" + E : "")), w.append('<input type="hidden" name="liveagent.prechat:BrandCode" value="' + liveChatSettings.brandCode + '" />'), w.append('<input type="hidden" name="liveagent.prechat:Chat_Initiated_By" value="' + (h ? "tablet" : c ? "mobile" : "desktop") + '" />'), w.append('<input type="hidden" name="liveagent.prechat.findorcreate.map:Case" value="Chat_Initiated_By__c,Chat_Initiated_By" />'), w.append('<input type="hidden" name="liveagent.prechat.findorcreate.map.doCreate:Case" value="Chat_Initiated_By__c,true" />'), w.append('<input type="hidden" name="liveagent.prechat.save:BrandCode" value="PC_Brand_Code__c" />'), t(".livechat-text").html(n(liveChatClientSettings.preChat.headline)), liveChatClientSettings.preChat.subText ? t(".livechat-subtext").html(n(liveChatClientSettings.preChat.subText)) : t(".livechat-subtext").hide(), t("#is-existing-case").on("change", function(e) {
                        var i = t(this),
                            n = t(".existing-case-field"),
                            a = i.closest("form").data("validator"),
                            l = !!a && a.settings;
                        t(this).is(":checked") ? (n.removeClass("hidden"), t("#case-number").select(), o.scrollTo(o.prop("scrollHeight"))) : (n.addClass("hidden"), l && (n.find(l.errorElement + "." + l.errorClass.split(" ")[0] + ", .form-errors").hide(), n.find("." + l.errorClass).removeClass(l.errorClass)))
                    }), t.validator) {
                    t.extend(t.validator.messages, {
                        de: {
                            casenumber: "Bitte geben Sie eine gÃ¼ltige Bestellnummer ein.",
                            email: "Bitte geben Sie eine gÃ¼ltige E-Mail-Adresse ein.",
                            required: "Dieses Feld ist erforderlich."
                        },
                        en: {
                            casenumber: "Please enter a valid order number."
                        },
                        es: {
                            casenumber: "Introduzca un nÃºmero de pedido vÃ¡lido.",
                            email: "Por favor, introduce una direcciÃ³n de correo electrÃ³nico vÃ¡lida.",
                            required: "Este campo es obligatorio."
                        },
                        fr: {
                            casenumber: "Entrez un numÃ©ro de commande valide.",
                            email: "Veuillez indiquer une adresse de courriel valide.",
                            required: "Ce champ est obligatoire."
                        },
                        it: {
                            casenumber: "Inserisci un numero d'ordine valido.",
                            email: "Si prega di inserire un indirizzo email valido.",
                            required: "Campo obbligatorio."
                        },
                        no: {
                            casenumber: "Vennligst skriv inn et gyldig bestillingsnummer.",
                            email: "Vennligst oppgi en gyldig epostadresse.",
                            required: "Dette feltet er obligatorisk."
                        }
                    }[v]), t.validator.addMethod("email", function(t, e) {
                        return this.optional(e) || /^[a-z0-9._%'+-]+@[a-z0-9.-]+\.[a-z]{2,}$/i.test(t)
                    }, t.validator.messages.email), t.validator.addMethod("casenumber", function(e, i) {
                        return t("#is-existing-case").is(":checked") && 0 !== e.length && /^[0-9a-z]{1,30}$/i.test(e)
                    }, t.validator.messages.casenumber)
                }
                liveChatSettings.preChat && "function" == typeof liveChatSettings.preChat.callback && liveChatSettings.preChat.callback(), liveChatClientSettings.preChat && "function" == typeof liveChatClientSettings.preChat.callback && liveChatClientSettings.preChat.callback(), t(function() {
                    setTimeout(function() {
                        window.scrollTo(0, 1)
                    }, 0), t.validator && t(".form-validation").validate({
                        errorClass: "livechat-field-error",
                        errorElement: "div",
                        showErrors: function(e, i) {
                            var n = this;
                            if (0 === i.length) return t(n.settings.errorElement + "." + n.settings.errorClass.split(" ")[0] + ", .form-errors").each(function() {
                                t(this).data("animated", !1).hide()
                            }), void n.currentElements.removeClass(n.settings.errorClass);
                            var a = liveChatClientSettings.validation.errors,
                                l = a.animate,
                                o = a.callback,
                                s = a.customClasses;
                            t.each(i, function() {
                                n.defaultShowErrors();
                                var e = this.method ? n.toShow : t(this.element.nextSibling);
                                e.prepend('<span class="livechat-icon-error"></span>'), l && !e.data("animated") && (e.data("animated", !0), e.animateOnce(liveChatClientSettings.validation.errors.animationClass, liveChatClientSettings.validation.errors.animationTime)), s && e.addClass(s)
                            }), "function" == typeof o && o.call(this, i)
                        }
                    })
                })
            } else {
                var A = function() {
                    liveagent.init(liveChatSettings.initUrl, liveChatSettings.deploymentId, liveChatSettings.orgId), liveagent.setChatWindowWidth(liveChatClientSettings.windowWidth), liveagent.setChatWindowHeight(liveChatClientSettings.windowHeight), t(function() {
                        var e = t(".livechat-online"),
                            i = t(".livechat-offline"),
                            a = t(".livechat-button"),
                            l = liveChatClientSettings.windowName || !1;
                        "self" === l && (window.name ? l = window.name : window.name = l), e.each(function() {
                            var e = t(this).data("livechat-lang");
                            forButtonId = e ? n(liveChatSettings.buttonId, e) : g, liveagent.showWhenOnline(forButtonId, this)
                        }), i.each(function() {
                            var e = t(this).data("livechat-lang");
                            forButtonId = e ? n(liveChatSettings.buttonId, e) : g, liveagent.showWhenOffline(forButtonId, this)
                        }), a.each(function() {
                            var e = t(this).data("livechat-lang"),
                                i = e ? n(liveChatSettings.buttonId, e) : g;
                            liveagent.showWhenOnline(i, this), t(this).on("click", function(e) {
                                var i = t(this).data("livechat-lang"),
                                    a = i ? n(liveChatSettings.buttonId, i) : g;
                                e.preventDefault(), l ? liveagent.startChatWithWindow(a, l) : liveagent.startChat(a)
                            })
                        })
                    })
                };
                window.liveagent ? A() : t.getScript(liveChatSettings.deploymentScript).done(function() {
                    A()
                }).fail(function() {
                    throw new Error("Failed to load SalesForce deployment script!")
                })
            }
        }(window.jQuery);
    }
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var processInclude = __webpack_require__(1);
    var paypalExpress = __webpack_require__(109);
    module.exports = {
        initPayPalExress: function() {
            processInclude(paypalExpress);
        }
    };
}), (function(module, exports, __webpack_require__) {
    'use strict';
    var buttonProgressComponent = __webpack_require__(23);

    function initEvents() {
        if ($('.paypalcheckout, .cart-page').length > 0) {
            $(document).on('click', '#paypalBtn', function(e) {
                e.preventDefault();
                $('.paypal-button').click();
            });
        }
        $('body').on('cart.chekoutButtonStatusChanged', function(e, enabled) {
            $('.paypalcheckout-cart-action').toggleClass('d-none', !enabled);
        });
        buttonProgressComponent.functions.init('#paypalBtn, .paypal-button');
    }

    function checkoutReady() {
        var PAYPALMERCHANT_ID = $('.paypalcheckout').attr('data-merchantId');
        var INSTANCE_TYPE = $('.paypalcheckout').attr('data-environment');
        window.paypal.checkout.setup(PAYPALMERCHANT_ID, {
            environment: INSTANCE_TYPE,
            buttons: [{
                container: 'paypal-incontext',
                type: 'checkout',
                color: 'silver',
                size: 'medium',
                shape: 'rect'
            }]
        });
        initEvents();
    }

    function loadPayPalCheckoutJS() {
        var s = document.createElement('script');
        var INSTANCE_TYPE = $('.paypalcheckout').attr('data-environment');
        var PAYPAL_OBJECTS_SRC = $('.paypalcheckout').attr('data-paypalobjectssrc');
        s.setAttribute('type', 'text/javascript');
        s.setAttribute('name', 'paypalcheckout');
        s.setAttribute('data-env', INSTANCE_TYPE);
        s.setAttribute('src', PAYPAL_OBJECTS_SRC);
        s.onload = function() {
            checkoutReady();
            window.paypalCheckoutJS = true;
        };
        document.body.appendChild(s);
    }
    module.exports = function() {
        if (!window.paypalCheckoutJS && window.isEnablePayPal !== undefined && window.isEnablePayPal == true) {
            loadPayPalCheckoutJS();
        }
    };
}), (function(module, exports) {
    'use strict';

    function initModalFix() {
        var isIOS11 = isAffectedIphone();
        if (isIOS11) {
            $(document).on('show.bs.modal', function() {
                var offset = $(window).scrollTop();
                $('body').css({
                    position: 'fixed',
                    top: '-' + offset + 'px'
                });
            });
            $(document).on('hide.bs.modal', function() {
                $('body').css({
                    position: '',
                    top: ''
                });
            });
        }
    }

    function isAffectedIphone() {
        var isAffectedIOS = false;
        var userAgent = navigator.userAgent;
        if (userAgent.indexOf('iPhone OS 11') >= 0 && userAgent.search(/iPhone OS 11_[3-9]/) < 0) {
            isAffectedIOS = true;
        }
        return isAffectedIOS;
    }
    module.exports = {
        initModalFix: initModalFix
    };
}), (function(module, exports) {
    'use strict';

    function placeButtonInFooter() {
        $('button .optanon-show-settings').css('display', 'inline');
        let MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
        let pageFooter = document.querySelector('footer');
        let observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (!mutation.addedNodes) {
                    return;
                }
                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    if (mutation.addedNodes[i].className === 'optanon-show-settings-popup-wrapper') {
                        if ($.contains(pageFooter, mutation.addedNodes[i])) {
                            $('.menu-footer').eq(2).append(mutation.addedNodes[i]);
                        }
                        mutation.addedNodes[i].classList.remove('optanon-show-settings-popup-wrapper');
                        $('.optanon-show-settings').css('display', 'inline');
                        break;
                    }
                }
            });
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false,
            characterData: false
        });
    }
    module.exports = function() {
        placeButtonInFooter();
    };
})]);